graph lpg {

    /**************************************************************************/
    /* Receive                                                                */

    cluster Rx {
        node Queue {
            attr "source"
            port out[L2EtherClassified]
            port drop[]
            port init[Init]
        }

        node Init {
            spawn init .TxL3ARPSendGratuitous /* [predicate "and(pred(EthType,ARP))"] */
        }

        /*******************************************/
        /* Ethernet RX                             */

        cluster L2Ether {
            boolean Classified {
                port true[ValidLength]
                port false[]
                semantics true { (= L2P.Ethernet (L2.Proto pkt)) }}

            boolean ValidLength {
                port true[ValidUnicast ValidMulticast ValidBroadcast
                          ValidSrc ValidType ValidLocalMAC]
                port false[] }

            boolean ValidUnicast {
                port true false[ValidDest] }

            boolean ValidMulticast {
                port true false[ValidDest] }

            boolean ValidBroadcast {
                port true false[ValidDest] }

            or ValidDest {
                port true false[Valid] }

            boolean ValidSrc {
                port true false[Valid] }

            boolean ValidLocalMAC {
                port true false[Valid] }

            /* Note that .L3ARPNeedsResponse .L3ARPValidPendingResponse probably
             * belong in here */
            and Valid {
                port true false[.L3IPAndBelowValid] }

            boolean ValidType {
                port true[ClassifyL3]
                port false[] }

            node ClassifyL3 {
                port ipv4[.L3IPv4ValidHeaderLength]
                port ipv6[]
                port arp[.L3ARPValidHeaderLength]
                port drop[]
                semantics ipv4 { (= L3P.IP4 (L3.Proto pkt)) }
                semantics ipv6 { (= L3P.IP6 (L3.Proto pkt)) }
                semantics arp { (= L3P.ARP (L3.Proto pkt)) }

                predicate ipv4 "pred(EthType, IPv4)"
                predicate arp  "pred(EthType, ARP)"
            }
        }


        /*******************************************/
        /* ARP RX                                  */

        cluster L3ARP {
            boolean ValidHeaderLength {
                port true[Classify LocalIPDest]
                port false[] }

            node Classify {
                port request[ValidRequest]
                port response[ValidResponse]
                port drop[] }

            boolean LocalIPDest {
                port true false[NeedsResponse ValidPendingResponse] }

            boolean ValidRequest {
                port true false[NeedsResponse] }

            and NeedsResponse {
                port true[InitResponse]
                port false[] }

            node InitResponse {
                spawn responose ..TxL3ARPInitiateResponse
            }

            boolean ValidResponse {
                port true[IsPending]
                port false[]
            }

            boolean IsPending {
                port true false[ValidPendingResponse] }

            and ValidPendingResponse {
                port true[ProcessPendingResponse]
                port false[] }

            // for now we hard-code that the restart operation will result in an IPv4 packet
            node ProcessPendingResponse {
                spawn restart ..TxL3ARPLookupRequestIn [predicate "pred(EthType,IPv4)"]
                port out [] }


        }


        /*******************************************/
        /* IPv4 RX                                 */

        cluster L3IPv4 {
            boolean ValidHeaderLength {
                port true[ValidReassembly ValidVersion ValidLength
                          ValidTTL ValidChecksum Classify ValidLocalIP]
                port false[] }

            boolean ValidReassembly {
                port true false[Valid] }

            boolean ValidVersion {
                port true false[Valid] }

            boolean ValidLength {
                port true false[Valid] }

            boolean ValidTTL {
                port true false[Valid] }

            boolean ValidChecksum {
                port true false[Valid] }

            boolean ValidLocalIP {
                port true false[Valid] }

            node Classify {
                port udp[.L4UDPValidHeaderLength]
                port icmp[.L3ICMPValidHeaderLength]
                port drop[]
                semantics udp { (= L4P.UDP (L4.Proto pkt)) }
                semantics icmp { (= L4P.ICMP (L4.Proto pkt)) } }

            and Valid {
                port true false[.L3IPValid] }

        }


        /*******************************************/
        /* IPv6 RX                                 */

        /*boolean L3IPv6ValidHeaderLength {
            port true false[L3IPValid] }*/



        or L3IPValid {
            port true false[L3IPAndBelowValid] }

        and L3IPAndBelowValid {
            port true false[L3ICMPValid L4UDPValid] }


        /*******************************************/
        /* ICMP RX                                 */

        cluster L3ICMP {
            boolean ValidHeaderLength {
                port true[ValidChecksum IsTypeRequest]
                port false[] }

            boolean ValidChecksum {
                port true false[Valid] }

            and Valid {
                port true false[NeedsResponse_] }

            boolean IsTypeRequest {
                port true false[NeedsResponse_] }

            and NeedsResponse_ {
                port true[NeedsResponse]
                port false[] }

            node NeedsResponse {
                spawn response ..TxL3ICMPInitiateResponse [predicate "and(pred(EthType,IPv4),pred(IpProt,ICMP))"]
            }
        }

        /*******************************************/
        /* UDP RX                                  */

        cluster L4UDP {
            boolean ValidHeaderLength {
                port true[CUDPSockets ValidLength ValidChecksum]
                port false[CUDPSockets] }

            boolean ValidLength {
                port true false[Valid] }

            boolean ValidChecksum {
                port true false[Valid] }

            and Valid {
                port true[CUDPSockets]
                port false[] }

            config CUDPSockets {
                type { (id:    UInt64,
                        sIP:   <UInt 32>,
                        sPort: <UInt 16>,
                        dIP:   <UInt 32>,
                        dPort: <UInt 16>) }
                port unused[UnusedPort]
                port true[..TxL4UDPStart] }

            nor UnusedPort {
                port false[]
                port true[ClosedPortAction] }

            node ClosedPortAction {
                port out[] }

        }

    } // end cluster: Rx


    cluster Tx {
        cluster L4UDP {

            or Start {
                port true[InitiateResponse]
                port false[]
            }

            node InitiateResponse {
                port out[AllocateHeader]
                port drop[] }

            node AllocateHeader {
                port true[FillHeader FillChecksum .L3IPv4Prepare] }

            node FillHeader   { port true[Done] }
            node FillChecksum { port true[Done] }

            and Done { port true false[.UDPv4Done] }
        }

        cluster L3ICMP {
            node InitiateResponse {
                port out[AllocateHeader] }

            node AllocateHeader {
                port true[FillHeader .L3IPv4Prepare] }

            boolean FillHeader {
                port true false[Done] }

            and Done {
                port true false[.L3_AND_L4Done] }
        }

        cluster L3IPv4 {
            or Prepare {
                port true[AllocateHeader]
                port false[] }

            node AllocateHeader {
                port out[FillHeader FillChecksum Routing] }

            node FillHeader {
                port true[Done] }


            node FillChecksum {
                    port true[Done] }

            boolean Routing {
                port true false[.L3ARPLookup] }

            and Done { // UDPv4Done
                    port true false [.UDPv4Done .L3ICMPDone]
            }
        }

        cluster L3ARP {
            node SendGratuitous {
                attr "noreplicateininout"
                port false true[Prepare]

                predicate true "pred(EthType,ARP)"
            }

            node InitiateResponse {
                port false true[Prepare]
                port drop[]

               predicate true "pred(EthType,ARP)"
            }

            or Prepare {
                port true[AllocateHeader .L3_AND_L4Done] // we are sending ARP, no need to wait for anything else
                port false[] }

            node AllocateHeader {
                port out[FillHeader] }

            boolean FillHeader {
                port true false[.L2EtherPrepare] }

            boolean LookupRequestIn {
                port true false[Lookup]
            }

            or Lookup {
                port true[Lookup_]
                port false[] }

            node Lookup_ {
                spawn miss SendRequest
                port false true[.L2EtherPrepare]
                port miss[] }

            node SendRequest {
                attr "noreplicateout"
                port false true[Prepare]
                port drop[]

                predicate true "pred(EthType,ARP)"
            }
        }

        and UDPv4Done {
                port true[L3_AND_L4Done]
                port false[]
        }

        // L4 and L3 done
        // ICMP/ARP are not technically L4, but ICMP_OR_TCP_OR_UDP_OR_ARP__DONE is probably a more confusing name
        or L3_AND_L4Done {
                port true[Done]
                port false[]
        }


        cluster L2Ether {
            or Prepare {
                port true[AllocateHeader]
                port false[] }

            node AllocateHeader {
                port out[FillHeader] }

            node FillHeader {
                port true[.Done] }
        }

        and Done {
                port true[Queue]
                port false[]
        }

        node Queue {
            attr "sink"
            port out[]
        }
    }
}
