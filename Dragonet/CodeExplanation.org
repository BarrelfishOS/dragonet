Document format: orgmode
Document Objective: Understanding high level code functionality

* Steps in starting the stack

** Oracle selection and setup
 * Based on the commandline parameter, decide which Oracle to use
 * Configure the Oracle parameters to form a closure which can be called later
    only with flows information.
 * The important parameters are
   - Cost function: balanced, priority
   - Search type: Greedy, exhaustive?

** Instantiate the stack
 * Configure how to handle events generated by applications
 * Provide a way to update the graph in order to handle application events
    - [[updateGraph]] function
 * Create initial minimal graph based on empty list of connection flows
    - This is done by manually calling [[updateGraph]] function

** updateGraph
Function 'updateGraph' adapts the graph to current stack state.
It does following things:
 * Generates all the endpoints from current stack-state,
 * Generates an LPG based on the stack-state
 * STEP: Finds out best PRG configuration for current state by using given Oracle
 * Decides on transformations to be applied on the graph before implementing it
 * STEP: Generate a combined pipelined-graph, based on the above PRG, LPG and
        transformations
 * STEP: Applies the configuration changes
 * STEP: Runs the pipelines

This function will be called in following situations
 * To manually kickoff start of the stack (only once, in this function)
 * App event UDPListen
 * App event UDPFlow
 * App event SpanSocket


** Calling Oracle
 * Called from [[updateGraph]] with current active flows as parameter
 * The actual call path looks something like follow:
 * Search.runSearch
    * Initialize the state based on the parameters
    * doSearch
      - It sorts the flow list using the function 'sOrderFlows' from parameter
      - Then it applies the search strategy given in 'sStrategy' parameter
          with current search state to find a configuation
      - Possible strategies: [[searchGreedyFlows]], etc...

*** searchGreedyFlows

 * Recursive search in configuration space where
    * We consider one flow at time, and find best configuration
       for that flow from current state.
    * Update current state by adding best configuration selected above
    * Recursively consider rest of the flow, but with updated current state

 * Relies on two important parts:
    * Suggestion for configuring given flow.  Implemented by [[OracleSt]] class
    * [[cost-function]] to evaluate given configuring

**** Complexity of this algorithm
 * q == number of queues
 * n == number of flows
 * For every flow, we will evaluate 'O(q)' configurations
 * So, the overall complexity of [[searchGreedyFlows]] is
           'O(nq) * O(cost-functions)'

*** cost-function

 * Given a QMap [(Flow, QueueID)], it evaluates and gives a numeric score
    showing the cost of making assignments represented by QMap.

*** OracleSt
 * Has interface `flowConfChanges` which promises to give list of possible
    configurations suitable for given flow, with given current configuration.
 * Currently e10k is using a basic implementation of flowConfChanges where
    - given flow is mapped to all the queues, irrespective of current status
        of that queue.
    - For every flow, it generates [nQueue] configurations
    - It counts on cost-function to evaluate these configurations to choose
        the best one.
    - So, the complexity of current implementation is 'O(q)'

** Applying configuration changes to the driver
 * This is NIC specific function, which translates configuration changes
    suggested by Oracle into actions for the [[driver-thread]]
    which controls the device driver.
 * It remembers the current state of the device and only applies the changes
    which are actually needed, so that we don't endup inserting same filter
    again and again with every [[updateGraph]]
 * Runs a dedicated control thread which will loop infinitely waiting for
    commands to the driver, and implement those commands
 * Implementation in stack-dpdk.hs: `implCfg`
    * Make sure that there is a thread running to handle driver changes (driver-thread)
    * Translate the configuration changes into filter specific actions
    * Find the differences in the existing filter configuration and the
       one requested.  This should tell which filters to remove and which to add
    * Send a message to driver-thread about removing and adding filters using STM
    * Update the current state to reflect the new allocation of filters

** driver-thread
 * It is implemented as a haskell thread (and not an OS-level thread)
 * Reads a Software Transaction based channel for commands (CfgAction)
      for the driver and executes them.
 * The typical commands are in type CfgAction
        - set5Tuple, clear5Tuple, setFDir, clearFDir
 * It keeps doing that in an infinite loop
 * The actions are typically sent by using C function interface.

** Running a pipelined graph
For every pipeline in pipelined graph

The function 'run' calls "runPipelines'" which will run each pipeline
     individually by using the 'pipeline init' function provided here.

Defines a function 'pipeline init', which
     * starts new pipeline if it does not exist,
     * updates the connection queues if the pipeline already exists


*** Pipeline initialization/Update

Function 'pinit': pipeline initialization code for given pipeline
  * Reads the current state of pipelines from STM
  * If given pipeline exists in it then
     + stop it
     + get the config and in, out queues for it
  * Else: (given pipeline does not exists in it)
     + Create new pipeline with empty in, out queues (this will create an OS thread)
  * Add/remove queue in the In and Out list based on
     + has new queue added (new connection)
     + has existing queue removed (close, re-route connection)
  * Update the graph associated with the pipeline
  * Restart the execution of the pipeline

