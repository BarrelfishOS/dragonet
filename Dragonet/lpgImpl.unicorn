graph lpg {
    node SoftwareRX {
        port out[RxL2EtherClassified] }

    node PacketDrop { }


    /**************************************************************************/
    /* Receive                                                                */

    cluster Rx {

        /*******************************************/
        /* Ethernet RX                             */

        cluster L2Ether {
            boolean Classified {
                port true[ValidLength]
                port false[..PacketDrop] }

            boolean ValidLength {
                port true[ValidUnicast ValidMulticast ValidBroadcast
                          ValidSrc ValidType ValidLocalMAC]
                port false[..PacketDrop] }

            boolean ValidUnicast {
                port true false[ValidDest] }

            boolean ValidMulticast {
                port true false[ValidDest] }

            boolean ValidBroadcast {
                port true false[ValidDest] }

            or ValidDest {
                port true false[Valid] }

            boolean ValidSrc {
                port true false[Valid] }

            boolean ValidLocalMAC {
                port true false[Valid] }

            and Valid {
                port true false[.L3IPAndBelowValid] }

            boolean ValidType {
                port true[ClassifyL3]
                port false[..PacketDrop] }

            node ClassifyL3 {
                port ipv4[.L3IPv4ValidHeaderLength]
                port ipv6[.L3IPv6ValidHeaderLength]
                port arp[.L3ARPValidHeaderLength]
                port drop[..PacketDrop] }
        }


        /*******************************************/
        /* ARP RX                                  */

        cluster L3ARP {
            boolean ValidHeaderLength {
                port true[Classify LocalIPDest]
                port false[..PacketDrop] }

            node Classify {
                port request[ValidRequest]
                port response[ValidResponse]
                port drop[..PacketDrop] }

            boolean LocalIPDest {
                port true false[NeedsResponse ValidPendingResponse] }

            boolean ValidRequest {
                port true false[NeedsResponse] }

            and NeedsResponse {
                port true[..TxL3ARPInitiateResponse]
                port false[] }

            boolean ValidResponse {
                port true false[ValidPendingResponse IsPending] }

            boolean IsPending {
                port true false[ValidPendingResponse] }

            and ValidPendingResponse {
                port true[ProcessPendingResponse]
                port false[] }

            node ProcessPendingResponse {
                port true false[..TxL3ARPLookup]
                port drop[] }
        }


        /*******************************************/
        /* IPv4 RX                                 */

        cluster L3IPv4 {
            boolean ValidHeaderLength {
                port true[ValidReassembly ValidVersion ValidLength
                          ValidTTL ValidChecksum Classify ValidLocalIP]
                port false[..PacketDrop] }

            boolean ValidReassembly {
                port true false[Valid] }

            boolean ValidVersion {
                port true false[Valid] }

            boolean ValidLength {
                port true false[Valid] }

            boolean ValidTTL {
                port true false[Valid] }

            boolean ValidChecksum {
                port true false[Valid] }

            boolean ValidLocalIP {
                port true false[Valid] }

            node Classify {
                port tcp[.L4TCPValidHeaderLength]
                port udp[.L4UDPValidHeaderLength]
                port icmp[.L3ICMPValidHeaderLength]
                port drop[..PacketDrop] }

            and Valid {
                port true false[.L3IPValid] }

        }


        /*******************************************/
        /* IPv6 RX                                 */

        boolean L3IPv6ValidHeaderLength {
            port true false[L3IPValid] }



        or L3IPValid {
            port true false[L3IPAndBelowValid] }

        and L3IPAndBelowValid {
            port true false[L3ICMPValid L4TCPValid L4UDPValid] }


        /*******************************************/
        /* ICMP RX                                 */

        cluster L3ICMP {
            boolean ValidHeaderLength {
                port true[ValidChecksum IsTypeRequest]
		port false[] }

            boolean ValidChecksum {
                port true false[Valid] }

            and Valid {
                port true false[NeedsResponse] }

            boolean IsTypeRequest {
                port true false[NeedsResponse] }

            and NeedsResponse {
                port true[..TxL3ICMPInitiateResponse]
                port false[] }
        }

        /*******************************************/
        /* UDP RX                                  */

        cluster L4UDP {
            boolean ValidHeaderLength {
                port true[ValidLength ValidChecksum]
                port false[..PacketDrop] }

            boolean ValidLength {
                port true false[Valid] }

            boolean ValidChecksum {
                port true false[Valid] }

            and Valid {
                port true[PortClassify]
                port false[..PacketDrop] }

            node PortClassify {
                port appDNS [.DnsAPP]
                port closedPort [ClosedPortAction]
            }

            node ClosedPortAction { }

        }


        /*******************************************/
        /* TCP RX                                  */

        cluster L4TCP {
            boolean ValidHeaderLength {
                port true false[Valid] }

            and Valid {
                port true[Out]
                port false[..PacketDrop] }

            node Out { }
        }


        /*******************************************/
        /* Application RX                          */

    node DnsAPP {
                port out[.TxL4UDPInitiateResponse]
                port drop[.PacketDrop] }


    }


    cluster Tx {

        cluster L4UDP {
            node InitiateResponse {
                port out[AllocateHeader]
		port drop[] }

            node AllocateHeader {
                port out[FillHeader] }

            boolean FillHeader {
                port true false[.L3IPv4Prepare] }
        }


        cluster L3ICMP {
            node InitiateResponse {
                port out[AllocateHeader]
		port drop[] }

            node AllocateHeader {
                port out[FillHeader] }

            boolean FillHeader {
                port true false[.L3IPv4Prepare] }
        }

	cluster L3IPv4 {
            or Prepare {
                port true[AllocateHeader]
                port false[] }

            node AllocateHeader {
                port out[FillHeader] }

            node FillHeader {
                port out[Routing] }

            boolean Routing {
                port true false[.L3ARPLookup] }
        }

        cluster L3ARP {
            node InitiateResponse {
                port true false[Prepare]
		port drop[] }

            or Prepare {
                port true[AllocateHeader]
                port false[] }

            node AllocateHeader {
                port out[FillHeader] }

            boolean FillHeader {
                port true false[.L2EtherPrepare] }

            or Lookup {
                port true[Lookup_]
                port false[] }

            node Lookup_ {
                port true false[.L2EtherPrepare]
                port miss[SendRequest] }

            node SendRequest {
                port true false[Prepare]
                port drop[] }
        }

        cluster L2Ether {
            or Prepare {
                port true[AllocateHeader]
                port false[] }

            node AllocateHeader {
                port out[FillHeader] }

            node FillHeader {
                port out[.Queue] }
        }

        node Queue { }
    }
}
