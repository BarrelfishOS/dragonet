#ifndef __e10k_DEV_H
#define __e10k_DEV_H 1
/*
 * DEVICE DEFINITION: Intel 82599 10 GbE Controller
 * 
 * Copyright (c) 2010, ETH Zurich.
 * All rights reserved.
 * 
 * This file is distributed under the terms in the attached LICENSE
 * file. If you do not find this file, copies can be found by
 * writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.
 * Attn: Systems Group.
 * 
 * THIS FILE IS AUTOMATICALLY GENERATED BY MACKEREL: DO NOT EDIT!
 */
#include <mackerel/mackerel.h>
#include <inttypes.h>
#undef __DN
#define __DN(x) e10k ## _ ## x
/*
 * Constants defn: e10k.lanid (LAN ID)
 *  - no width specified
 */
typedef uint8_t e10k_lanid_t;
#define e10k_lan_0 ((e10k_lanid_t)0x0)
#define e10k_lan_1 ((e10k_lanid_t)0x1)
#define e10k_lan_not_u1 ((e10k_lanid_t)0x2)
#define e10k_lan_not_u2 ((e10k_lanid_t)0x3)

static inline char *e10k_lanid_describe(e10k_lanid_t _e) __attribute__ ((always_inline));
static inline char *e10k_lanid_describe(e10k_lanid_t _e)
{
    switch (_e) {
    case e10k_lan_0:
        return("lan_0: LAN 0");
    case e10k_lan_1:
        return("lan_1: LAN 1");
    case e10k_lan_not_u1:
        return("lan_not_u1: LAN ID not used");
    case e10k_lan_not_u2:
        return("lan_not_u2: LAN ID not used");
    default:
        return(NULL);
    }
}

static inline int e10k_lanid_prtval(char *_s, size_t _size, e10k_lanid_t _e) __attribute__ ((always_inline));
static inline int e10k_lanid_prtval(char *_s, size_t _size, e10k_lanid_t _e)
{
    char *d = e10k_lanid_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_lanid_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.ledmode (LED Mode)
 *  - no width specified
 */
typedef uint8_t e10k_ledmode_t;
#define e10k_link_up ((e10k_ledmode_t)0x0)
#define e10k_link_10g ((e10k_ledmode_t)0x1)
#define e10k_mac_act ((e10k_ledmode_t)0x2)
#define e10k_filter_act ((e10k_ledmode_t)0x3)
#define e10k_link_act ((e10k_ledmode_t)0x4)
#define e10k_link_1g ((e10k_ledmode_t)0x5)
#define e10k_link_100 ((e10k_ledmode_t)0x6)
#define e10k_led_on ((e10k_ledmode_t)0xe)
#define e10k_led_off ((e10k_ledmode_t)0xf)

static inline char *e10k_ledmode_describe(e10k_ledmode_t _e) __attribute__ ((always_inline));
static inline char *e10k_ledmode_describe(e10k_ledmode_t _e)
{
    switch (_e) {
    case e10k_link_up:
        return("link_up: Link established and maintained");
    case e10k_link_10g:
        return("link_10g: 10G Link established and maintained");
    case e10k_mac_act:
        return("mac_act: MAC activity");
    case e10k_filter_act:
        return("filter_act: MAC activity that passed MAC filters");
    case e10k_link_act:
        return("link_act: Steady when link good, blinking on activity");
    case e10k_link_1g:
        return("link_1g: 1G Link established and maintained");
    case e10k_link_100:
        return("link_100: 100M Link established and maintained");
    case e10k_led_on:
        return("led_on: LED on");
    case e10k_led_off:
        return("led_off: LED off");
    default:
        return(NULL);
    }
}

static inline int e10k_ledmode_prtval(char *_s, size_t _size, e10k_ledmode_t _e) __attribute__ ((always_inline));
static inline int e10k_ledmode_prtval(char *_s, size_t _size, e10k_ledmode_t _e)
{
    char *d = e10k_ledmode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_ledmode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.fwe_control (Flash Write Enable Control)
 *  - no width specified
 */
typedef uint8_t e10k_fwe_control_t;
#define e10k_fwe_erase ((e10k_fwe_control_t)0x0)
#define e10k_fwe_nowrite ((e10k_fwe_control_t)0x1)
#define e10k_fwe_write ((e10k_fwe_control_t)0x2)

static inline char *e10k_fwe_control_describe(e10k_fwe_control_t _e) __attribute__ ((always_inline));
static inline char *e10k_fwe_control_describe(e10k_fwe_control_t _e)
{
    switch (_e) {
    case e10k_fwe_erase:
        return("fwe_erase: Flash erase");
    case e10k_fwe_nowrite:
        return("fwe_nowrite: Flash writes disabled");
    case e10k_fwe_write:
        return("fwe_write: Flash writes enabled");
    default:
        return(NULL);
    }
}

static inline int e10k_fwe_control_prtval(char *_s, size_t _size, e10k_fwe_control_t _e) __attribute__ ((always_inline));
static inline int e10k_fwe_control_prtval(char *_s, size_t _size, e10k_fwe_control_t _e)
{
    char *d = e10k_fwe_control_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_fwe_control_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.eeprom_size (EEPROM Size)
 *  - no width specified
 */
typedef uint8_t e10k_eeprom_size_t;
#define e10k_eesz_16K ((e10k_eeprom_size_t)0x4)
#define e10k_eesz_32K ((e10k_eeprom_size_t)0x5)
#define e10k_eesz_64K ((e10k_eeprom_size_t)0x6)
#define e10k_eesz_128K ((e10k_eeprom_size_t)0x7)
#define e10k_eesz_256K ((e10k_eeprom_size_t)0x8)

static inline char *e10k_eeprom_size_describe(e10k_eeprom_size_t _e) __attribute__ ((always_inline));
static inline char *e10k_eeprom_size_describe(e10k_eeprom_size_t _e)
{
    switch (_e) {
    case e10k_eesz_16K:
        return("eesz_16K: 16Kb, 2B Address Size");
    case e10k_eesz_32K:
        return("eesz_32K: 32Kb, 2B Address Size");
    case e10k_eesz_64K:
        return("eesz_64K: 64Kb, 2B Address Size");
    case e10k_eesz_128K:
        return("eesz_128K: 128Kb, 2B Address Size");
    case e10k_eesz_256K:
        return("eesz_256K: 256Kb, 2B Address Size");
    default:
        return(NULL);
    }
}

static inline int e10k_eeprom_size_prtval(char *_s, size_t _size, e10k_eeprom_size_t _e) __attribute__ ((always_inline));
static inline int e10k_eeprom_size_prtval(char *_s, size_t _size, e10k_eeprom_size_t _e)
{
    char *d = e10k_eeprom_size_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_eeprom_size_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.flmng_command (Commands to access flash)
 *  - no width specified
 */
typedef uint8_t e10k_flmng_command_t;
#define e10k_fl_read ((e10k_flmng_command_t)0x0)
#define e10k_fl_write ((e10k_flmng_command_t)0x1)
#define e10k_fl_secerase ((e10k_flmng_command_t)0x2)
#define e10k_fl_erase ((e10k_flmng_command_t)0x3)

static inline char *e10k_flmng_command_describe(e10k_flmng_command_t _e) __attribute__ ((always_inline));
static inline char *e10k_flmng_command_describe(e10k_flmng_command_t _e)
{
    switch (_e) {
    case e10k_fl_read:
        return("fl_read: Read command");
    case e10k_fl_write:
        return("fl_write: Write command");
    case e10k_fl_secerase:
        return("fl_secerase: Sector erase");
    case e10k_fl_erase:
        return("fl_erase: Erase");
    default:
        return(NULL);
    }
}

static inline int e10k_flmng_command_prtval(char *_s, size_t _size, e10k_flmng_command_t _e) __attribute__ ((always_inline));
static inline int e10k_flmng_command_prtval(char *_s, size_t _size, e10k_flmng_command_t _e)
{
    char *d = e10k_flmng_command_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_flmng_command_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.tfc_status (Transmit Flow Control Status)
 *  - no width specified
 */
typedef uint8_t e10k_tfc_status_t;
#define e10k_tfc_dis ((e10k_tfc_status_t)0x0)
#define e10k_lfc_en ((e10k_tfc_status_t)0x1)
#define e10k_pfc_en ((e10k_tfc_status_t)0x2)

static inline char *e10k_tfc_status_describe(e10k_tfc_status_t _e) __attribute__ ((always_inline));
static inline char *e10k_tfc_status_describe(e10k_tfc_status_t _e)
{
    switch (_e) {
    case e10k_tfc_dis:
        return("tfc_dis: Transmit flow control disabled");
    case e10k_lfc_en:
        return("lfc_en: Link flow control enabled");
    case e10k_pfc_en:
        return("pfc_en: Priority flow control enabled");
    default:
        return(NULL);
    }
}

static inline int e10k_tfc_status_prtval(char *_s, size_t _size, e10k_tfc_status_t _e) __attribute__ ((always_inline));
static inline int e10k_tfc_status_prtval(char *_s, size_t _size, e10k_tfc_status_t _e)
{
    char *d = e10k_tfc_status_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_tfc_status_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.pcie_capability_version (PCIe Capability Version)
 *  - no width specified
 */
typedef uint8_t e10k_pcie_capability_version_t;
#define e10k_ver1 ((e10k_pcie_capability_version_t)0x0)
#define e10k_ver2 ((e10k_pcie_capability_version_t)0x1)

static inline char *e10k_pcie_capability_version_describe(e10k_pcie_capability_version_t _e) __attribute__ ((always_inline));
static inline char *e10k_pcie_capability_version_describe(e10k_pcie_capability_version_t _e)
{
    switch (_e) {
    case e10k_ver1:
        return("ver1: Capability version: 0x1");
    case e10k_ver2:
        return("ver2: Capability version: 0x2");
    default:
        return(NULL);
    }
}

static inline int e10k_pcie_capability_version_prtval(char *_s, size_t _size, e10k_pcie_capability_version_t _e) __attribute__ ((always_inline));
static inline int e10k_pcie_capability_version_prtval(char *_s, size_t _size, e10k_pcie_capability_version_t _e)
{
    char *d = e10k_pcie_capability_version_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_pcie_capability_version_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.pcie_statenc (PCIe Statistic Events Encoding)
 *  - no width specified
 */
typedef uint8_t e10k_pcie_statenc_t;
#define e10k_bad_tlp ((e10k_pcie_statenc_t)0x0)
#define e10k_no_req_tout ((e10k_pcie_statenc_t)0x10)
#define e10k_nack_dllp ((e10k_pcie_statenc_t)0x20)
#define e10k_repl_tout ((e10k_pcie_statenc_t)0x21)
#define e10k_recv_error ((e10k_pcie_statenc_t)0x22)
#define e10k_repl_rollov ((e10k_pcie_statenc_t)0x23)
#define e10k_resnd_pkg ((e10k_pcie_statenc_t)0x24)
#define e10k_sp_linkdown ((e10k_pcie_statenc_t)0x25)
#define e10k_ltssm_l0_rt ((e10k_pcie_statenc_t)0x30)
#define e10k_ltssm_l0_rx ((e10k_pcie_statenc_t)0x31)
#define e10k_ltssm_l0_tx ((e10k_pcie_statenc_t)0x32)
#define e10k_ltssm_l1act ((e10k_pcie_statenc_t)0x33)
#define e10k_ltssm_l1sft ((e10k_pcie_statenc_t)0x34)
#define e10k_ltssm_recov ((e10k_pcie_statenc_t)0x35)

static inline char *e10k_pcie_statenc_describe(e10k_pcie_statenc_t _e) __attribute__ ((always_inline));
static inline char *e10k_pcie_statenc_describe(e10k_pcie_statenc_t _e)
{
    switch (_e) {
    case e10k_bad_tlp:
        return("bad_tlp: Bad TLP from LL");
    case e10k_no_req_tout:
        return("no_req_tout: Requests that reached timeout");
    case e10k_nack_dllp:
        return("nack_dllp: NACK DLLP received");
    case e10k_repl_tout:
        return("repl_tout: Replay happened in retry buffer");
    case e10k_recv_error:
        return("recv_error: Receive error");
    case e10k_repl_rollov:
        return("repl_rollov: Replay roll over");
    case e10k_resnd_pkg:
        return("resnd_pkg: Re-sending packets");
    case e10k_sp_linkdown:
        return("sp_linkdown: Surprise link down");
    case e10k_ltssm_l0_rt:
        return("ltssm_l0_rt: LTSSM in L0s in both Rx and Tx");
    case e10k_ltssm_l0_rx:
        return("ltssm_l0_rx: LTSSM in L0s in Rx");
    case e10k_ltssm_l0_tx:
        return("ltssm_l0_tx: LTSSM in L0s in Tx");
    case e10k_ltssm_l1act:
        return("ltssm_l1act: LTSSM in L1 active");
    case e10k_ltssm_l1sft:
        return("ltssm_l1sft: LTSSM in L1 software");
    case e10k_ltssm_recov:
        return("ltssm_recov: LTSSM in recovery");
    default:
        return(NULL);
    }
}

static inline int e10k_pcie_statenc_prtval(char *_s, size_t _size, e10k_pcie_statenc_t _e) __attribute__ ((always_inline));
static inline int e10k_pcie_statenc_prtval(char *_s, size_t _size, e10k_pcie_statenc_t _e)
{
    char *d = e10k_pcie_statenc_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_pcie_statenc_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.power_state (Power State indication)
 *  - no width specified
 */
typedef uint8_t e10k_power_state_t;
#define e10k_ps_dr ((e10k_power_state_t)0x0)
#define e10k_ps_d0u ((e10k_power_state_t)0x1)
#define e10k_ps_d0a ((e10k_power_state_t)0x2)
#define e10k_ps_d3 ((e10k_power_state_t)0x3)

static inline char *e10k_power_state_describe(e10k_power_state_t _e) __attribute__ ((always_inline));
static inline char *e10k_power_state_describe(e10k_power_state_t _e)
{
    switch (_e) {
    case e10k_ps_dr:
        return("ps_dr: DR");
    case e10k_ps_d0u:
        return("ps_d0u: D0u");
    case e10k_ps_d0a:
        return("ps_d0a: D0a");
    case e10k_ps_d3:
        return("ps_d3: D3");
    default:
        return(NULL);
    }
}

static inline int e10k_power_state_prtval(char *_s, size_t _size, e10k_power_state_t _e) __attribute__ ((always_inline));
static inline int e10k_power_state_prtval(char *_s, size_t _size, e10k_power_state_t _e)
{
    char *d = e10k_power_state_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_power_state_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.fw_mode (Firmware Mode)
 *  - no width specified
 */
typedef uint8_t e10k_fw_mode_t;
#define e10k_nomode ((e10k_fw_mode_t)0x0)
#define e10k_ptmode ((e10k_fw_mode_t)0x2)
#define e10k_hien_only ((e10k_fw_mode_t)0x4)

static inline char *e10k_fw_mode_describe(e10k_fw_mode_t _e) __attribute__ ((always_inline));
static inline char *e10k_fw_mode_describe(e10k_fw_mode_t _e)
{
    switch (_e) {
    case e10k_nomode:
        return("nomode: None (manageability off)");
    case e10k_ptmode:
        return("ptmode: PT mode");
    case e10k_hien_only:
        return("hien_only: Host interface enable only");
    default:
        return(NULL);
    }
}

static inline int e10k_fw_mode_prtval(char *_s, size_t _size, e10k_fw_mode_t _e) __attribute__ ((always_inline));
static inline int e10k_fw_mode_prtval(char *_s, size_t _size, e10k_fw_mode_t _e)
{
    char *d = e10k_fw_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_fw_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.ext_err_ind (External Error Indication)
 *  - no width specified
 */
typedef uint8_t e10k_ext_err_ind_t;
#define e10k_noerr ((e10k_ext_err_ind_t)0x0)
#define e10k_inv_eechs ((e10k_ext_err_ind_t)0x1)
#define e10k_unlkd_secee ((e10k_ext_err_ind_t)0x2)
#define e10k_clk_offcmd ((e10k_ext_err_ind_t)0x3)
#define e10k_inv_flchs ((e10k_ext_err_ind_t)0x4)
#define e10k_inv_c0chs ((e10k_ext_err_ind_t)0x5)
#define e10k_inv_c1chs ((e10k_ext_err_ind_t)0x6)
#define e10k_inv_c2chs ((e10k_ext_err_ind_t)0x7)
#define e10k_inv_c3chs ((e10k_ext_err_ind_t)0x8)
#define e10k_tt_exeeded ((e10k_ext_err_ind_t)0x9)
#define e10k_dmal_failed ((e10k_ext_err_ind_t)0xa)
#define e10k_bad_hwver ((e10k_ext_err_ind_t)0xb)
#define e10k_fl_notsup ((e10k_ext_err_ind_t)0xc)
#define e10k_unspec ((e10k_ext_err_ind_t)0xd)

static inline char *e10k_ext_err_ind_describe(e10k_ext_err_ind_t _e) __attribute__ ((always_inline));
static inline char *e10k_ext_err_ind_describe(e10k_ext_err_ind_t _e)
{
    switch (_e) {
    case e10k_noerr:
        return("noerr: No error");
    case e10k_inv_eechs:
        return("inv_eechs: Invalid EEPROM checksum");
    case e10k_unlkd_secee:
        return("unlkd_secee: Unlocked secured EEPROM");
    case e10k_clk_offcmd:
        return("clk_offcmd: Clock off host command");
    case e10k_inv_flchs:
        return("inv_flchs: Invalid Flash checksum");
    case e10k_inv_c0chs:
        return("inv_c0chs: C0 checksum failed");
    case e10k_inv_c1chs:
        return("inv_c1chs: C1 checksum failed");
    case e10k_inv_c2chs:
        return("inv_c2chs: C2 checksum failed");
    case e10k_inv_c3chs:
        return("inv_c3chs: C3 checksum failed");
    case e10k_tt_exeeded:
        return("tt_exeeded: TLB table exceeded");
    case e10k_dmal_failed:
        return("dmal_failed: DMA load failed");
    case e10k_bad_hwver:
        return("bad_hwver: Bad hardware version in patch load");
    case e10k_fl_notsup:
        return("fl_notsup: Flash device not supported in the 82599");
    case e10k_unspec:
        return("unspec: Unspecified error");
    default:
        return(NULL);
    }
}

static inline int e10k_ext_err_ind_prtval(char *_s, size_t _size, e10k_ext_err_ind_t _e) __attribute__ ((always_inline));
static inline int e10k_ext_err_ind_prtval(char *_s, size_t _size, e10k_ext_err_ind_t _e)
{
    char *d = e10k_ext_err_ind_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_ext_err_ind_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.vt_mode (VT mode of operation)
 *  - no width specified
 */
typedef uint8_t e10k_vt_mode_t;
#define e10k_vt_none ((e10k_vt_mode_t)0x0)
#define e10k_vt_16 ((e10k_vt_mode_t)0x1)
#define e10k_vt_32 ((e10k_vt_mode_t)0x2)
#define e10k_vt_64 ((e10k_vt_mode_t)0x3)

static inline char *e10k_vt_mode_describe(e10k_vt_mode_t _e) __attribute__ ((always_inline));
static inline char *e10k_vt_mode_describe(e10k_vt_mode_t _e)
{
    switch (_e) {
    case e10k_vt_none:
        return("vt_none: No VT");
    case e10k_vt_16:
        return("vt_16: VT16");
    case e10k_vt_32:
        return("vt_32: VT32");
    case e10k_vt_64:
        return("vt_64: VT64");
    default:
        return(NULL);
    }
}

static inline int e10k_vt_mode_prtval(char *_s, size_t _size, e10k_vt_mode_t _e) __attribute__ ((always_inline));
static inline int e10k_vt_mode_prtval(char *_s, size_t _size, e10k_vt_mode_t _e)
{
    char *d = e10k_vt_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_vt_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.nfs_version (NFS Version selection)
 *  - no width specified
 */
typedef uint8_t e10k_nfs_version_t;
#define e10k_nfs2 ((e10k_nfs_version_t)0x0)
#define e10k_nfs3 ((e10k_nfs_version_t)0x1)
#define e10k_nfs4 ((e10k_nfs_version_t)0x2)

static inline char *e10k_nfs_version_describe(e10k_nfs_version_t _e) __attribute__ ((always_inline));
static inline char *e10k_nfs_version_describe(e10k_nfs_version_t _e)
{
    switch (_e) {
    case e10k_nfs2:
        return("nfs2: NFS version 2");
    case e10k_nfs3:
        return("nfs3: NFS version 3");
    case e10k_nfs4:
        return("nfs4: NFS version 4");
    default:
        return(NULL);
    }
}

static inline int e10k_nfs_version_prtval(char *_s, size_t _size, e10k_nfs_version_t _e) __attribute__ ((always_inline));
static inline int e10k_nfs_version_prtval(char *_s, size_t _size, e10k_nfs_version_t _e)
{
    char *d = e10k_nfs_version_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_nfs_version_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.mrq_mode (Defines the allocation of the Rx queues per RSS, Virt and DCB)
 *  - no width specified
 */
typedef uint8_t e10k_mrq_mode_t;
#define e10k_no_rss ((e10k_mrq_mode_t)0x0)
#define e10k_rss_only ((e10k_mrq_mode_t)0x1)
#define e10k_dcb8_norss ((e10k_mrq_mode_t)0x2)
#define e10k_dcb4_norss ((e10k_mrq_mode_t)0x3)
#define e10k_dcb8_rss ((e10k_mrq_mode_t)0x4)
#define e10k_dcb4_rss ((e10k_mrq_mode_t)0x5)
#define e10k_vrt_only ((e10k_mrq_mode_t)0x8)
#define e10k_vrt32_rss ((e10k_mrq_mode_t)0xa)
#define e10k_vrt64_rss ((e10k_mrq_mode_t)0xb)
#define e10k_vrt16_dcb ((e10k_mrq_mode_t)0xc)
#define e10k_vrt32_dcb ((e10k_mrq_mode_t)0xd)

static inline char *e10k_mrq_mode_describe(e10k_mrq_mode_t _e) __attribute__ ((always_inline));
static inline char *e10k_mrq_mode_describe(e10k_mrq_mode_t _e)
{
    switch (_e) {
    case e10k_no_rss:
        return("no_rss: RSS disabled");
    case e10k_rss_only:
        return("rss_only: RSS only -- Single set of RSS 16 queues");
    case e10k_dcb8_norss:
        return("dcb8_norss: DCB enabled and RSS disabled -- 8 TCs, each allocated 1 queue");
    case e10k_dcb4_norss:
        return("dcb4_norss: DCB enabled and RSS disabled -- 4 TCs, each allocated 1 queue");
    case e10k_dcb8_rss:
        return("dcb8_rss: DCB and RSS -- 8 TCs, each allocated 16 RSS queues");
    case e10k_dcb4_rss:
        return("dcb4_rss: DCB and RSS -- 4 TCs, each allocated 16 RSS queues");
    case e10k_vrt_only:
        return("vrt_only: Virtualization only -- 64 pools, no RSS, each pool allocated 2 queue");
    case e10k_vrt32_rss:
        return("vrt32_rss: Virtualization and RSS -- 32 pools, each allocated 4 RSS queues");
    case e10k_vrt64_rss:
        return("vrt64_rss: Virtualization and RSS -- 64 pools, each allocated 2 RSS queues");
    case e10k_vrt16_dcb:
        return("vrt16_dcb: Virtualization and DCB -- 16 pools, each allocated 8 TCs");
    case e10k_vrt32_dcb:
        return("vrt32_dcb: Virtualization and DCB -- 32 pools, each allocated 4 TCs");
    default:
        return(NULL);
    }
}

static inline int e10k_mrq_mode_prtval(char *_s, size_t _size, e10k_mrq_mode_t _e) __attribute__ ((always_inline));
static inline int e10k_mrq_mode_prtval(char *_s, size_t _size, e10k_mrq_mode_t _e)
{
    char *d = e10k_mrq_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_mrq_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.l4_proto (IP L4 protocol)
 *  - no width specified
 */
typedef uint8_t e10k_l4_proto_t;
#define e10k_l4tcp ((e10k_l4_proto_t)0x0)
#define e10k_l4udp ((e10k_l4_proto_t)0x1)
#define e10k_l4sctp ((e10k_l4_proto_t)0x2)
#define e10k_l4other ((e10k_l4_proto_t)0x3)

static inline char *e10k_l4_proto_describe(e10k_l4_proto_t _e) __attribute__ ((always_inline));
static inline char *e10k_l4_proto_describe(e10k_l4_proto_t _e)
{
    switch (_e) {
    case e10k_l4tcp:
        return("l4tcp: l4tcp");
    case e10k_l4udp:
        return("l4udp: l4udp");
    case e10k_l4sctp:
        return("l4sctp: l4sctp");
    case e10k_l4other:
        return("l4other: l4other");
    default:
        return(NULL);
    }
}

static inline int e10k_l4_proto_prtval(char *_s, size_t _size, e10k_l4_proto_t _e) __attribute__ ((always_inline));
static inline int e10k_l4_proto_prtval(char *_s, size_t _size, e10k_l4_proto_t _e)
{
    char *d = e10k_l4_proto_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_l4_proto_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.rx_desctype (RX Descriptor Type)
 *  - no width specified
 */
typedef uint8_t e10k_rx_desctype_t;
#define e10k_legacy ((e10k_rx_desctype_t)0x0)
#define e10k_adv_1buf ((e10k_rx_desctype_t)0x1)
#define e10k_adv_hdrsp ((e10k_rx_desctype_t)0x2)
#define e10k_adv_usehb ((e10k_rx_desctype_t)0x5)

static inline char *e10k_rx_desctype_describe(e10k_rx_desctype_t _e) __attribute__ ((always_inline));
static inline char *e10k_rx_desctype_describe(e10k_rx_desctype_t _e)
{
    switch (_e) {
    case e10k_legacy:
        return("legacy: Legacy");
    case e10k_adv_1buf:
        return("adv_1buf: Advanced descriptor one buffer");
    case e10k_adv_hdrsp:
        return("adv_hdrsp: Advanced descriptor header splitting");
    case e10k_adv_usehb:
        return("adv_usehb: Advanced descriptor header splitting always use header buffer");
    default:
        return(NULL);
    }
}

static inline int e10k_rx_desctype_prtval(char *_s, size_t _size, e10k_rx_desctype_t _e) __attribute__ ((always_inline));
static inline int e10k_rx_desctype_prtval(char *_s, size_t _size, e10k_rx_desctype_t _e)
{
    char *d = e10k_rx_desctype_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_rx_desctype_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.rsc_maxdesc (Maximum descriptors per Large receive)
 *  - no width specified
 */
typedef uint8_t e10k_rsc_maxdesc_t;
#define e10k_max_1desc ((e10k_rsc_maxdesc_t)0x0)
#define e10k_max_4desc ((e10k_rsc_maxdesc_t)0x1)
#define e10k_max_8desc ((e10k_rsc_maxdesc_t)0x2)
#define e10k_max_16desc ((e10k_rsc_maxdesc_t)0x3)

static inline char *e10k_rsc_maxdesc_describe(e10k_rsc_maxdesc_t _e) __attribute__ ((always_inline));
static inline char *e10k_rsc_maxdesc_describe(e10k_rsc_maxdesc_t _e)
{
    switch (_e) {
    case e10k_max_1desc:
        return("max_1desc: Maximum of 1 descriptor per large receive");
    case e10k_max_4desc:
        return("max_4desc: Maximum of 4 descriptors per large receive");
    case e10k_max_8desc:
        return("max_8desc: Maximum of 8 descriptors per large receive");
    case e10k_max_16desc:
        return("max_16desc: Maximum of 16 descriptors per large receive");
    default:
        return(NULL);
    }
}

static inline int e10k_rsc_maxdesc_prtval(char *_s, size_t _size, e10k_rsc_maxdesc_t _e) __attribute__ ((always_inline));
static inline int e10k_rsc_maxdesc_prtval(char *_s, size_t _size, e10k_rsc_maxdesc_t _e)
{
    char *d = e10k_rsc_maxdesc_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_rsc_maxdesc_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.dca_mode (DCA Mode)
 *  - no width specified
 */
typedef uint8_t e10k_dca_mode_t;
#define e10k_legacy_dca ((e10k_dca_mode_t)0x0)
#define e10k_dca10 ((e10k_dca_mode_t)0x1)

static inline char *e10k_dca_mode_describe(e10k_dca_mode_t _e) __attribute__ ((always_inline));
static inline char *e10k_dca_mode_describe(e10k_dca_mode_t _e)
{
    switch (_e) {
    case e10k_legacy_dca:
        return("legacy_dca: Legacy DCA is supported");
    case e10k_dca10:
        return("dca10: DCA 1.0 is supported");
    default:
        return(NULL);
    }
}

static inline int e10k_dca_mode_prtval(char *_s, size_t _size, e10k_dca_mode_t _e) __attribute__ ((always_inline));
static inline int e10k_dca_mode_prtval(char *_s, size_t _size, e10k_dca_mode_t _e)
{
    char *d = e10k_dca_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_dca_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.pballoc (Memory allocation for the flow director filters)
 *  - no width specified
 */
typedef uint8_t e10k_pballoc_t;
#define e10k_mem_none ((e10k_pballoc_t)0x0)
#define e10k_mem_64k ((e10k_pballoc_t)0x1)
#define e10k_mem_128k ((e10k_pballoc_t)0x2)
#define e10k_mem_256k ((e10k_pballoc_t)0x3)

static inline char *e10k_pballoc_describe(e10k_pballoc_t _e) __attribute__ ((always_inline));
static inline char *e10k_pballoc_describe(e10k_pballoc_t _e)
{
    switch (_e) {
    case e10k_mem_none:
        return("mem_none: mem_none");
    case e10k_mem_64k:
        return("mem_64k: mem_64k");
    case e10k_mem_128k:
        return("mem_128k: mem_128k");
    case e10k_mem_256k:
        return("mem_256k: mem_256k");
    default:
        return(NULL);
    }
}

static inline int e10k_pballoc_prtval(char *_s, size_t _size, e10k_pballoc_t _e) __attribute__ ((always_inline));
static inline int e10k_pballoc_prtval(char *_s, size_t _size, e10k_pballoc_t _e)
{
    char *d = e10k_pballoc_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_pballoc_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.fdir_cmd (Flow Director Filter Programming Command)
 *  - no width specified
 */
typedef uint8_t e10k_fdir_cmd_t;
#define e10k_no_action ((e10k_fdir_cmd_t)0x0)
#define e10k_add_flow ((e10k_fdir_cmd_t)0x1)
#define e10k_rem_flow ((e10k_fdir_cmd_t)0x2)
#define e10k_qry_cmd ((e10k_fdir_cmd_t)0x3)

static inline char *e10k_fdir_cmd_describe(e10k_fdir_cmd_t _e) __attribute__ ((always_inline));
static inline char *e10k_fdir_cmd_describe(e10k_fdir_cmd_t _e)
{
    switch (_e) {
    case e10k_no_action:
        return("no_action: No Action");
    case e10k_add_flow:
        return("add_flow: Add Flow");
    case e10k_rem_flow:
        return("rem_flow: Remove Flow");
    case e10k_qry_cmd:
        return("qry_cmd: Query Command");
    default:
        return(NULL);
    }
}

static inline int e10k_fdir_cmd_prtval(char *_s, size_t _size, e10k_fdir_cmd_t _e) __attribute__ ((always_inline));
static inline int e10k_fdir_cmd_prtval(char *_s, size_t _size, e10k_fdir_cmd_t _e)
{
    char *d = e10k_fdir_cmd_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_fdir_cmd_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.l4_ptype (L4 Packet Type)
 *  - no width specified
 */
typedef uint8_t e10k_l4_ptype_t;
#define e10k_l4p_ud ((e10k_l4_ptype_t)0x1)
#define e10k_l4p_tcp ((e10k_l4_ptype_t)0x2)
#define e10k_l4p_sctp ((e10k_l4_ptype_t)0x3)

static inline char *e10k_l4_ptype_describe(e10k_l4_ptype_t _e) __attribute__ ((always_inline));
static inline char *e10k_l4_ptype_describe(e10k_l4_ptype_t _e)
{
    switch (_e) {
    case e10k_l4p_ud:
        return("l4p_ud: UDP");
    case e10k_l4p_tcp:
        return("l4p_tcp: TCP");
    case e10k_l4p_sctp:
        return("l4p_sctp: SCTP");
    default:
        return(NULL);
    }
}

static inline int e10k_l4_ptype_prtval(char *_s, size_t _size, e10k_l4_ptype_t _e) __attribute__ ((always_inline));
static inline int e10k_l4_ptype_prtval(char *_s, size_t _size, e10k_l4_ptype_t _e)
{
    char *d = e10k_l4_ptype_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_l4_ptype_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.pause_cap (PAUSE Capabilities)
 *  - no width specified
 */
typedef uint8_t e10k_pause_cap_t;
#define e10k_no_pause ((e10k_pause_cap_t)0x0)
#define e10k_sym_pause ((e10k_pause_cap_t)0x1)
#define e10k_asym_pause ((e10k_pause_cap_t)0x2)
#define e10k_both_pause ((e10k_pause_cap_t)0x3)

static inline char *e10k_pause_cap_describe(e10k_pause_cap_t _e) __attribute__ ((always_inline));
static inline char *e10k_pause_cap_describe(e10k_pause_cap_t _e)
{
    switch (_e) {
    case e10k_no_pause:
        return("no_pause: No PAUSE");
    case e10k_sym_pause:
        return("sym_pause: Symmetric PAUSE");
    case e10k_asym_pause:
        return("asym_pause: Asymmetric PAUSE toward link partner");
    case e10k_both_pause:
        return("both_pause: Both symmetric and asymmetric PAUSE toward local device");
    default:
        return(NULL);
    }
}

static inline int e10k_pause_cap_prtval(char *_s, size_t _size, e10k_pause_cap_t _e) __attribute__ ((always_inline));
static inline int e10k_pause_cap_prtval(char *_s, size_t _size, e10k_pause_cap_t _e)
{
    char *d = e10k_pause_cap_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_pause_cap_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.remote_fault (Remote Fault Condition)
 *  - no width specified
 */
typedef uint8_t e10k_remote_fault_t;
#define e10k_no_error ((e10k_remote_fault_t)0x0)
#define e10k_lnk_fail ((e10k_remote_fault_t)0x1)
#define e10k_offline ((e10k_remote_fault_t)0x2)
#define e10k_an_err ((e10k_remote_fault_t)0x3)

static inline char *e10k_remote_fault_describe(e10k_remote_fault_t _e) __attribute__ ((always_inline));
static inline char *e10k_remote_fault_describe(e10k_remote_fault_t _e)
{
    switch (_e) {
    case e10k_no_error:
        return("no_error: No error, link good");
    case e10k_lnk_fail:
        return("lnk_fail: Link failure");
    case e10k_offline:
        return("offline: Offline");
    case e10k_an_err:
        return("an_err: Auto-negotiation error");
    default:
        return(NULL);
    }
}

static inline int e10k_remote_fault_prtval(char *_s, size_t _size, e10k_remote_fault_t _e) __attribute__ ((always_inline));
static inline int e10k_remote_fault_prtval(char *_s, size_t _size, e10k_remote_fault_t _e)
{
    char *d = e10k_remote_fault_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_remote_fault_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.pace (Pace)
 *  - no width specified
 */
typedef uint8_t e10k_pace_t;
#define e10k_p_10gbe ((e10k_pace_t)0x0)
#define e10k_p_1gbe ((e10k_pace_t)0x1)
#define e10k_p_2gbe ((e10k_pace_t)0x2)
#define e10k_p_3gbe ((e10k_pace_t)0x3)
#define e10k_p_4gbe ((e10k_pace_t)0x4)
#define e10k_p_5gbe ((e10k_pace_t)0x5)
#define e10k_p_6gbe ((e10k_pace_t)0x6)
#define e10k_p_7gbe ((e10k_pace_t)0x7)
#define e10k_p_8gbe ((e10k_pace_t)0x8)
#define e10k_p_9gbe ((e10k_pace_t)0x9)
#define e10k_p_9gbe_wan ((e10k_pace_t)0xf)

static inline char *e10k_pace_describe(e10k_pace_t _e) __attribute__ ((always_inline));
static inline char *e10k_pace_describe(e10k_pace_t _e)
{
    switch (_e) {
    case e10k_p_10gbe:
        return("p_10gbe: 10 GbE (LAN)");
    case e10k_p_1gbe:
        return("p_1gbe: 1 GbE");
    case e10k_p_2gbe:
        return("p_2gbe: 2 GbE");
    case e10k_p_3gbe:
        return("p_3gbe: 3 GbE");
    case e10k_p_4gbe:
        return("p_4gbe: 4 GbE");
    case e10k_p_5gbe:
        return("p_5gbe: 5 GbE");
    case e10k_p_6gbe:
        return("p_6gbe: 6 GbE");
    case e10k_p_7gbe:
        return("p_7gbe: 7 GbE");
    case e10k_p_8gbe:
        return("p_8gbe: 8 GbE");
    case e10k_p_9gbe:
        return("p_9gbe: 9 GbE");
    case e10k_p_9gbe_wan:
        return("p_9gbe_wan: 9.294196 GbE (WAN)");
    default:
        return(NULL);
    }
}

static inline int e10k_pace_prtval(char *_s, size_t _size, e10k_pace_t _e) __attribute__ ((always_inline));
static inline int e10k_pace_prtval(char *_s, size_t _size, e10k_pace_t _e)
{
    char *d = e10k_pace_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_pace_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.mdi_opcode (OP Code)
 *  - no width specified
 */
typedef uint8_t e10k_mdi_opcode_t;
#define e10k_addr_cycle ((e10k_mdi_opcode_t)0x0)
#define e10k_write_op ((e10k_mdi_opcode_t)0x1)
#define e10k_read_incad ((e10k_mdi_opcode_t)0x2)
#define e10k_read_op ((e10k_mdi_opcode_t)0x3)

static inline char *e10k_mdi_opcode_describe(e10k_mdi_opcode_t _e) __attribute__ ((always_inline));
static inline char *e10k_mdi_opcode_describe(e10k_mdi_opcode_t _e)
{
    switch (_e) {
    case e10k_addr_cycle:
        return("addr_cycle: Address cycle (new protocol only)");
    case e10k_write_op:
        return("write_op: Write operation");
    case e10k_read_incad:
        return("read_incad: Read increment address(new) /Read operation (old)");
    case e10k_read_op:
        return("read_op: Read operation (new protocol only)");
    default:
        return(NULL);
    }
}

static inline int e10k_mdi_opcode_prtval(char *_s, size_t _size, e10k_mdi_opcode_t _e) __attribute__ ((always_inline));
static inline int e10k_mdi_opcode_prtval(char *_s, size_t _size, e10k_mdi_opcode_t _e)
{
    char *d = e10k_mdi_opcode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_mdi_opcode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.mdi_stcode (ST Code)
 *  - no width specified
 */
typedef uint8_t e10k_mdi_stcode_t;
#define e10k_new_proto ((e10k_mdi_stcode_t)0x0)
#define e10k_old_proto ((e10k_mdi_stcode_t)0x1)

static inline char *e10k_mdi_stcode_describe(e10k_mdi_stcode_t _e) __attribute__ ((always_inline));
static inline char *e10k_mdi_stcode_describe(e10k_mdi_stcode_t _e)
{
    switch (_e) {
    case e10k_new_proto:
        return("new_proto: New protocol");
    case e10k_old_proto:
        return("old_proto: Old protocol");
    default:
        return(NULL);
    }
}

static inline int e10k_mdi_stcode_prtval(char *_s, size_t _size, e10k_mdi_stcode_t _e) __attribute__ ((always_inline));
static inline int e10k_mdi_stcode_prtval(char *_s, size_t _size, e10k_mdi_stcode_t _e)
{
    char *d = e10k_mdi_stcode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_mdi_stcode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.dev_present (Device present)
 *  - no width specified
 */
typedef uint8_t e10k_dev_present_t;
#define e10k_dev_present ((e10k_dev_present_t)0x2)

static inline char *e10k_dev_present_describe(e10k_dev_present_t _e) __attribute__ ((always_inline));
static inline char *e10k_dev_present_describe(e10k_dev_present_t _e)
{
    switch (_e) {
    case e10k_dev_present:
        return("dev_present: Device responding at this address");
    default:
        return(NULL);
    }
}

static inline int e10k_dev_present_prtval(char *_s, size_t _size, e10k_dev_present_t _e) __attribute__ ((always_inline));
static inline int e10k_dev_present_prtval(char *_s, size_t _size, e10k_dev_present_t _e)
{
    char *d = e10k_dev_present_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_dev_present_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.pmad_10gbe (10 GbE PMA/PMD)
 *  - no width specified
 */
typedef uint8_t e10k_pmad_10gbe_t;
#define e10k_pmad_xaui ((e10k_pmad_10gbe_t)0x0)
#define e10k_pmad_kx4 ((e10k_pmad_10gbe_t)0x1)
#define e10k_pmad_cx4 ((e10k_pmad_10gbe_t)0x2)

static inline char *e10k_pmad_10gbe_describe(e10k_pmad_10gbe_t _e) __attribute__ ((always_inline));
static inline char *e10k_pmad_10gbe_describe(e10k_pmad_10gbe_t _e)
{
    switch (_e) {
    case e10k_pmad_xaui:
        return("pmad_xaui: XAUI PMA/PMD");
    case e10k_pmad_kx4:
        return("pmad_kx4: KX4 PMA/PMD");
    case e10k_pmad_cx4:
        return("pmad_cx4: CX4 PMA/PMD");
    default:
        return(NULL);
    }
}

static inline int e10k_pmad_10gbe_prtval(char *_s, size_t _size, e10k_pmad_10gbe_t _e) __attribute__ ((always_inline));
static inline int e10k_pmad_10gbe_prtval(char *_s, size_t _size, e10k_pmad_10gbe_t _e)
{
    char *d = e10k_pmad_10gbe_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_pmad_10gbe_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.pmad_1gbe (PMA/PMD used for 1 Gb)
 *  - no width specified
 */
typedef uint8_t e10k_pmad_1gbe_t;
#define e10k_pmad_sfi ((e10k_pmad_1gbe_t)0x0)
#define e10k_pmad_kxbx ((e10k_pmad_1gbe_t)0x1)

static inline char *e10k_pmad_1gbe_describe(e10k_pmad_1gbe_t _e) __attribute__ ((always_inline));
static inline char *e10k_pmad_1gbe_describe(e10k_pmad_1gbe_t _e)
{
    switch (_e) {
    case e10k_pmad_sfi:
        return("pmad_sfi: SFI PMA/PMD");
    case e10k_pmad_kxbx:
        return("pmad_kxbx: KX or BX PMA/PMD");
    default:
        return(NULL);
    }
}

static inline int e10k_pmad_1gbe_prtval(char *_s, size_t _size, e10k_pmad_1gbe_t _e) __attribute__ ((always_inline));
static inline int e10k_pmad_1gbe_prtval(char *_s, size_t _size, e10k_pmad_1gbe_t _e)
{
    char *d = e10k_pmad_1gbe_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_pmad_1gbe_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.link_mode (Link Mode Select)
 *  - no width specified
 */
typedef uint8_t e10k_link_mode_t;
#define e10k_l1g ((e10k_link_mode_t)0x0)
#define e10k_l10g_kx4 ((e10k_link_mode_t)0x1)
#define e10k_l1g_bx ((e10k_link_mode_t)0x2)
#define e10k_l10g_sfi ((e10k_link_mode_t)0x3)
#define e10k_l1g_kxr ((e10k_link_mode_t)0x4)
#define e10k_l100m_sgmii ((e10k_link_mode_t)0x5)
#define e10k_l1g_kxr_an ((e10k_link_mode_t)0x6)
#define e10k_l1g_sgmii ((e10k_link_mode_t)0x7)

static inline char *e10k_link_mode_describe(e10k_link_mode_t _e) __attribute__ ((always_inline));
static inline char *e10k_link_mode_describe(e10k_link_mode_t _e)
{
    switch (_e) {
    case e10k_l1g:
        return("l1g: 1 GbE link (no bp aneg)");
    case e10k_l10g_kx4:
        return("l10g_kx4: 10 GbE parallel link (KX4 no bp aneg)");
    case e10k_l1g_bx:
        return("l1g_bx: 1 GbE link with clause 37 aneg enable");
    case e10k_l10g_sfi:
        return("l10g_sfi: 10 GbE serial link (SFI no bp aneg)");
    case e10k_l1g_kxr:
        return("l1g_kxr: KX/KX4/KR bp aneg; 1 GbE (Clause 37) aneg disabled");
    case e10k_l100m_sgmii:
        return("l100m_sgmii: SGMII 100M/1 GbE link");
    case e10k_l1g_kxr_an:
        return("l1g_kxr_an: KX/KX4/KR bp aneg; 1 GbE (Clause 37) aneg enabled");
    case e10k_l1g_sgmii:
        return("l1g_sgmii: KX/KX4/KR aneg enable. SGMII 100 Mb/s and 1GbE enable");
    default:
        return(NULL);
    }
}

static inline int e10k_link_mode_prtval(char *_s, size_t _size, e10k_link_mode_t _e) __attribute__ ((always_inline));
static inline int e10k_link_mode_prtval(char *_s, size_t _size, e10k_link_mode_t _e)
{
    char *d = e10k_link_mode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_link_mode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.aneg_pdt (Auto-Negotiation Parallel Detect Timer)
 *  - no width specified
 */
typedef uint8_t e10k_aneg_pdt_t;
#define e10k_t1ms ((e10k_aneg_pdt_t)0x0)
#define e10k_t2ms ((e10k_aneg_pdt_t)0x1)
#define e10k_t5ms ((e10k_aneg_pdt_t)0x2)
#define e10k_t8ms ((e10k_aneg_pdt_t)0x3)

static inline char *e10k_aneg_pdt_describe(e10k_aneg_pdt_t _e) __attribute__ ((always_inline));
static inline char *e10k_aneg_pdt_describe(e10k_aneg_pdt_t _e)
{
    switch (_e) {
    case e10k_t1ms:
        return("t1ms: 1 ms");
    case e10k_t2ms:
        return("t2ms: 2 ms");
    case e10k_t5ms:
        return("t5ms: 5 ms");
    case e10k_t8ms:
        return("t8ms: 8 ms");
    default:
        return(NULL);
    }
}

static inline int e10k_aneg_pdt_prtval(char *_s, size_t _size, e10k_aneg_pdt_t _e) __attribute__ ((always_inline));
static inline int e10k_aneg_pdt_prtval(char *_s, size_t _size, e10k_aneg_pdt_t _e)
{
    char *d = e10k_aneg_pdt_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_aneg_pdt_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.mac_lnkmode (MAC link mode status)
 *  - no width specified
 */
typedef uint8_t e10k_mac_lnkmode_t;
#define e10k_lms_1g ((e10k_mac_lnkmode_t)0x0)
#define e10k_lms_10g_par ((e10k_mac_lnkmode_t)0x1)
#define e10k_lms_10g_ser ((e10k_mac_lnkmode_t)0x2)
#define e10k_lms_aneg ((e10k_mac_lnkmode_t)0x3)

static inline char *e10k_mac_lnkmode_describe(e10k_mac_lnkmode_t _e) __attribute__ ((always_inline));
static inline char *e10k_mac_lnkmode_describe(e10k_mac_lnkmode_t _e)
{
    switch (_e) {
    case e10k_lms_1g:
        return("lms_1g: 1 GbE");
    case e10k_lms_10g_par:
        return("lms_10g_par: 10 GbE parallel");
    case e10k_lms_10g_ser:
        return("lms_10g_ser: 10 GbE serial");
    case e10k_lms_aneg:
        return("lms_aneg: auto-negotiation");
    default:
        return(NULL);
    }
}

static inline int e10k_mac_lnkmode_prtval(char *_s, size_t _size, e10k_mac_lnkmode_t _e) __attribute__ ((always_inline));
static inline int e10k_mac_lnkmode_prtval(char *_s, size_t _size, e10k_mac_lnkmode_t _e)
{
    char *d = e10k_mac_lnkmode_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_mac_lnkmode_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.link_speed (MAC link speed status)
 *  - no width specified
 */
typedef uint8_t e10k_link_speed_t;
#define e10k_ls_100m ((e10k_link_speed_t)0x1)
#define e10k_ls_1g ((e10k_link_speed_t)0x2)
#define e10k_ls_10g ((e10k_link_speed_t)0x3)

static inline char *e10k_link_speed_describe(e10k_link_speed_t _e) __attribute__ ((always_inline));
static inline char *e10k_link_speed_describe(e10k_link_speed_t _e)
{
    switch (_e) {
    case e10k_ls_100m:
        return("ls_100m: 100 Mb/s");
    case e10k_ls_1g:
        return("ls_1g: 1 GbE");
    case e10k_ls_10g:
        return("ls_10g: 10 GbE");
    default:
        return(NULL);
    }
}

static inline int e10k_link_speed_prtval(char *_s, size_t _size, e10k_link_speed_t _e) __attribute__ ((always_inline));
static inline int e10k_link_speed_prtval(char *_s, size_t _size, e10k_link_speed_t _e)
{
    char *d = e10k_link_speed_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_link_speed_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.mac_rxtxlm (MAC link mode in the Core Rx/Tx path)
 *  - no width specified
 */
typedef uint8_t e10k_mac_rxtxlm_t;
#define e10k_rxlm_1g ((e10k_mac_rxtxlm_t)0x0)
#define e10k_rxlm_10g_p ((e10k_mac_rxtxlm_t)0x1)
#define e10k_rxlm_10g_s ((e10k_mac_rxtxlm_t)0x2)
#define e10k_rxlm_aneg ((e10k_mac_rxtxlm_t)0x3)

static inline char *e10k_mac_rxtxlm_describe(e10k_mac_rxtxlm_t _e) __attribute__ ((always_inline));
static inline char *e10k_mac_rxtxlm_describe(e10k_mac_rxtxlm_t _e)
{
    switch (_e) {
    case e10k_rxlm_1g:
        return("rxlm_1g: 1 GbE");
    case e10k_rxlm_10g_p:
        return("rxlm_10g_p: 10 GbE parallel");
    case e10k_rxlm_10g_s:
        return("rxlm_10g_s: 10GbE serial");
    case e10k_rxlm_aneg:
        return("rxlm_aneg: auto-negotiation");
    default:
        return(NULL);
    }
}

static inline int e10k_mac_rxtxlm_prtval(char *_s, size_t _size, e10k_mac_rxtxlm_t _e) __attribute__ ((always_inline));
static inline int e10k_mac_rxtxlm_prtval(char *_s, size_t _size, e10k_mac_rxtxlm_t _e)
{
    char *d = e10k_mac_rxtxlm_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_mac_rxtxlm_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.pmapd_10gbes (PMAPMD used for 10 GbE serial link operation)
 *  - no width specified
 */
typedef uint8_t e10k_pmapd_10gbes_t;
#define e10k_pmapd_kr ((e10k_pmapd_10gbes_t)0x0)
#define e10k_pmapd_sfi ((e10k_pmapd_10gbes_t)0x2)

static inline char *e10k_pmapd_10gbes_describe(e10k_pmapd_10gbes_t _e) __attribute__ ((always_inline));
static inline char *e10k_pmapd_10gbes_describe(e10k_pmapd_10gbes_t _e)
{
    switch (_e) {
    case e10k_pmapd_kr:
        return("pmapd_kr: KR");
    case e10k_pmapd_sfi:
        return("pmapd_sfi: SFI");
    default:
        return(NULL);
    }
}

static inline int e10k_pmapd_10gbes_prtval(char *_s, size_t _size, e10k_pmapd_10gbes_t _e) __attribute__ ((always_inline));
static inline int e10k_pmapd_10gbes_prtval(char *_s, size_t _size, e10k_pmapd_10gbes_t _e)
{
    char *d = e10k_pmapd_10gbes_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_pmapd_10gbes_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.fec_ncnt (Good Parity Block Count)
 *  - no width specified
 */
typedef uint8_t e10k_fec_ncnt_t;
#define e10k_gbl_4 ((e10k_fec_ncnt_t)0x0)
#define e10k_gbl_2 ((e10k_fec_ncnt_t)0x1)
#define e10k_gbl_5 ((e10k_fec_ncnt_t)0x2)
#define e10k_gbl_7 ((e10k_fec_ncnt_t)0x3)

static inline char *e10k_fec_ncnt_describe(e10k_fec_ncnt_t _e) __attribute__ ((always_inline));
static inline char *e10k_fec_ncnt_describe(e10k_fec_ncnt_t _e)
{
    switch (_e) {
    case e10k_gbl_4:
        return("gbl_4: 4 good blocks");
    case e10k_gbl_2:
        return("gbl_2: 2 good blocks");
    case e10k_gbl_5:
        return("gbl_5: 5 good blocks");
    case e10k_gbl_7:
        return("gbl_7: 7 good blocks");
    default:
        return(NULL);
    }
}

static inline int e10k_fec_ncnt_prtval(char *_s, size_t _size, e10k_fec_ncnt_t _e) __attribute__ ((always_inline));
static inline int e10k_fec_ncnt_prtval(char *_s, size_t _size, e10k_fec_ncnt_t _e)
{
    char *d = e10k_fec_ncnt_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_fec_ncnt_t", (uint64_t )(_e)));
    }
}

/*
 * Constants defn: e10k.fec_mcnt (Bad Parity Block Count)
 *  - no width specified
 */
typedef uint8_t e10k_fec_mcnt_t;
#define e10k_err_8 ((e10k_fec_mcnt_t)0x0)
#define e10k_err_4 ((e10k_fec_mcnt_t)0x1)
#define e10k_err_12 ((e10k_fec_mcnt_t)0x2)
#define e10k_err_15 ((e10k_fec_mcnt_t)0x3)

static inline char *e10k_fec_mcnt_describe(e10k_fec_mcnt_t _e) __attribute__ ((always_inline));
static inline char *e10k_fec_mcnt_describe(e10k_fec_mcnt_t _e)
{
    switch (_e) {
    case e10k_err_8:
        return("err_8: 8 errors");
    case e10k_err_4:
        return("err_4: 4 errors");
    case e10k_err_12:
        return("err_12: 12 errors");
    case e10k_err_15:
        return("err_15: 15 errors");
    default:
        return(NULL);
    }
}

static inline int e10k_fec_mcnt_prtval(char *_s, size_t _size, e10k_fec_mcnt_t _e) __attribute__ ((always_inline));
static inline int e10k_fec_mcnt_prtval(char *_s, size_t _size, e10k_fec_mcnt_t _e)
{
    char *d = e10k_fec_mcnt_describe(_e);
    if (d) {
        return(snprintf(_s, _size, "%s", d));
    } else {
        return(snprintf(_s, _size, "Unknown constant %s value 0x%" PRIx64, "e10k_fec_mcnt_t", (uint64_t )(_e)));
    }
}

/*
 * Register type: e10k_ctrl_t
 * Description: Implicit type of Device control register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   pcie_md	(size 1, offset 2, init 0):	RW	PCIe Master Disable
 *   lrst	(size 1, offset 3, init 0):	RW	Link reset
 *   _anon4	(size 22, offset 4, init 0):	RSVD	_
 *   rst	(size 1, offset 26, init 0):	RW	Device reset
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t e10k_ctrl_t;
#define e10k_ctrl_default 0x0
static inline uint8_t e10k_ctrl_pcie_md_extract(e10k_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_pcie_md_extract(e10k_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_ctrl_t e10k_ctrl_pcie_md_insert(e10k_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ctrl_t e10k_ctrl_pcie_md_insert(e10k_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_ctrl_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_ctrl_lrst_extract(e10k_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_lrst_extract(e10k_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_ctrl_t e10k_ctrl_lrst_insert(e10k_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ctrl_t e10k_ctrl_lrst_insert(e10k_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_ctrl_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_ctrl_rst_extract(e10k_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_rst_extract(e10k_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_ctrl_t e10k_ctrl_rst_insert(e10k_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ctrl_t e10k_ctrl_rst_insert(e10k_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_ctrl_t )(_fieldval)) << 26)));
}

static inline int e10k_ctrl_prtval(char *_s, size_t _size, e10k_ctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_ctrl_prtval(char *_s, size_t _size, e10k_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_md =\t%" PRIx8 "\t(PCIe Master Disable)\n", e10k_ctrl_pcie_md_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lrst =\t%" PRIx8 "\t(Link reset)\n", e10k_ctrl_lrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Device reset)\n", e10k_ctrl_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_status_t
 * Description: Implicit type of Device status register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	RSVD	_
 *   lan_id	(size 2, offset 2, init 0):	RO	LAN ID
 *   _anon4	(size 3, offset 4, init 0):	RSVD	_
 *   link_up	(size 1, offset 7, init 0):	RO	Linkup Status Indication
 *   _anon8	(size 2, offset 8, init 0):	RSVD	_
 *   num_vfs	(size 8, offset 10, init 0):	RO	Num VFs
 *   iov_active	(size 1, offset 18, init 0):	RO	IOV Active
 *   pcie_mes	(size 1, offset 19, init 0):	RO	PCIe Master Enable Status
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t e10k_status_t;
#define e10k_status_default 0x0
static inline e10k_lanid_t e10k_status_lan_id_extract(e10k_status_t _regval) __attribute__ ((always_inline));
static inline e10k_lanid_t e10k_status_lan_id_extract(e10k_status_t _regval)
{
    return((e10k_lanid_t )((_regval & 0xc) >> 2));
}

static inline e10k_status_t e10k_status_lan_id_insert(e10k_status_t _regval, e10k_lanid_t _fieldval) __attribute__ ((always_inline));
static inline e10k_status_t e10k_status_lan_id_insert(e10k_status_t _regval, e10k_lanid_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((e10k_status_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_status_link_up_extract(e10k_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_status_link_up_extract(e10k_status_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_status_t e10k_status_link_up_insert(e10k_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_status_t e10k_status_link_up_insert(e10k_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_status_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_status_num_vfs_extract(e10k_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_status_num_vfs_extract(e10k_status_t _regval)
{
    return((uint8_t )((_regval & 0x3fc00) >> 10));
}

static inline e10k_status_t e10k_status_num_vfs_insert(e10k_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_status_t e10k_status_num_vfs_insert(e10k_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffc03ff) | (0x3fc00 & (((e10k_status_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_status_iov_active_extract(e10k_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_status_iov_active_extract(e10k_status_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_status_t e10k_status_iov_active_insert(e10k_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_status_t e10k_status_iov_active_insert(e10k_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_status_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_status_pcie_mes_extract(e10k_status_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_status_pcie_mes_extract(e10k_status_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_status_t e10k_status_pcie_mes_insert(e10k_status_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_status_t e10k_status_pcie_mes_insert(e10k_status_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_status_t )(_fieldval)) << 19)));
}

static inline int e10k_status_prtval(char *_s, size_t _size, e10k_status_t _regval) __attribute__ ((always_inline));
static inline int e10k_status_prtval(char *_s, size_t _size, e10k_status_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan_id =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_lanid_prtval(_s + _r, _avail, e10k_status_lan_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LAN ID)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " link_up =\t%" PRIx8 "\t(Linkup Status Indication)\n", e10k_status_link_up_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " num_vfs =\t%" PRIx8 "\t(Num VFs)\n", e10k_status_num_vfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iov_active =\t%" PRIx8 "\t(IOV Active)\n", e10k_status_iov_active_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_mes =\t%" PRIx8 "\t(PCIe Master Enable Status)\n", e10k_status_pcie_mes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_ctrl_ext_t
 * Description: Implicit type of Extended Device Control Register register
 * Fields:
 *   _anon0	(size 14, offset 0, init 0):	RSVD	_
 *   pfrstd	(size 1, offset 14, init 0):	RW	PF Reset Done
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   ns_dis	(size 1, offset 16, init 0):	RW	NO Snoop Disable
 *   ro_dis	(size 1, offset 17, init 0):	RW	Relaxed Ordering Disable
 *   _anon18	(size 8, offset 18, init 0):	RSVD	_
 *   ext_vlan	(size 1, offset 26, init 0):	RW	Extended VLAN
 *   _anon27	(size 1, offset 27, init 0):	RSVD	_
 *   drv_load	(size 1, offset 28, init 0):	RW	Driver loaded 
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
typedef uint32_t e10k_ctrl_ext_t;
#define e10k_ctrl_ext_default 0x0
static inline uint8_t e10k_ctrl_ext_pfrstd_extract(e10k_ctrl_ext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_pfrstd_extract(e10k_ctrl_ext_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_ctrl_ext_t e10k_ctrl_ext_pfrstd_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ctrl_ext_t e10k_ctrl_ext_pfrstd_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_ctrl_ext_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_ctrl_ext_ns_dis_extract(e10k_ctrl_ext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_ns_dis_extract(e10k_ctrl_ext_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_ctrl_ext_t e10k_ctrl_ext_ns_dis_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ctrl_ext_t e10k_ctrl_ext_ns_dis_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_ctrl_ext_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_ctrl_ext_ro_dis_extract(e10k_ctrl_ext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_ro_dis_extract(e10k_ctrl_ext_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_ctrl_ext_t e10k_ctrl_ext_ro_dis_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ctrl_ext_t e10k_ctrl_ext_ro_dis_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_ctrl_ext_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_ctrl_ext_ext_vlan_extract(e10k_ctrl_ext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_ext_vlan_extract(e10k_ctrl_ext_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_ctrl_ext_t e10k_ctrl_ext_ext_vlan_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ctrl_ext_t e10k_ctrl_ext_ext_vlan_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_ctrl_ext_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_ctrl_ext_drv_load_extract(e10k_ctrl_ext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_drv_load_extract(e10k_ctrl_ext_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_ctrl_ext_t e10k_ctrl_ext_drv_load_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ctrl_ext_t e10k_ctrl_ext_drv_load_insert(e10k_ctrl_ext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_ctrl_ext_t )(_fieldval)) << 28)));
}

static inline int e10k_ctrl_ext_prtval(char *_s, size_t _size, e10k_ctrl_ext_t _regval) __attribute__ ((always_inline));
static inline int e10k_ctrl_ext_prtval(char *_s, size_t _size, e10k_ctrl_ext_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pfrstd =\t%" PRIx8 "\t(PF Reset Done)\n", e10k_ctrl_ext_pfrstd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ns_dis =\t%" PRIx8 "\t(NO Snoop Disable)\n", e10k_ctrl_ext_ns_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ro_dis =\t%" PRIx8 "\t(Relaxed Ordering Disable)\n", e10k_ctrl_ext_ro_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ext_vlan =\t%" PRIx8 "\t(Extended VLAN)\n", e10k_ctrl_ext_ext_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drv_load =\t%" PRIx8 "\t(Driver loaded )\n", e10k_ctrl_ext_drv_load_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_esdp_t
 * Description: Implicit type of Extended SDP Control register
 * Fields:
 *   sdp0_data	(size 1, offset 0, init 0):	RW	SDP0 Data Value
 *   sdp1_data	(size 1, offset 1, init 0):	RW	SDP1 Data Value
 *   sdp2_data	(size 1, offset 2, init 0):	RW	SDP2 Data Value
 *   sdp3_data	(size 1, offset 3, init 0):	RW	SDP3 Data Value
 *   sdp4_data	(size 1, offset 4, init 0):	RW	SDP4 Data Value
 *   sdp5_data	(size 1, offset 5, init 0):	RW	SDP5 Data Value
 *   sdp6_data	(size 1, offset 6, init 0):	RW	SDP6 Data Value
 *   sdp7_data	(size 1, offset 7, init 0):	RW	SDP7 Data Value
 *   sdp0_iodir	(size 1, offset 8, init 0):	RW	SDP0 Pin Directionality
 *   sdp1_iodir	(size 1, offset 9, init 0):	RW	SDP1 Pin Directionality
 *   sdp2_iodir	(size 1, offset 10, init 0):	RW	SDP2 Pin Directionality
 *   sdp3_iodir	(size 1, offset 11, init 0):	RW	SDP3 Pin Directionality
 *   sdp4_iodir	(size 1, offset 12, init 0):	RW	SDP4 Pin Directionality
 *   sdp5_iodir	(size 1, offset 13, init 0):	RW	SDP5 Pin Directionality
 *   sdp6_iodir	(size 1, offset 14, init 0):	RW	SDP6 Pin Directionality
 *   sdp7_iodir	(size 1, offset 15, init 0):	RW	SDP7 Pin Directionality
 *   sdp0_native	(size 1, offset 16, init 0):	RW	SDP0 Operating Mode
 *   sdp1_native	(size 1, offset 17, init 0):	RW	SDP1 Operating Mode
 *   sdp2_native	(size 1, offset 18, init 0):	RW	SDP2 Operating Mode
 *   sdp3_native	(size 1, offset 19, init 0):	RW	SDP3 Operating Mode
 *   sdp4_native	(size 1, offset 20, init 0):	RW	SDP4 Operating Mode
 *   sdp5_native	(size 1, offset 21, init 0):	RW	SDP5 Operating Mode
 *   sdp6_native	(size 1, offset 22, init 0):	RW	SDP6 Operating Mode
 *   sdp7_native	(size 1, offset 23, init 0):	RW	SDP7 Operating Mode
 *   _anon24	(size 2, offset 24, init 0):	RSVD	_
 *   sdp2_ts_tt1	(size 1, offset 26, init 0):	RW	SDP2 Native Mode Functionality
 *   sdp3_ts_tt0	(size 1, offset 27, init 0):	RW	SDP3 Native Mode Functionality
 *   sdp4_func	(size 1, offset 28, init 0):	RW	SDP4 Native Mode Functionality
 *   sdp5_func	(size 1, offset 29, init 0):	RW	SDP5 Native Mode Functionality
 *   sdp6_ts_tt1	(size 1, offset 30, init 0):	RW	SDP6 Native Mode Functionality
 *   sdp7_ts_tt0	(size 1, offset 31, init 0):	RW	SDP7 Native Mode Functionality
 */
typedef uint32_t e10k_esdp_t;
#define e10k_esdp_default 0x0
static inline uint8_t e10k_esdp_sdp0_data_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp0_data_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_esdp_t e10k_esdp_sdp0_data_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp0_data_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_esdp_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_esdp_sdp1_data_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp1_data_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_esdp_t e10k_esdp_sdp1_data_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp1_data_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_esdp_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_esdp_sdp2_data_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp2_data_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_esdp_t e10k_esdp_sdp2_data_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp2_data_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_esdp_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_esdp_sdp3_data_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp3_data_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_esdp_t e10k_esdp_sdp3_data_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp3_data_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_esdp_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_esdp_sdp4_data_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp4_data_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_esdp_t e10k_esdp_sdp4_data_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp4_data_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_esdp_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_esdp_sdp5_data_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp5_data_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_esdp_t e10k_esdp_sdp5_data_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp5_data_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_esdp_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_esdp_sdp6_data_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp6_data_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_esdp_t e10k_esdp_sdp6_data_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp6_data_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_esdp_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_esdp_sdp7_data_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp7_data_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_esdp_t e10k_esdp_sdp7_data_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp7_data_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_esdp_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_esdp_sdp0_iodir_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp0_iodir_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_esdp_t e10k_esdp_sdp0_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp0_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_esdp_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_esdp_sdp1_iodir_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp1_iodir_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_esdp_t e10k_esdp_sdp1_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp1_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_esdp_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_esdp_sdp2_iodir_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp2_iodir_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_esdp_t e10k_esdp_sdp2_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp2_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_esdp_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_esdp_sdp3_iodir_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp3_iodir_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_esdp_t e10k_esdp_sdp3_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp3_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_esdp_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_esdp_sdp4_iodir_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp4_iodir_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_esdp_t e10k_esdp_sdp4_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp4_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_esdp_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_esdp_sdp5_iodir_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp5_iodir_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_esdp_t e10k_esdp_sdp5_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp5_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_esdp_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_esdp_sdp6_iodir_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp6_iodir_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_esdp_t e10k_esdp_sdp6_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp6_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_esdp_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_esdp_sdp7_iodir_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp7_iodir_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_esdp_t e10k_esdp_sdp7_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp7_iodir_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_esdp_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_esdp_sdp0_native_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp0_native_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_esdp_t e10k_esdp_sdp0_native_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp0_native_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_esdp_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_esdp_sdp1_native_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp1_native_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_esdp_t e10k_esdp_sdp1_native_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp1_native_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_esdp_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_esdp_sdp2_native_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp2_native_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_esdp_t e10k_esdp_sdp2_native_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp2_native_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_esdp_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_esdp_sdp3_native_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp3_native_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_esdp_t e10k_esdp_sdp3_native_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp3_native_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_esdp_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_esdp_sdp4_native_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp4_native_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_esdp_t e10k_esdp_sdp4_native_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp4_native_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_esdp_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_esdp_sdp5_native_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp5_native_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_esdp_t e10k_esdp_sdp5_native_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp5_native_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_esdp_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_esdp_sdp6_native_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp6_native_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_esdp_t e10k_esdp_sdp6_native_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp6_native_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_esdp_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_esdp_sdp7_native_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp7_native_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_esdp_t e10k_esdp_sdp7_native_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp7_native_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_esdp_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_esdp_sdp2_ts_tt1_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp2_ts_tt1_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_esdp_t e10k_esdp_sdp2_ts_tt1_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp2_ts_tt1_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_esdp_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_esdp_sdp3_ts_tt0_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp3_ts_tt0_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_esdp_t e10k_esdp_sdp3_ts_tt0_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp3_ts_tt0_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_esdp_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_esdp_sdp4_func_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp4_func_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_esdp_t e10k_esdp_sdp4_func_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp4_func_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_esdp_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_esdp_sdp5_func_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp5_func_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_esdp_t e10k_esdp_sdp5_func_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp5_func_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_esdp_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_esdp_sdp6_ts_tt1_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp6_ts_tt1_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_esdp_t e10k_esdp_sdp6_ts_tt1_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp6_ts_tt1_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_esdp_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_esdp_sdp7_ts_tt0_extract(e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp7_ts_tt0_extract(e10k_esdp_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_esdp_t e10k_esdp_sdp7_ts_tt0_insert(e10k_esdp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_sdp7_ts_tt0_insert(e10k_esdp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_esdp_t )(_fieldval)) << 31)));
}

static inline int e10k_esdp_prtval(char *_s, size_t _size, e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline int e10k_esdp_prtval(char *_s, size_t _size, e10k_esdp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_data =\t%" PRIx8 "\t(SDP0 Data Value)\n", e10k_esdp_sdp0_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_data =\t%" PRIx8 "\t(SDP1 Data Value)\n", e10k_esdp_sdp1_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_data =\t%" PRIx8 "\t(SDP2 Data Value)\n", e10k_esdp_sdp2_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_data =\t%" PRIx8 "\t(SDP3 Data Value)\n", e10k_esdp_sdp3_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp4_data =\t%" PRIx8 "\t(SDP4 Data Value)\n", e10k_esdp_sdp4_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp5_data =\t%" PRIx8 "\t(SDP5 Data Value)\n", e10k_esdp_sdp5_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp6_data =\t%" PRIx8 "\t(SDP6 Data Value)\n", e10k_esdp_sdp6_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp7_data =\t%" PRIx8 "\t(SDP7 Data Value)\n", e10k_esdp_sdp7_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_iodir =\t%" PRIx8 "\t(SDP0 Pin Directionality)\n", e10k_esdp_sdp0_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_iodir =\t%" PRIx8 "\t(SDP1 Pin Directionality)\n", e10k_esdp_sdp1_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_iodir =\t%" PRIx8 "\t(SDP2 Pin Directionality)\n", e10k_esdp_sdp2_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_iodir =\t%" PRIx8 "\t(SDP3 Pin Directionality)\n", e10k_esdp_sdp3_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp4_iodir =\t%" PRIx8 "\t(SDP4 Pin Directionality)\n", e10k_esdp_sdp4_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp5_iodir =\t%" PRIx8 "\t(SDP5 Pin Directionality)\n", e10k_esdp_sdp5_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp6_iodir =\t%" PRIx8 "\t(SDP6 Pin Directionality)\n", e10k_esdp_sdp6_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp7_iodir =\t%" PRIx8 "\t(SDP7 Pin Directionality)\n", e10k_esdp_sdp7_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_native =\t%" PRIx8 "\t(SDP0 Operating Mode)\n", e10k_esdp_sdp0_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_native =\t%" PRIx8 "\t(SDP1 Operating Mode)\n", e10k_esdp_sdp1_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_native =\t%" PRIx8 "\t(SDP2 Operating Mode)\n", e10k_esdp_sdp2_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_native =\t%" PRIx8 "\t(SDP3 Operating Mode)\n", e10k_esdp_sdp3_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp4_native =\t%" PRIx8 "\t(SDP4 Operating Mode)\n", e10k_esdp_sdp4_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp5_native =\t%" PRIx8 "\t(SDP5 Operating Mode)\n", e10k_esdp_sdp5_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp6_native =\t%" PRIx8 "\t(SDP6 Operating Mode)\n", e10k_esdp_sdp6_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp7_native =\t%" PRIx8 "\t(SDP7 Operating Mode)\n", e10k_esdp_sdp7_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_ts_tt1 =\t%" PRIx8 "\t(SDP2 Native Mode Functionality)\n", e10k_esdp_sdp2_ts_tt1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_ts_tt0 =\t%" PRIx8 "\t(SDP3 Native Mode Functionality)\n", e10k_esdp_sdp3_ts_tt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp4_func =\t%" PRIx8 "\t(SDP4 Native Mode Functionality)\n", e10k_esdp_sdp4_func_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp5_func =\t%" PRIx8 "\t(SDP5 Native Mode Functionality)\n", e10k_esdp_sdp5_func_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp6_ts_tt1 =\t%" PRIx8 "\t(SDP6 Native Mode Functionality)\n", e10k_esdp_sdp6_ts_tt1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp7_ts_tt0 =\t%" PRIx8 "\t(SDP7 Native Mode Functionality)\n", e10k_esdp_sdp7_ts_tt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_i2cctl_t
 * Description: Implicit type of I2C Control register
 * Fields:
 *   i2c_clkin	(size 1, offset 0, init 0):	RW	I2C_CLK In Value
 *   i2c_clkout	(size 1, offset 1, init 0):	RW	I2C_CLK Out Value
 *   i2c_datain	(size 1, offset 2, init 0):	RW	I2C_DATA In Value
 *   i2c_dataout	(size 1, offset 3, init 0):	RW	I2C_DATA Out Value
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
typedef uint32_t e10k_i2cctl_t;
#define e10k_i2cctl_default 0x0
static inline uint8_t e10k_i2cctl_i2c_clkin_extract(e10k_i2cctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_i2cctl_i2c_clkin_extract(e10k_i2cctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_i2cctl_t e10k_i2cctl_i2c_clkin_insert(e10k_i2cctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_i2cctl_t e10k_i2cctl_i2c_clkin_insert(e10k_i2cctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_i2cctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_i2cctl_i2c_clkout_extract(e10k_i2cctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_i2cctl_i2c_clkout_extract(e10k_i2cctl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_i2cctl_t e10k_i2cctl_i2c_clkout_insert(e10k_i2cctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_i2cctl_t e10k_i2cctl_i2c_clkout_insert(e10k_i2cctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_i2cctl_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_i2cctl_i2c_datain_extract(e10k_i2cctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_i2cctl_i2c_datain_extract(e10k_i2cctl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_i2cctl_t e10k_i2cctl_i2c_datain_insert(e10k_i2cctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_i2cctl_t e10k_i2cctl_i2c_datain_insert(e10k_i2cctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_i2cctl_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_i2cctl_i2c_dataout_extract(e10k_i2cctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_i2cctl_i2c_dataout_extract(e10k_i2cctl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_i2cctl_t e10k_i2cctl_i2c_dataout_insert(e10k_i2cctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_i2cctl_t e10k_i2cctl_i2c_dataout_insert(e10k_i2cctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_i2cctl_t )(_fieldval)) << 3)));
}

static inline int e10k_i2cctl_prtval(char *_s, size_t _size, e10k_i2cctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_i2cctl_prtval(char *_s, size_t _size, e10k_i2cctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i2c_clkin =\t%" PRIx8 "\t(I2C_CLK In Value)\n", e10k_i2cctl_i2c_clkin_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i2c_clkout =\t%" PRIx8 "\t(I2C_CLK Out Value)\n", e10k_i2cctl_i2c_clkout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i2c_datain =\t%" PRIx8 "\t(I2C_DATA In Value)\n", e10k_i2cctl_i2c_datain_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i2c_dataout =\t%" PRIx8 "\t(I2C_DATA Out Value)\n", e10k_i2cctl_i2c_dataout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_ledctl_t
 * Description: Implicit type of LED Control register
 * Fields:
 *   led0_mode	(size 4, offset 0, init 0):	RW	LED0 Mode
 *   _anon4	(size 1, offset 4, init 0):	RSVD	_
 *   glob_blmode	(size 1, offset 5, init 0):	RW	GLOBAL blink mode
 *   led0_ivrt	(size 1, offset 6, init 0):	RW	LED0 Invert
 *   led0_blink	(size 1, offset 7, init 0):	RW	LED0 Blink
 *   led1_mode	(size 4, offset 8, init 0):	RW	LED1 Mode
 *   _anon12	(size 2, offset 12, init 0):	RSVD	_
 *   led1_ivrt	(size 1, offset 14, init 0):	RW	LED1 Invert
 *   led1_blink	(size 1, offset 15, init 0):	RW	LED1 Blink
 *   led2_mode	(size 4, offset 16, init 0):	RW	LED2 Mode
 *   _anon20	(size 2, offset 20, init 0):	RSVD	_
 *   led2_ivrt	(size 1, offset 22, init 0):	RW	LED2 Invert
 *   led2_blink	(size 1, offset 23, init 0):	RW	LED2 Blink
 *   led3_mode	(size 4, offset 24, init 0):	RW	LED3 Mode
 *   _anon28	(size 2, offset 28, init 0):	RSVD	_
 *   led3_ivrt	(size 1, offset 30, init 0):	RW	LED3 Invert
 *   led3_blink	(size 1, offset 31, init 0):	RW	LED3 Blink
 */
typedef uint32_t e10k_ledctl_t;
#define e10k_ledctl_default 0x0
static inline e10k_ledmode_t e10k_ledctl_led0_mode_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline e10k_ledmode_t e10k_ledctl_led0_mode_extract(e10k_ledctl_t _regval)
{
    return((e10k_ledmode_t )((_regval & 0xf) >> 0));
}

static inline e10k_ledctl_t e10k_ledctl_led0_mode_insert(e10k_ledctl_t _regval, e10k_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led0_mode_insert(e10k_ledctl_t _regval, e10k_ledmode_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((e10k_ledctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_ledctl_glob_blmode_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_glob_blmode_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_ledctl_t e10k_ledctl_glob_blmode_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_glob_blmode_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_ledctl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_ledctl_led0_ivrt_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led0_ivrt_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_ledctl_t e10k_ledctl_led0_ivrt_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led0_ivrt_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_ledctl_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_ledctl_led0_blink_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led0_blink_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_ledctl_t e10k_ledctl_led0_blink_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led0_blink_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_ledctl_t )(_fieldval)) << 7)));
}

static inline e10k_ledmode_t e10k_ledctl_led1_mode_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline e10k_ledmode_t e10k_ledctl_led1_mode_extract(e10k_ledctl_t _regval)
{
    return((e10k_ledmode_t )((_regval & 0xf00) >> 8));
}

static inline e10k_ledctl_t e10k_ledctl_led1_mode_insert(e10k_ledctl_t _regval, e10k_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led1_mode_insert(e10k_ledctl_t _regval, e10k_ledmode_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((e10k_ledctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_ledctl_led1_ivrt_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led1_ivrt_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_ledctl_t e10k_ledctl_led1_ivrt_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led1_ivrt_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_ledctl_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_ledctl_led1_blink_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led1_blink_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_ledctl_t e10k_ledctl_led1_blink_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led1_blink_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_ledctl_t )(_fieldval)) << 15)));
}

static inline e10k_ledmode_t e10k_ledctl_led2_mode_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline e10k_ledmode_t e10k_ledctl_led2_mode_extract(e10k_ledctl_t _regval)
{
    return((e10k_ledmode_t )((_regval & 0xf0000) >> 16));
}

static inline e10k_ledctl_t e10k_ledctl_led2_mode_insert(e10k_ledctl_t _regval, e10k_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led2_mode_insert(e10k_ledctl_t _regval, e10k_ledmode_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((e10k_ledctl_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_ledctl_led2_ivrt_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led2_ivrt_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_ledctl_t e10k_ledctl_led2_ivrt_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led2_ivrt_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_ledctl_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_ledctl_led2_blink_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led2_blink_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_ledctl_t e10k_ledctl_led2_blink_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led2_blink_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_ledctl_t )(_fieldval)) << 23)));
}

static inline e10k_ledmode_t e10k_ledctl_led3_mode_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline e10k_ledmode_t e10k_ledctl_led3_mode_extract(e10k_ledctl_t _regval)
{
    return((e10k_ledmode_t )((_regval & 0xf000000) >> 24));
}

static inline e10k_ledctl_t e10k_ledctl_led3_mode_insert(e10k_ledctl_t _regval, e10k_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led3_mode_insert(e10k_ledctl_t _regval, e10k_ledmode_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((e10k_ledctl_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_ledctl_led3_ivrt_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led3_ivrt_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_ledctl_t e10k_ledctl_led3_ivrt_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led3_ivrt_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_ledctl_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_ledctl_led3_blink_extract(e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led3_blink_extract(e10k_ledctl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_ledctl_t e10k_ledctl_led3_blink_insert(e10k_ledctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_led3_blink_insert(e10k_ledctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_ledctl_t )(_fieldval)) << 31)));
}

static inline int e10k_ledctl_prtval(char *_s, size_t _size, e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_ledctl_prtval(char *_s, size_t _size, e10k_ledctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledmode_prtval(_s + _r, _avail, e10k_ledctl_led0_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED0 Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " glob_blmode =\t%" PRIx8 "\t(GLOBAL blink mode)\n", e10k_ledctl_glob_blmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_ivrt =\t%" PRIx8 "\t(LED0 Invert)\n", e10k_ledctl_led0_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_blink =\t%" PRIx8 "\t(LED0 Blink)\n", e10k_ledctl_led0_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledmode_prtval(_s + _r, _avail, e10k_ledctl_led1_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED1 Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_ivrt =\t%" PRIx8 "\t(LED1 Invert)\n", e10k_ledctl_led1_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_blink =\t%" PRIx8 "\t(LED1 Blink)\n", e10k_ledctl_led1_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledmode_prtval(_s + _r, _avail, e10k_ledctl_led2_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED2 Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_ivrt =\t%" PRIx8 "\t(LED2 Invert)\n", e10k_ledctl_led2_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_blink =\t%" PRIx8 "\t(LED2 Blink)\n", e10k_ledctl_led2_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledmode_prtval(_s + _r, _avail, e10k_ledctl_led3_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED3 Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_ivrt =\t%" PRIx8 "\t(LED3 Invert)\n", e10k_ledctl_led3_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_blink =\t%" PRIx8 "\t(LED3 Blink)\n", e10k_ledctl_led3_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_exvet_t
 * Description: Implicit type of Extended VLAN Ether Type  register
 * Fields:
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   vet_ext	(size 16, offset 16, init 0):	RW	Outer-VLAN Ether Type
 */
typedef uint32_t e10k_exvet_t;
#define e10k_exvet_default 0x0
static inline uint16_t e10k_exvet_vet_ext_extract(e10k_exvet_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_exvet_vet_ext_extract(e10k_exvet_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_exvet_t e10k_exvet_vet_ext_insert(e10k_exvet_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_exvet_t e10k_exvet_vet_ext_insert(e10k_exvet_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_exvet_t )(_fieldval)) << 16)));
}

static inline int e10k_exvet_prtval(char *_s, size_t _size, e10k_exvet_t _regval) __attribute__ ((always_inline));
static inline int e10k_exvet_prtval(char *_s, size_t _size, e10k_exvet_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vet_ext =\t%" PRIx16 "\t(Outer-VLAN Ether Type)\n", e10k_exvet_vet_ext_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eec_t
 * Description: Implicit type of EEPROM/Flash Control Register register
 * Fields:
 *   ee_sk	(size 1, offset 0, init 0):	RW	Clock input to the EEPROM
 *   ee_cs	(size 1, offset 1, init 0):	RW	Chip select input to the EEPROM
 *   ee_di	(size 1, offset 2, init 0):	RW	Data input to the EEPROM
 *   ee_do	(size 1, offset 3, init 0):	RO	Data output bit from the EEPROM
 *   fwe	(size 2, offset 4, init 0):	RW	Flash Write Enable Control
 *   ee_req	(size 1, offset 6, init 0):	RW	Request EEPROM Access
 *   ee_gnt	(size 1, offset 7, init 0):	RO	Grant EEPROM Access
 *   ee_pres	(size 1, offset 8, init 0):	RO	EEPROM Present
 *   auto_rd	(size 1, offset 9, init 0):	RO	EEPROM Auto-Read Done
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   ee_size	(size 4, offset 11, init 0):	RO	EEPROM Size
 *   pci_anadon	(size 1, offset 15, init 0):	RO	PCIe Analog Done
 *   pci_cordon	(size 1, offset 16, init 0):	RO	PCIe Core Done
 *   pci_gendon	(size 1, offset 17, init 0):	RO	PCIe General Done
 *   pci_fundon	(size 1, offset 18, init 0):	RO	PCIe Function Done
 *   core_done	(size 1, offset 19, init 0):	RO	Core Done
 *   core_csrdon	(size 1, offset 20, init 0):	RO	Core CSR Done
 *   mac_done	(size 1, offset 21, init 0):	RO	MAC Done
 *   _anon22	(size 10, offset 22, init 0):	RSVD	_
 */
typedef uint32_t e10k_eec_t;
#define e10k_eec_default 0x0
static inline uint8_t e10k_eec_ee_sk_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_sk_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_eec_t e10k_eec_ee_sk_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_ee_sk_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_eec_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_eec_ee_cs_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_cs_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_eec_t e10k_eec_ee_cs_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_ee_cs_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_eec_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_eec_ee_di_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_di_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_eec_t e10k_eec_ee_di_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_ee_di_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_eec_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_eec_ee_do_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_do_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_eec_t e10k_eec_ee_do_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_ee_do_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_eec_t )(_fieldval)) << 3)));
}

static inline e10k_fwe_control_t e10k_eec_fwe_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline e10k_fwe_control_t e10k_eec_fwe_extract(e10k_eec_t _regval)
{
    return((e10k_fwe_control_t )((_regval & 0x30) >> 4));
}

static inline e10k_eec_t e10k_eec_fwe_insert(e10k_eec_t _regval, e10k_fwe_control_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_fwe_insert(e10k_eec_t _regval, e10k_fwe_control_t _fieldval)
{
    return((_regval & 0xffffffcf) | (0x30 & (((e10k_eec_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_eec_ee_req_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_req_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_eec_t e10k_eec_ee_req_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_ee_req_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_eec_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_eec_ee_gnt_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_gnt_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_eec_t e10k_eec_ee_gnt_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_ee_gnt_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_eec_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_eec_ee_pres_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_pres_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_eec_t e10k_eec_ee_pres_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_ee_pres_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_eec_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_eec_auto_rd_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_auto_rd_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_eec_t e10k_eec_auto_rd_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_auto_rd_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_eec_t )(_fieldval)) << 9)));
}

static inline e10k_eeprom_size_t e10k_eec_ee_size_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline e10k_eeprom_size_t e10k_eec_ee_size_extract(e10k_eec_t _regval)
{
    return((e10k_eeprom_size_t )((_regval & 0x7800) >> 11));
}

static inline e10k_eec_t e10k_eec_ee_size_insert(e10k_eec_t _regval, e10k_eeprom_size_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_ee_size_insert(e10k_eec_t _regval, e10k_eeprom_size_t _fieldval)
{
    return((_regval & 0xffff87ff) | (0x7800 & (((e10k_eec_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_eec_pci_anadon_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_pci_anadon_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_eec_t e10k_eec_pci_anadon_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_pci_anadon_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_eec_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_eec_pci_cordon_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_pci_cordon_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_eec_t e10k_eec_pci_cordon_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_pci_cordon_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_eec_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_eec_pci_gendon_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_pci_gendon_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_eec_t e10k_eec_pci_gendon_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_pci_gendon_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_eec_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_eec_pci_fundon_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_pci_fundon_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_eec_t e10k_eec_pci_fundon_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_pci_fundon_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_eec_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_eec_core_done_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_core_done_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_eec_t e10k_eec_core_done_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_core_done_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_eec_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_eec_core_csrdon_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_core_csrdon_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_eec_t e10k_eec_core_csrdon_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_core_csrdon_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_eec_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_eec_mac_done_extract(e10k_eec_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_mac_done_extract(e10k_eec_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_eec_t e10k_eec_mac_done_insert(e10k_eec_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_mac_done_insert(e10k_eec_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_eec_t )(_fieldval)) << 21)));
}

static inline int e10k_eec_prtval(char *_s, size_t _size, e10k_eec_t _regval) __attribute__ ((always_inline));
static inline int e10k_eec_prtval(char *_s, size_t _size, e10k_eec_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_sk =\t%" PRIx8 "\t(Clock input to the EEPROM)\n", e10k_eec_ee_sk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_cs =\t%" PRIx8 "\t(Chip select input to the EEPROM)\n", e10k_eec_ee_cs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_di =\t%" PRIx8 "\t(Data input to the EEPROM)\n", e10k_eec_ee_di_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_do =\t%" PRIx8 "\t(Data output bit from the EEPROM)\n", e10k_eec_ee_do_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fwe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fwe_control_prtval(_s + _r, _avail, e10k_eec_fwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Flash Write Enable Control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_req =\t%" PRIx8 "\t(Request EEPROM Access)\n", e10k_eec_ee_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_gnt =\t%" PRIx8 "\t(Grant EEPROM Access)\n", e10k_eec_ee_gnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_pres =\t%" PRIx8 "\t(EEPROM Present)\n", e10k_eec_ee_pres_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_rd =\t%" PRIx8 "\t(EEPROM Auto-Read Done)\n", e10k_eec_auto_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_size =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eeprom_size_prtval(_s + _r, _avail, e10k_eec_ee_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(EEPROM Size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_anadon =\t%" PRIx8 "\t(PCIe Analog Done)\n", e10k_eec_pci_anadon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_cordon =\t%" PRIx8 "\t(PCIe Core Done)\n", e10k_eec_pci_cordon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_gendon =\t%" PRIx8 "\t(PCIe General Done)\n", e10k_eec_pci_gendon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_fundon =\t%" PRIx8 "\t(PCIe Function Done)\n", e10k_eec_pci_fundon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " core_done =\t%" PRIx8 "\t(Core Done)\n", e10k_eec_core_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " core_csrdon =\t%" PRIx8 "\t(Core CSR Done)\n", e10k_eec_core_csrdon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mac_done =\t%" PRIx8 "\t(MAC Done)\n", e10k_eec_mac_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eerd_t
 * Description: Implicit type of EEPROM Read Register register
 * Fields:
 *   start	(size 1, offset 0, init 0):	RW	Start Read
 *   done	(size 1, offset 1, init 0):	RW	Read Done
 *   addr	(size 14, offset 2, init 0):	RW	Read Address
 *   data	(size 16, offset 16, init 0):	RW	Read Data
 */
typedef uint32_t e10k_eerd_t;
#define e10k_eerd_default 0x0
static inline uint8_t e10k_eerd_start_extract(e10k_eerd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eerd_start_extract(e10k_eerd_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_eerd_t e10k_eerd_start_insert(e10k_eerd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eerd_t e10k_eerd_start_insert(e10k_eerd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_eerd_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_eerd_done_extract(e10k_eerd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eerd_done_extract(e10k_eerd_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_eerd_t e10k_eerd_done_insert(e10k_eerd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eerd_t e10k_eerd_done_insert(e10k_eerd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_eerd_t )(_fieldval)) << 1)));
}

static inline uint16_t e10k_eerd_addr_extract(e10k_eerd_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_eerd_addr_extract(e10k_eerd_t _regval)
{
    return((uint16_t )((_regval & 0xfffc) >> 2));
}

static inline e10k_eerd_t e10k_eerd_addr_insert(e10k_eerd_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eerd_t e10k_eerd_addr_insert(e10k_eerd_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0003) | (0xfffc & (((e10k_eerd_t )(_fieldval)) << 2)));
}

static inline uint16_t e10k_eerd_data_extract(e10k_eerd_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_eerd_data_extract(e10k_eerd_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_eerd_t e10k_eerd_data_insert(e10k_eerd_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eerd_t e10k_eerd_data_insert(e10k_eerd_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_eerd_t )(_fieldval)) << 16)));
}

static inline int e10k_eerd_prtval(char *_s, size_t _size, e10k_eerd_t _regval) __attribute__ ((always_inline));
static inline int e10k_eerd_prtval(char *_s, size_t _size, e10k_eerd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start Read)\n", e10k_eerd_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Read Done)\n", e10k_eerd_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(Read Address)\n", e10k_eerd_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Read Data)\n", e10k_eerd_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fla_t
 * Description: Implicit type of Flash Access Register register
 * Fields:
 *   fl_sck	(size 1, offset 0, init 0):	RW	Clock input to the Flash
 *   fl_ce	(size 1, offset 1, init 0):	RW	Chip select input to the Flash
 *   fl_si	(size 1, offset 2, init 0):	RW	Data input to the Flash
 *   fl_so	(size 1, offset 3, init 0):	RO	Data output bit from the Flash
 *   fl_req	(size 1, offset 4, init 0):	RW	Request Flash Access
 *   fl_gnt	(size 1, offset 5, init 0):	RW	Grant Flash Access
 *   _anon6	(size 24, offset 6, init 0):	MBZ	_
 *   fl_busy	(size 1, offset 30, init 0):	RO	Flash Busy
 *   fl_er	(size 1, offset 31, init 0):	RW	Flash Erase Command
 */
typedef uint32_t e10k_fla_t;
#define e10k_fla_default 0x0
static inline uint8_t e10k_fla_fl_sck_extract(e10k_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_sck_extract(e10k_fla_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_fla_t e10k_fla_fl_sck_insert(e10k_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_fl_sck_insert(e10k_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_fla_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_fla_fl_ce_extract(e10k_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_ce_extract(e10k_fla_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_fla_t e10k_fla_fl_ce_insert(e10k_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_fl_ce_insert(e10k_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_fla_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_fla_fl_si_extract(e10k_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_si_extract(e10k_fla_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_fla_t e10k_fla_fl_si_insert(e10k_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_fl_si_insert(e10k_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_fla_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_fla_fl_so_extract(e10k_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_so_extract(e10k_fla_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_fla_t e10k_fla_fl_so_insert(e10k_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_fl_so_insert(e10k_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_fla_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_fla_fl_req_extract(e10k_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_req_extract(e10k_fla_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_fla_t e10k_fla_fl_req_insert(e10k_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_fl_req_insert(e10k_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_fla_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_fla_fl_gnt_extract(e10k_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_gnt_extract(e10k_fla_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_fla_t e10k_fla_fl_gnt_insert(e10k_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_fl_gnt_insert(e10k_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_fla_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_fla_fl_busy_extract(e10k_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_busy_extract(e10k_fla_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_fla_t e10k_fla_fl_busy_insert(e10k_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_fl_busy_insert(e10k_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_fla_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_fla_fl_er_extract(e10k_fla_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_er_extract(e10k_fla_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_fla_t e10k_fla_fl_er_insert(e10k_fla_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_fl_er_insert(e10k_fla_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_fla_t )(_fieldval)) << 31)));
}

static inline int e10k_fla_prtval(char *_s, size_t _size, e10k_fla_t _regval) __attribute__ ((always_inline));
static inline int e10k_fla_prtval(char *_s, size_t _size, e10k_fla_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_sck =\t%" PRIx8 "\t(Clock input to the Flash)\n", e10k_fla_fl_sck_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_ce =\t%" PRIx8 "\t(Chip select input to the Flash)\n", e10k_fla_fl_ce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_si =\t%" PRIx8 "\t(Data input to the Flash)\n", e10k_fla_fl_si_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_so =\t%" PRIx8 "\t(Data output bit from the Flash)\n", e10k_fla_fl_so_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_req =\t%" PRIx8 "\t(Request Flash Access)\n", e10k_fla_fl_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_gnt =\t%" PRIx8 "\t(Grant Flash Access)\n", e10k_fla_fl_gnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_busy =\t%" PRIx8 "\t(Flash Busy)\n", e10k_fla_fl_busy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_er =\t%" PRIx8 "\t(Flash Erase Command)\n", e10k_fla_fl_er_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eemngctl_t
 * Description: Implicit type of Manageability EEPROM Control Register register
 * Fields:
 *   addr	(size 15, offset 0, init 0):	RW	EEPROM address to read or write
 *   start	(size 1, offset 15, init 0):	RW	Start
 *   write	(size 1, offset 16, init 0):	RW	Write
 *   eebusy	(size 1, offset 17, init 0):	RW	EPROM Busy
 *   _anon18	(size 13, offset 18, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	RW	Transaction Done
 */
typedef uint32_t e10k_eemngctl_t;
#define e10k_eemngctl_default 0x0
static inline uint16_t e10k_eemngctl_addr_extract(e10k_eemngctl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_eemngctl_addr_extract(e10k_eemngctl_t _regval)
{
    return((uint16_t )((_regval & 0x7fff) >> 0));
}

static inline e10k_eemngctl_t e10k_eemngctl_addr_insert(e10k_eemngctl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eemngctl_t e10k_eemngctl_addr_insert(e10k_eemngctl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff8000) | (0x7fff & (((e10k_eemngctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_eemngctl_start_extract(e10k_eemngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eemngctl_start_extract(e10k_eemngctl_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_eemngctl_t e10k_eemngctl_start_insert(e10k_eemngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eemngctl_t e10k_eemngctl_start_insert(e10k_eemngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_eemngctl_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_eemngctl_write_extract(e10k_eemngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eemngctl_write_extract(e10k_eemngctl_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_eemngctl_t e10k_eemngctl_write_insert(e10k_eemngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eemngctl_t e10k_eemngctl_write_insert(e10k_eemngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_eemngctl_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_eemngctl_eebusy_extract(e10k_eemngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eemngctl_eebusy_extract(e10k_eemngctl_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_eemngctl_t e10k_eemngctl_eebusy_insert(e10k_eemngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eemngctl_t e10k_eemngctl_eebusy_insert(e10k_eemngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_eemngctl_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_eemngctl_done_extract(e10k_eemngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eemngctl_done_extract(e10k_eemngctl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_eemngctl_t e10k_eemngctl_done_insert(e10k_eemngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eemngctl_t e10k_eemngctl_done_insert(e10k_eemngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_eemngctl_t )(_fieldval)) << 31)));
}

static inline int e10k_eemngctl_prtval(char *_s, size_t _size, e10k_eemngctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_eemngctl_prtval(char *_s, size_t _size, e10k_eemngctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(EEPROM address to read or write)\n", e10k_eemngctl_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start)\n", e10k_eemngctl_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " write =\t%" PRIx8 "\t(Write)\n", e10k_eemngctl_write_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eebusy =\t%" PRIx8 "\t(EPROM Busy)\n", e10k_eemngctl_eebusy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Transaction Done)\n", e10k_eemngctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eemngdata_t
 * Description: Implicit type of Manageability EEPROM Read/Write Data register
 * Fields:
 *   wrdata	(size 16, offset 0, init 0):	RW	Data to be written to the EEPROM
 *   rddata	(size 16, offset 16, init 0):	RO	Data returned from the EEPROM read
 */
typedef uint32_t e10k_eemngdata_t;
#define e10k_eemngdata_default 0x0
static inline uint16_t e10k_eemngdata_wrdata_extract(e10k_eemngdata_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_eemngdata_wrdata_extract(e10k_eemngdata_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_eemngdata_t e10k_eemngdata_wrdata_insert(e10k_eemngdata_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eemngdata_t e10k_eemngdata_wrdata_insert(e10k_eemngdata_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_eemngdata_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_eemngdata_rddata_extract(e10k_eemngdata_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_eemngdata_rddata_extract(e10k_eemngdata_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_eemngdata_t e10k_eemngdata_rddata_insert(e10k_eemngdata_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eemngdata_t e10k_eemngdata_rddata_insert(e10k_eemngdata_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_eemngdata_t )(_fieldval)) << 16)));
}

static inline int e10k_eemngdata_prtval(char *_s, size_t _size, e10k_eemngdata_t _regval) __attribute__ ((always_inline));
static inline int e10k_eemngdata_prtval(char *_s, size_t _size, e10k_eemngdata_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrdata =\t%" PRIx16 "\t(Data to be written to the EEPROM)\n", e10k_eemngdata_wrdata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rddata =\t%" PRIx16 "\t(Data returned from the EEPROM read)\n", e10k_eemngdata_rddata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_flmngctl_t
 * Description: Implicit type of Manageability Flash Control Register register
 * Fields:
 *   addr	(size 24, offset 0, init 0):	RW	Flash address to read or write
 *   cmd	(size 2, offset 24, init 0):	RW	Command
 *   cmdv	(size 1, offset 26, init 0):	RW	Command Valid
 *   flbusy	(size 1, offset 27, init 0):	RW	Flash Busy
 *   _anon28	(size 2, offset 28, init 0):	RSVD	_
 *   done	(size 1, offset 30, init 0):	RC	Read Done
 *   wrdone	(size 1, offset 31, init 0):	RW	Global Done
 */
typedef uint32_t e10k_flmngctl_t;
#define e10k_flmngctl_default 0x0
static inline uint32_t e10k_flmngctl_addr_extract(e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_flmngctl_addr_extract(e10k_flmngctl_t _regval)
{
    return((uint32_t )((_regval & 0xffffff) >> 0));
}

static inline e10k_flmngctl_t e10k_flmngctl_addr_insert(e10k_flmngctl_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flmngctl_t e10k_flmngctl_addr_insert(e10k_flmngctl_t _regval, uint32_t _fieldval)
{
    return((_regval & 0xff000000) | (0xffffff & (((e10k_flmngctl_t )(_fieldval)) << 0)));
}

static inline e10k_flmng_command_t e10k_flmngctl_cmd_extract(e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline e10k_flmng_command_t e10k_flmngctl_cmd_extract(e10k_flmngctl_t _regval)
{
    return((e10k_flmng_command_t )((_regval & 0x3000000) >> 24));
}

static inline e10k_flmngctl_t e10k_flmngctl_cmd_insert(e10k_flmngctl_t _regval, e10k_flmng_command_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flmngctl_t e10k_flmngctl_cmd_insert(e10k_flmngctl_t _regval, e10k_flmng_command_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((e10k_flmngctl_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_flmngctl_cmdv_extract(e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_flmngctl_cmdv_extract(e10k_flmngctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_flmngctl_t e10k_flmngctl_cmdv_insert(e10k_flmngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flmngctl_t e10k_flmngctl_cmdv_insert(e10k_flmngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_flmngctl_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_flmngctl_flbusy_extract(e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_flmngctl_flbusy_extract(e10k_flmngctl_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_flmngctl_t e10k_flmngctl_flbusy_insert(e10k_flmngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flmngctl_t e10k_flmngctl_flbusy_insert(e10k_flmngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_flmngctl_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_flmngctl_done_extract(e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_flmngctl_done_extract(e10k_flmngctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_flmngctl_t e10k_flmngctl_done_insert(e10k_flmngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flmngctl_t e10k_flmngctl_done_insert(e10k_flmngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_flmngctl_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_flmngctl_wrdone_extract(e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_flmngctl_wrdone_extract(e10k_flmngctl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_flmngctl_t e10k_flmngctl_wrdone_insert(e10k_flmngctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flmngctl_t e10k_flmngctl_wrdone_insert(e10k_flmngctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_flmngctl_t )(_fieldval)) << 31)));
}

static inline int e10k_flmngctl_prtval(char *_s, size_t _size, e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_flmngctl_prtval(char *_s, size_t _size, e10k_flmngctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Flash address to read or write)\n", e10k_flmngctl_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_flmng_command_prtval(_s + _r, _avail, e10k_flmngctl_cmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Command)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmdv =\t%" PRIx8 "\t(Command Valid)\n", e10k_flmngctl_cmdv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flbusy =\t%" PRIx8 "\t(Flash Busy)\n", e10k_flmngctl_flbusy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Read Done)\n", e10k_flmngctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrdone =\t%" PRIx8 "\t(Global Done)\n", e10k_flmngctl_wrdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_flmngdata_t
 * Description: Implicit type of Manageability Flash Read Data register
 * Fields:
 *   data	(size 32, offset 0, init 0):	RW	Read/Write Data
 */
typedef uint32_t e10k_flmngdata_t;
#define e10k_flmngdata_default 0x0
static inline uint32_t e10k_flmngdata_data_extract(e10k_flmngdata_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_flmngdata_data_extract(e10k_flmngdata_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_flmngdata_t e10k_flmngdata_data_insert(e10k_flmngdata_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flmngdata_t e10k_flmngdata_data_insert(e10k_flmngdata_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_flmngdata_t )(_fieldval)) << 0)));
}

static inline int e10k_flmngdata_prtval(char *_s, size_t _size, e10k_flmngdata_t _regval) __attribute__ ((always_inline));
static inline int e10k_flmngdata_prtval(char *_s, size_t _size, e10k_flmngdata_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx32 "\t(Read/Write Data)\n", e10k_flmngdata_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_flop_t
 * Description: Implicit type of Flash Opcode Register register
 * Fields:
 *   serase	(size 8, offset 0, init 0):	RW	Flash Block Erase Instruction
 *   derase	(size 8, offset 8, init 0):	RW	Flash Device Erase Instruction
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_flop_t;
#define e10k_flop_default 0x0
static inline uint8_t e10k_flop_serase_extract(e10k_flop_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_flop_serase_extract(e10k_flop_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e10k_flop_t e10k_flop_serase_insert(e10k_flop_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flop_t e10k_flop_serase_insert(e10k_flop_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_flop_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_flop_derase_extract(e10k_flop_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_flop_derase_extract(e10k_flop_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e10k_flop_t e10k_flop_derase_insert(e10k_flop_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_flop_t e10k_flop_derase_insert(e10k_flop_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e10k_flop_t )(_fieldval)) << 8)));
}

static inline int e10k_flop_prtval(char *_s, size_t _size, e10k_flop_t _regval) __attribute__ ((always_inline));
static inline int e10k_flop_prtval(char *_s, size_t _size, e10k_flop_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " serase =\t%" PRIx8 "\t(Flash Block Erase Instruction)\n", e10k_flop_serase_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " derase =\t%" PRIx8 "\t(Flash Device Erase Instruction)\n", e10k_flop_derase_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_grc_t
 * Description: Implicit type of General Receive Control register
 * Fields:
 *   mng_en	(size 1, offset 0, init 0):	RO	Manageability Enable
 *   apme	(size 1, offset 1, init 0):	RW	Advance Power Management Enable
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
typedef uint32_t e10k_grc_t;
#define e10k_grc_default 0x0
static inline uint8_t e10k_grc_mng_en_extract(e10k_grc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_grc_mng_en_extract(e10k_grc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_grc_t e10k_grc_mng_en_insert(e10k_grc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_grc_t e10k_grc_mng_en_insert(e10k_grc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_grc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_grc_apme_extract(e10k_grc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_grc_apme_extract(e10k_grc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_grc_t e10k_grc_apme_insert(e10k_grc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_grc_t e10k_grc_apme_insert(e10k_grc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_grc_t )(_fieldval)) << 1)));
}

static inline int e10k_grc_prtval(char *_s, size_t _size, e10k_grc_t _regval) __attribute__ ((always_inline));
static inline int e10k_grc_prtval(char *_s, size_t _size, e10k_grc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mng_en =\t%" PRIx8 "\t(Manageability Enable)\n", e10k_grc_mng_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apme =\t%" PRIx8 "\t(Advance Power Management Enable)\n", e10k_grc_apme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pfctop_t
 * Description: Implicit type of Priority Flow Control Type Opcode register
 * Fields:
 *   fct	(size 16, offset 0, init 0):	RW	Priority Flow Control EtherType
 *   fcop	(size 16, offset 16, init 0):	RW	Priority Flow Control Opcode
 */
typedef uint32_t e10k_pfctop_t;
#define e10k_pfctop_default 0x0
static inline uint16_t e10k_pfctop_fct_extract(e10k_pfctop_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_pfctop_fct_extract(e10k_pfctop_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_pfctop_t e10k_pfctop_fct_insert(e10k_pfctop_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfctop_t e10k_pfctop_fct_insert(e10k_pfctop_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_pfctop_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_pfctop_fcop_extract(e10k_pfctop_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_pfctop_fcop_extract(e10k_pfctop_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_pfctop_t e10k_pfctop_fcop_insert(e10k_pfctop_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfctop_t e10k_pfctop_fcop_insert(e10k_pfctop_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_pfctop_t )(_fieldval)) << 16)));
}

static inline int e10k_pfctop_prtval(char *_s, size_t _size, e10k_pfctop_t _regval) __attribute__ ((always_inline));
static inline int e10k_pfctop_prtval(char *_s, size_t _size, e10k_pfctop_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fct =\t%" PRIx16 "\t(Priority Flow Control EtherType)\n", e10k_pfctop_fct_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcop =\t%" PRIx16 "\t(Priority Flow Control Opcode)\n", e10k_pfctop_fcop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fcttv_t
 * Description: Implicit type of Flow Control Transmit Timer Value register array
 * Fields:
 *   ttv0	(size 16, offset 0, init 0):	NOATTR	Transmit Timer Value 2n
 *   ttv1	(size 16, offset 16, init 0):	NOATTR	Transmit Timer Value 2n+1
 */
typedef uint32_t e10k_fcttv_t;
#define e10k_fcttv_default 0x0
static inline uint16_t e10k_fcttv_ttv0_extract(e10k_fcttv_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fcttv_ttv0_extract(e10k_fcttv_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fcttv_t e10k_fcttv_ttv0_insert(e10k_fcttv_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fcttv_t e10k_fcttv_ttv0_insert(e10k_fcttv_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fcttv_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_fcttv_ttv1_extract(e10k_fcttv_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fcttv_ttv1_extract(e10k_fcttv_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_fcttv_t e10k_fcttv_ttv1_insert(e10k_fcttv_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fcttv_t e10k_fcttv_ttv1_insert(e10k_fcttv_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_fcttv_t )(_fieldval)) << 16)));
}

static inline int e10k_fcttv_prtval(char *_s, size_t _size, e10k_fcttv_t _regval) __attribute__ ((always_inline));
static inline int e10k_fcttv_prtval(char *_s, size_t _size, e10k_fcttv_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ttv0 =\t%" PRIx16 "\t(Transmit Timer Value 2n)\n", e10k_fcttv_ttv0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ttv1 =\t%" PRIx16 "\t(Transmit Timer Value 2n+1)\n", e10k_fcttv_ttv1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fcrtl_t
 * Description: Implicit type of Flow Control Receive Threshold Low register array
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rtl	(size 14, offset 5, init 0):	NOATTR	Receive Threshold Low n
 *   _anon19	(size 12, offset 19, init 0):	RSVD	_
 *   xone	(size 1, offset 31, init 0):	NOATTR	XON Enable n
 */
typedef uint32_t e10k_fcrtl_t;
#define e10k_fcrtl_default 0x0
static inline uint16_t e10k_fcrtl_rtl_extract(e10k_fcrtl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fcrtl_rtl_extract(e10k_fcrtl_t _regval)
{
    return((uint16_t )((_regval & 0x7ffe0) >> 5));
}

static inline e10k_fcrtl_t e10k_fcrtl_rtl_insert(e10k_fcrtl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fcrtl_t e10k_fcrtl_rtl_insert(e10k_fcrtl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfff8001f) | (0x7ffe0 & (((e10k_fcrtl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_fcrtl_xone_extract(e10k_fcrtl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fcrtl_xone_extract(e10k_fcrtl_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_fcrtl_t e10k_fcrtl_xone_insert(e10k_fcrtl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fcrtl_t e10k_fcrtl_xone_insert(e10k_fcrtl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_fcrtl_t )(_fieldval)) << 31)));
}

static inline int e10k_fcrtl_prtval(char *_s, size_t _size, e10k_fcrtl_t _regval) __attribute__ ((always_inline));
static inline int e10k_fcrtl_prtval(char *_s, size_t _size, e10k_fcrtl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtl =\t%" PRIx16 "\t(Receive Threshold Low n)\n", e10k_fcrtl_rtl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xone =\t%" PRIx8 "\t(XON Enable n)\n", e10k_fcrtl_xone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fcrth_t
 * Description: Implicit type of Flow Control Receive Threshold High register array
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rth	(size 14, offset 5, init 0):	NOATTR	Receive Threshold High n
 *   _anon19	(size 12, offset 19, init 0):	RSVD	_
 *   fcen	(size 1, offset 31, init 0):	NOATTR	Transmit flow control enable for packet buffer n
 */
typedef uint32_t e10k_fcrth_t;
#define e10k_fcrth_default 0x0
static inline uint16_t e10k_fcrth_rth_extract(e10k_fcrth_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fcrth_rth_extract(e10k_fcrth_t _regval)
{
    return((uint16_t )((_regval & 0x7ffe0) >> 5));
}

static inline e10k_fcrth_t e10k_fcrth_rth_insert(e10k_fcrth_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fcrth_t e10k_fcrth_rth_insert(e10k_fcrth_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfff8001f) | (0x7ffe0 & (((e10k_fcrth_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_fcrth_fcen_extract(e10k_fcrth_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fcrth_fcen_extract(e10k_fcrth_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_fcrth_t e10k_fcrth_fcen_insert(e10k_fcrth_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fcrth_t e10k_fcrth_fcen_insert(e10k_fcrth_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_fcrth_t )(_fieldval)) << 31)));
}

static inline int e10k_fcrth_prtval(char *_s, size_t _size, e10k_fcrth_t _regval) __attribute__ ((always_inline));
static inline int e10k_fcrth_prtval(char *_s, size_t _size, e10k_fcrth_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rth =\t%" PRIx16 "\t(Receive Threshold High n)\n", e10k_fcrth_rth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcen =\t%" PRIx8 "\t(Transmit flow control enable for packet buffer n)\n", e10k_fcrth_fcen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fcrtv_t
 * Description: Implicit type of Flow Control Refresh Threshold Value register
 * Fields:
 *   fc_refth	(size 16, offset 0, init 0):	RW	Flow Control Refresh Threshold
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_fcrtv_t;
#define e10k_fcrtv_default 0x0
static inline uint16_t e10k_fcrtv_fc_refth_extract(e10k_fcrtv_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fcrtv_fc_refth_extract(e10k_fcrtv_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fcrtv_t e10k_fcrtv_fc_refth_insert(e10k_fcrtv_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fcrtv_t e10k_fcrtv_fc_refth_insert(e10k_fcrtv_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fcrtv_t )(_fieldval)) << 0)));
}

static inline int e10k_fcrtv_prtval(char *_s, size_t _size, e10k_fcrtv_t _regval) __attribute__ ((always_inline));
static inline int e10k_fcrtv_prtval(char *_s, size_t _size, e10k_fcrtv_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fc_refth =\t%" PRIx16 "\t(Flow Control Refresh Threshold)\n", e10k_fcrtv_fc_refth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_tfcs_t
 * Description: Implicit type of Transmit Flow Control Status register
 * Fields:
 *   tc_xon	(size 8, offset 0, init 0):	RO	Set if flow control is in XON state
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t e10k_tfcs_t;
#define e10k_tfcs_default 0x0
static inline uint8_t e10k_tfcs_tc_xon_extract(e10k_tfcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_tfcs_tc_xon_extract(e10k_tfcs_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e10k_tfcs_t e10k_tfcs_tc_xon_insert(e10k_tfcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tfcs_t e10k_tfcs_tc_xon_insert(e10k_tfcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_tfcs_t )(_fieldval)) << 0)));
}

static inline int e10k_tfcs_prtval(char *_s, size_t _size, e10k_tfcs_t _regval) __attribute__ ((always_inline));
static inline int e10k_tfcs_prtval(char *_s, size_t _size, e10k_tfcs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc_xon =\t%" PRIx8 "\t(Set if flow control is in XON state)\n", e10k_tfcs_tc_xon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fccfg_t
 * Description: Implicit type of Flow Control Configuration register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   tfce	(size 2, offset 3, init 0):	RW	Transmit Flow Control Enable
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
typedef uint32_t e10k_fccfg_t;
#define e10k_fccfg_default 0x0
static inline e10k_tfc_status_t e10k_fccfg_tfce_extract(e10k_fccfg_t _regval) __attribute__ ((always_inline));
static inline e10k_tfc_status_t e10k_fccfg_tfce_extract(e10k_fccfg_t _regval)
{
    return((e10k_tfc_status_t )((_regval & 0x18) >> 3));
}

static inline e10k_fccfg_t e10k_fccfg_tfce_insert(e10k_fccfg_t _regval, e10k_tfc_status_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fccfg_t e10k_fccfg_tfce_insert(e10k_fccfg_t _regval, e10k_tfc_status_t _fieldval)
{
    return((_regval & 0xffffffe7) | (0x18 & (((e10k_fccfg_t )(_fieldval)) << 3)));
}

static inline int e10k_fccfg_prtval(char *_s, size_t _size, e10k_fccfg_t _regval) __attribute__ ((always_inline));
static inline int e10k_fccfg_prtval(char *_s, size_t _size, e10k_fccfg_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfce =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tfc_status_prtval(_s + _r, _avail, e10k_fccfg_tfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transmit Flow Control Enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_gcr_t
 * Description: Implicit type of PCIe Control Register register
 * Fields:
 *   _anon0	(size 9, offset 0, init 0):	RSVD	_
 *   ctrsen	(size 1, offset 9, init 0):	RW	Completion Timeout resend enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   no_resend	(size 2, offset 11, init 0):	RW	Number of resends
 *   _anon13	(size 5, offset 13, init 0):	RSVD	_
 *   pcie_capver	(size 1, offset 18, init 0):	RW	PCIe Capability Version
 *   _anon19	(size 2, offset 19, init 0):	RSVD	_
 *   hdrlog_inv	(size 1, offset 21, init 0):	RW	hdr_log inversion
 *   _anon22	(size 10, offset 22, init 0):	RSVD	_
 */
typedef uint32_t e10k_gcr_t;
#define e10k_gcr_default 0x0
static inline uint8_t e10k_gcr_ctrsen_extract(e10k_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gcr_ctrsen_extract(e10k_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_gcr_t e10k_gcr_ctrsen_insert(e10k_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gcr_t e10k_gcr_ctrsen_insert(e10k_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_gcr_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_gcr_no_resend_extract(e10k_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gcr_no_resend_extract(e10k_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x1800) >> 11));
}

static inline e10k_gcr_t e10k_gcr_no_resend_insert(e10k_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gcr_t e10k_gcr_no_resend_insert(e10k_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffe7ff) | (0x1800 & (((e10k_gcr_t )(_fieldval)) << 11)));
}

static inline e10k_pcie_capability_version_t e10k_gcr_pcie_capver_extract(e10k_gcr_t _regval) __attribute__ ((always_inline));
static inline e10k_pcie_capability_version_t e10k_gcr_pcie_capver_extract(e10k_gcr_t _regval)
{
    return((e10k_pcie_capability_version_t )((_regval & 0x40000) >> 18));
}

static inline e10k_gcr_t e10k_gcr_pcie_capver_insert(e10k_gcr_t _regval, e10k_pcie_capability_version_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gcr_t e10k_gcr_pcie_capver_insert(e10k_gcr_t _regval, e10k_pcie_capability_version_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_gcr_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_gcr_hdrlog_inv_extract(e10k_gcr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gcr_hdrlog_inv_extract(e10k_gcr_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_gcr_t e10k_gcr_hdrlog_inv_insert(e10k_gcr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gcr_t e10k_gcr_hdrlog_inv_insert(e10k_gcr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_gcr_t )(_fieldval)) << 21)));
}

static inline int e10k_gcr_prtval(char *_s, size_t _size, e10k_gcr_t _regval) __attribute__ ((always_inline));
static inline int e10k_gcr_prtval(char *_s, size_t _size, e10k_gcr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctrsen =\t%" PRIx8 "\t(Completion Timeout resend enable)\n", e10k_gcr_ctrsen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " no_resend =\t%" PRIx8 "\t(Number of resends)\n", e10k_gcr_no_resend_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_capver =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_capability_version_prtval(_s + _r, _avail, e10k_gcr_pcie_capver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PCIe Capability Version)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hdrlog_inv =\t%" PRIx8 "\t(hdr_log inversion)\n", e10k_gcr_hdrlog_inv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_gscl_1_t
 * Description: Implicit type of PCIe Statistic Control Register #1 register
 * Fields:
 *   gio_cnt_en0	(size 1, offset 0, init 0):	RW	Enables PCIe statistic counter number 0
 *   gio_cnt_en1	(size 1, offset 1, init 0):	RW	Enables PCIe statistic counter number 1
 *   gio_cnt_en2	(size 1, offset 2, init 0):	RW	Enables PCIe statistic counter number 2
 *   gio_cnt_en3	(size 1, offset 3, init 0):	RW	Enables PCIe statistic counter number 3
 *   lbc_en0	(size 1, offset 4, init 0):	RW	LBC Enable 0
 *   lbc_en1	(size 1, offset 5, init 0):	RW	LBC Enable 1
 *   lbc_en2	(size 1, offset 6, init 0):	RW	LBC Enable 2
 *   lbc_en3	(size 1, offset 7, init 0):	RW	LBC Enable 3
 *   _anon8	(size 19, offset 8, init 0):	RSVD	_
 *   gio_cnt_tst	(size 1, offset 27, init 0):	RW	Test Bit
 *   gio_64bit	(size 1, offset 28, init 0):	RW	Enables two 64-bit counters instead of four 32-bit counters
 *   gio_cnt_rst	(size 1, offset 29, init 0):	RW	Reset indication of PCIe statistic counters
 *   gio_cnt_stp	(size 1, offset 30, init 0):	RW	Stop indication of PCIe statistic counters.
 *   gio_cnt_sta	(size 1, offset 31, init 0):	RW	Start indication of PCIe statistic counters.
 */
typedef uint32_t e10k_gscl_1_t;
#define e10k_gscl_1_default 0x0
static inline uint8_t e10k_gscl_1_gio_cnt_en0_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_en0_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_en0_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_en0_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_gscl_1_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_gscl_1_gio_cnt_en1_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_en1_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_en1_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_en1_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_gscl_1_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_gscl_1_gio_cnt_en2_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_en2_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_en2_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_en2_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_gscl_1_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_gscl_1_gio_cnt_en3_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_en3_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_en3_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_en3_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_gscl_1_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_gscl_1_lbc_en0_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_lbc_en0_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_gscl_1_t e10k_gscl_1_lbc_en0_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_lbc_en0_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_gscl_1_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_gscl_1_lbc_en1_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_lbc_en1_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_gscl_1_t e10k_gscl_1_lbc_en1_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_lbc_en1_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_gscl_1_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_gscl_1_lbc_en2_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_lbc_en2_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_gscl_1_t e10k_gscl_1_lbc_en2_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_lbc_en2_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_gscl_1_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_gscl_1_lbc_en3_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_lbc_en3_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_gscl_1_t e10k_gscl_1_lbc_en3_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_lbc_en3_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_gscl_1_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_gscl_1_gio_cnt_tst_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_tst_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_tst_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_tst_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_gscl_1_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_gscl_1_gio_64bit_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_64bit_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_64bit_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_64bit_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_gscl_1_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_gscl_1_gio_cnt_rst_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_rst_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_rst_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_rst_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_gscl_1_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_gscl_1_gio_cnt_stp_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_stp_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_stp_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_stp_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_gscl_1_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_gscl_1_gio_cnt_sta_extract(e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_sta_extract(e10k_gscl_1_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_sta_insert(e10k_gscl_1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_gio_cnt_sta_insert(e10k_gscl_1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_gscl_1_t )(_fieldval)) << 31)));
}

static inline int e10k_gscl_1_prtval(char *_s, size_t _size, e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline int e10k_gscl_1_prtval(char *_s, size_t _size, e10k_gscl_1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_en0 =\t%" PRIx8 "\t(Enables PCIe statistic counter number 0)\n", e10k_gscl_1_gio_cnt_en0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_en1 =\t%" PRIx8 "\t(Enables PCIe statistic counter number 1)\n", e10k_gscl_1_gio_cnt_en1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_en2 =\t%" PRIx8 "\t(Enables PCIe statistic counter number 2)\n", e10k_gscl_1_gio_cnt_en2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_en3 =\t%" PRIx8 "\t(Enables PCIe statistic counter number 3)\n", e10k_gscl_1_gio_cnt_en3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_en0 =\t%" PRIx8 "\t(LBC Enable 0)\n", e10k_gscl_1_lbc_en0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_en1 =\t%" PRIx8 "\t(LBC Enable 1)\n", e10k_gscl_1_lbc_en1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_en2 =\t%" PRIx8 "\t(LBC Enable 2)\n", e10k_gscl_1_lbc_en2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_en3 =\t%" PRIx8 "\t(LBC Enable 3)\n", e10k_gscl_1_lbc_en3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_tst =\t%" PRIx8 "\t(Test Bit)\n", e10k_gscl_1_gio_cnt_tst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_64bit =\t%" PRIx8 "\t(Enables two 64-bit counters instead of four 32-bit counters)\n", e10k_gscl_1_gio_64bit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_rst =\t%" PRIx8 "\t(Reset indication of PCIe statistic counters)\n", e10k_gscl_1_gio_cnt_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_stp =\t%" PRIx8 "\t(Stop indication of PCIe statistic counters.)\n", e10k_gscl_1_gio_cnt_stp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_sta =\t%" PRIx8 "\t(Start indication of PCIe statistic counters.)\n", e10k_gscl_1_gio_cnt_sta_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_gscl_2_t
 * Description: Implicit type of PCIe Statistic Control Register #2 register
 * Fields:
 *   gio_evcnt0	(size 8, offset 0, init 0):	RW	Event number that counter 0 counts
 *   gio_evcnt1	(size 8, offset 8, init 0):	RW	Event number that counter 1 counts
 *   gio_evcnt2	(size 8, offset 16, init 0):	RW	Event number that counter 2 counts
 *   gio_evcnt3	(size 8, offset 24, init 0):	RW	Event number that counter 3 counts
 */
typedef uint32_t e10k_gscl_2_t;
#define e10k_gscl_2_default 0x0
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt0_extract(e10k_gscl_2_t _regval) __attribute__ ((always_inline));
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt0_extract(e10k_gscl_2_t _regval)
{
    return((e10k_pcie_statenc_t )((_regval & 0xff) >> 0));
}

static inline e10k_gscl_2_t e10k_gscl_2_gio_evcnt0_insert(e10k_gscl_2_t _regval, e10k_pcie_statenc_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_2_t e10k_gscl_2_gio_evcnt0_insert(e10k_gscl_2_t _regval, e10k_pcie_statenc_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_gscl_2_t )(_fieldval)) << 0)));
}

static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt1_extract(e10k_gscl_2_t _regval) __attribute__ ((always_inline));
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt1_extract(e10k_gscl_2_t _regval)
{
    return((e10k_pcie_statenc_t )((_regval & 0xff00) >> 8));
}

static inline e10k_gscl_2_t e10k_gscl_2_gio_evcnt1_insert(e10k_gscl_2_t _regval, e10k_pcie_statenc_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_2_t e10k_gscl_2_gio_evcnt1_insert(e10k_gscl_2_t _regval, e10k_pcie_statenc_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e10k_gscl_2_t )(_fieldval)) << 8)));
}

static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt2_extract(e10k_gscl_2_t _regval) __attribute__ ((always_inline));
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt2_extract(e10k_gscl_2_t _regval)
{
    return((e10k_pcie_statenc_t )((_regval & 0xff0000) >> 16));
}

static inline e10k_gscl_2_t e10k_gscl_2_gio_evcnt2_insert(e10k_gscl_2_t _regval, e10k_pcie_statenc_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_2_t e10k_gscl_2_gio_evcnt2_insert(e10k_gscl_2_t _regval, e10k_pcie_statenc_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((e10k_gscl_2_t )(_fieldval)) << 16)));
}

static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt3_extract(e10k_gscl_2_t _regval) __attribute__ ((always_inline));
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt3_extract(e10k_gscl_2_t _regval)
{
    return((e10k_pcie_statenc_t )((_regval & 0xff000000) >> 24));
}

static inline e10k_gscl_2_t e10k_gscl_2_gio_evcnt3_insert(e10k_gscl_2_t _regval, e10k_pcie_statenc_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl_2_t e10k_gscl_2_gio_evcnt3_insert(e10k_gscl_2_t _regval, e10k_pcie_statenc_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((e10k_gscl_2_t )(_fieldval)) << 24)));
}

static inline int e10k_gscl_2_prtval(char *_s, size_t _size, e10k_gscl_2_t _regval) __attribute__ ((always_inline));
static inline int e10k_gscl_2_prtval(char *_s, size_t _size, e10k_gscl_2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_evcnt0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_statenc_prtval(_s + _r, _avail, e10k_gscl_2_gio_evcnt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Event number that counter 0 counts)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_evcnt1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_statenc_prtval(_s + _r, _avail, e10k_gscl_2_gio_evcnt1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Event number that counter 1 counts)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_evcnt2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_statenc_prtval(_s + _r, _avail, e10k_gscl_2_gio_evcnt2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Event number that counter 2 counts)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_evcnt3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_statenc_prtval(_s + _r, _avail, e10k_gscl_2_gio_evcnt3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Event number that counter 3 counts)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_gscl5_8_t
 * Description: Implicit type of PCIe Statistic Control Register #5...#8 register array
 * Fields:
 *   lbc_thr	(size 16, offset 0, init 0):	NOATTR	Threshold for the leaky bucket counter n.
 *   lbc_timer	(size 16, offset 16, init 0):	NOATTR	Time period between decrementing value in leaky bucket Counter n.
 */
typedef uint32_t e10k_gscl5_8_t;
#define e10k_gscl5_8_default 0x0
static inline uint16_t e10k_gscl5_8_lbc_thr_extract(e10k_gscl5_8_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_gscl5_8_lbc_thr_extract(e10k_gscl5_8_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_gscl5_8_t e10k_gscl5_8_lbc_thr_insert(e10k_gscl5_8_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl5_8_t e10k_gscl5_8_lbc_thr_insert(e10k_gscl5_8_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_gscl5_8_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_gscl5_8_lbc_timer_extract(e10k_gscl5_8_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_gscl5_8_lbc_timer_extract(e10k_gscl5_8_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_gscl5_8_t e10k_gscl5_8_lbc_timer_insert(e10k_gscl5_8_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gscl5_8_t e10k_gscl5_8_lbc_timer_insert(e10k_gscl5_8_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_gscl5_8_t )(_fieldval)) << 16)));
}

static inline int e10k_gscl5_8_prtval(char *_s, size_t _size, e10k_gscl5_8_t _regval) __attribute__ ((always_inline));
static inline int e10k_gscl5_8_prtval(char *_s, size_t _size, e10k_gscl5_8_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_thr =\t%" PRIx16 "\t(Threshold for the leaky bucket counter n.)\n", e10k_gscl5_8_lbc_thr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_timer =\t%" PRIx16 "\t(Time period between decrementing value in leaky bucket Counter n.)\n", e10k_gscl5_8_lbc_timer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_factps_t
 * Description: Implicit type of Function Active and Power State to Manageability register
 * Fields:
 *   f0_pstate	(size 2, offset 0, init 0):	RO	Func0 Power State
 *   lan0_valid	(size 1, offset 2, init 0):	RO	LAN0 Valid
 *   f0_auxen	(size 1, offset 3, init 0):	RO	Function 0 Auxiliary (AUX) Power PM Enable 
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   f1_pstate	(size 2, offset 6, init 0):	RO	Func1 Power State
 *   lan1_valid	(size 1, offset 8, init 0):	RO	LAN1 Valid
 *   f1_auxen	(size 1, offset 9, init 0):	RO	Function 1 Auxiliary (AUX) Power PM Enable 
 *   _anon10	(size 19, offset 10, init 0):	RSVD	_
 *   mngcg	(size 1, offset 29, init 0):	RO	Manageability Clock Gated
 *   lan_fsel	(size 1, offset 30, init 0):	RO	LAN Function Sel
 *   pstate_chg	(size 1, offset 31, init 0):	RO	PM State changed
 */
typedef uint32_t e10k_factps_t;
#define e10k_factps_default 0x0
static inline e10k_power_state_t e10k_factps_f0_pstate_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline e10k_power_state_t e10k_factps_f0_pstate_extract(e10k_factps_t _regval)
{
    return((e10k_power_state_t )((_regval & 0x3) >> 0));
}

static inline e10k_factps_t e10k_factps_f0_pstate_insert(e10k_factps_t _regval, e10k_power_state_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_f0_pstate_insert(e10k_factps_t _regval, e10k_power_state_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e10k_factps_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_factps_lan0_valid_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_lan0_valid_extract(e10k_factps_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_factps_t e10k_factps_lan0_valid_insert(e10k_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_lan0_valid_insert(e10k_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_factps_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_factps_f0_auxen_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_f0_auxen_extract(e10k_factps_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_factps_t e10k_factps_f0_auxen_insert(e10k_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_f0_auxen_insert(e10k_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_factps_t )(_fieldval)) << 3)));
}

static inline e10k_power_state_t e10k_factps_f1_pstate_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline e10k_power_state_t e10k_factps_f1_pstate_extract(e10k_factps_t _regval)
{
    return((e10k_power_state_t )((_regval & 0xc0) >> 6));
}

static inline e10k_factps_t e10k_factps_f1_pstate_insert(e10k_factps_t _regval, e10k_power_state_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_f1_pstate_insert(e10k_factps_t _regval, e10k_power_state_t _fieldval)
{
    return((_regval & 0xffffff3f) | (0xc0 & (((e10k_factps_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_factps_lan1_valid_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_lan1_valid_extract(e10k_factps_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_factps_t e10k_factps_lan1_valid_insert(e10k_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_lan1_valid_insert(e10k_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_factps_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_factps_f1_auxen_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_f1_auxen_extract(e10k_factps_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_factps_t e10k_factps_f1_auxen_insert(e10k_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_f1_auxen_insert(e10k_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_factps_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_factps_mngcg_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_mngcg_extract(e10k_factps_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_factps_t e10k_factps_mngcg_insert(e10k_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_mngcg_insert(e10k_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_factps_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_factps_lan_fsel_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_lan_fsel_extract(e10k_factps_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_factps_t e10k_factps_lan_fsel_insert(e10k_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_lan_fsel_insert(e10k_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_factps_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_factps_pstate_chg_extract(e10k_factps_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_pstate_chg_extract(e10k_factps_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_factps_t e10k_factps_pstate_chg_insert(e10k_factps_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_pstate_chg_insert(e10k_factps_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_factps_t )(_fieldval)) << 31)));
}

static inline int e10k_factps_prtval(char *_s, size_t _size, e10k_factps_t _regval) __attribute__ ((always_inline));
static inline int e10k_factps_prtval(char *_s, size_t _size, e10k_factps_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f0_pstate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_power_state_prtval(_s + _r, _avail, e10k_factps_f0_pstate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Func0 Power State)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan0_valid =\t%" PRIx8 "\t(LAN0 Valid)\n", e10k_factps_lan0_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f0_auxen =\t%" PRIx8 "\t(Function 0 Auxiliary (AUX) Power PM Enable )\n", e10k_factps_f0_auxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f1_pstate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_power_state_prtval(_s + _r, _avail, e10k_factps_f1_pstate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Func1 Power State)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan1_valid =\t%" PRIx8 "\t(LAN1 Valid)\n", e10k_factps_lan1_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f1_auxen =\t%" PRIx8 "\t(Function 1 Auxiliary (AUX) Power PM Enable )\n", e10k_factps_f1_auxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mngcg =\t%" PRIx8 "\t(Manageability Clock Gated)\n", e10k_factps_mngcg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan_fsel =\t%" PRIx8 "\t(LAN Function Sel)\n", e10k_factps_lan_fsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pstate_chg =\t%" PRIx8 "\t(PM State changed)\n", e10k_factps_pstate_chg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pciephyadr_t
 * Description: Implicit type of PCIe Analog Configuration Register register
 * Fields:
 *   address	(size 12, offset 0, init 0):	RW	The indirect access' address
 *   _anon12	(size 13, offset 12, init 0):	RSVD	_
 *   byte_en	(size 4, offset 25, init 0):	RW	The indirect access' byte enable
 *   read_en	(size 1, offset 29, init 0):	RW	The indirect access is read transaction
 *   write_en	(size 1, offset 30, init 0):	RW	The indirect access is write transaction
 *   done	(size 1, offset 31, init 0):	RW	Acknowledge for the indirect access to the CSR
 */
typedef uint32_t e10k_pciephyadr_t;
#define e10k_pciephyadr_default 0x0
static inline uint16_t e10k_pciephyadr_address_extract(e10k_pciephyadr_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_pciephyadr_address_extract(e10k_pciephyadr_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e10k_pciephyadr_t e10k_pciephyadr_address_insert(e10k_pciephyadr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pciephyadr_t e10k_pciephyadr_address_insert(e10k_pciephyadr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e10k_pciephyadr_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_pciephyadr_byte_en_extract(e10k_pciephyadr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pciephyadr_byte_en_extract(e10k_pciephyadr_t _regval)
{
    return((uint8_t )((_regval & 0x1e000000) >> 25));
}

static inline e10k_pciephyadr_t e10k_pciephyadr_byte_en_insert(e10k_pciephyadr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pciephyadr_t e10k_pciephyadr_byte_en_insert(e10k_pciephyadr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xe1ffffff) | (0x1e000000 & (((e10k_pciephyadr_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_pciephyadr_read_en_extract(e10k_pciephyadr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pciephyadr_read_en_extract(e10k_pciephyadr_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_pciephyadr_t e10k_pciephyadr_read_en_insert(e10k_pciephyadr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pciephyadr_t e10k_pciephyadr_read_en_insert(e10k_pciephyadr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_pciephyadr_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_pciephyadr_write_en_extract(e10k_pciephyadr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pciephyadr_write_en_extract(e10k_pciephyadr_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_pciephyadr_t e10k_pciephyadr_write_en_insert(e10k_pciephyadr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pciephyadr_t e10k_pciephyadr_write_en_insert(e10k_pciephyadr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_pciephyadr_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_pciephyadr_done_extract(e10k_pciephyadr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pciephyadr_done_extract(e10k_pciephyadr_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_pciephyadr_t e10k_pciephyadr_done_insert(e10k_pciephyadr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pciephyadr_t e10k_pciephyadr_done_insert(e10k_pciephyadr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_pciephyadr_t )(_fieldval)) << 31)));
}

static inline int e10k_pciephyadr_prtval(char *_s, size_t _size, e10k_pciephyadr_t _regval) __attribute__ ((always_inline));
static inline int e10k_pciephyadr_prtval(char *_s, size_t _size, e10k_pciephyadr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx16 "\t(The indirect access' address)\n", e10k_pciephyadr_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " byte_en =\t%" PRIx8 "\t(The indirect access' byte enable)\n", e10k_pciephyadr_byte_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_en =\t%" PRIx8 "\t(The indirect access is read transaction)\n", e10k_pciephyadr_read_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " write_en =\t%" PRIx8 "\t(The indirect access is write transaction)\n", e10k_pciephyadr_write_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Acknowledge for the indirect access to the CSR)\n", e10k_pciephyadr_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_swsm_t
 * Description: Implicit type of Software Semaphore Register register
 * Fields:
 *   smbi	(size 1, offset 0, init 0):	RWZC	Semaphore Bit
 *   swesmbi	(size 1, offset 1, init 0):	RW	Software Semaphore bi
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
typedef uint32_t e10k_swsm_t;
#define e10k_swsm_default 0x0
static inline uint8_t e10k_swsm_smbi_extract(e10k_swsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swsm_smbi_extract(e10k_swsm_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_swsm_t e10k_swsm_smbi_insert(e10k_swsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swsm_t e10k_swsm_smbi_insert(e10k_swsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_swsm_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_swsm_swesmbi_extract(e10k_swsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swsm_swesmbi_extract(e10k_swsm_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_swsm_t e10k_swsm_swesmbi_insert(e10k_swsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swsm_t e10k_swsm_swesmbi_insert(e10k_swsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_swsm_t )(_fieldval)) << 1)));
}

static inline int e10k_swsm_prtval(char *_s, size_t _size, e10k_swsm_t _regval) __attribute__ ((always_inline));
static inline int e10k_swsm_prtval(char *_s, size_t _size, e10k_swsm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smbi =\t%" PRIx8 "\t(Semaphore Bit)\n", e10k_swsm_smbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swesmbi =\t%" PRIx8 "\t(Software Semaphore bi)\n", e10k_swsm_swesmbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fwsm_t
 * Description: Implicit type of Firmware Semaphore Register register
 * Fields:
 *   fwsmbi	(size 1, offset 0, init 0):	RO	Firmware Semaphore
 *   fw_mode	(size 3, offset 1, init 0):	RO	Firmware Mode
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   eep_relind	(size 1, offset 6, init 0):	RO	EEPROM Reloaded Indication
 *   _anon7	(size 8, offset 7, init 0):	RSVD	_
 *   fw_valid	(size 1, offset 15, init 0):	RO	Firmware Valid
 *   reset_cnt	(size 3, offset 16, init 0):	RO	Reset Counter
 *   exterr_ind	(size 6, offset 19, init 0):	RO	External Error Indication
 *   pcie_cfgerr	(size 1, offset 25, init 0):	RO	PCIe Configuration Error Indication
 *   sdes0_err	(size 1, offset 26, init 0):	RO	PHY/SERDES0 Configuration Error Indication
 *   sdes1_err	(size 1, offset 27, init 0):	RO	PHY/SERDES1 Configuration Error Indication
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t e10k_fwsm_t;
#define e10k_fwsm_default 0x0
static inline uint8_t e10k_fwsm_fwsmbi_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_fwsmbi_extract(e10k_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_fwsm_t e10k_fwsm_fwsmbi_insert(e10k_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_fwsmbi_insert(e10k_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_fwsm_t )(_fieldval)) << 0)));
}

static inline e10k_fw_mode_t e10k_fwsm_fw_mode_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline e10k_fw_mode_t e10k_fwsm_fw_mode_extract(e10k_fwsm_t _regval)
{
    return((e10k_fw_mode_t )((_regval & 0xe) >> 1));
}

static inline e10k_fwsm_t e10k_fwsm_fw_mode_insert(e10k_fwsm_t _regval, e10k_fw_mode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_fw_mode_insert(e10k_fwsm_t _regval, e10k_fw_mode_t _fieldval)
{
    return((_regval & 0xfffffff1) | (0xe & (((e10k_fwsm_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_fwsm_eep_relind_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_eep_relind_extract(e10k_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_fwsm_t e10k_fwsm_eep_relind_insert(e10k_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_eep_relind_insert(e10k_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_fwsm_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_fwsm_fw_valid_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_fw_valid_extract(e10k_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_fwsm_t e10k_fwsm_fw_valid_insert(e10k_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_fw_valid_insert(e10k_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_fwsm_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_fwsm_reset_cnt_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_reset_cnt_extract(e10k_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x70000) >> 16));
}

static inline e10k_fwsm_t e10k_fwsm_reset_cnt_insert(e10k_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_reset_cnt_insert(e10k_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((e10k_fwsm_t )(_fieldval)) << 16)));
}

static inline e10k_ext_err_ind_t e10k_fwsm_exterr_ind_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline e10k_ext_err_ind_t e10k_fwsm_exterr_ind_extract(e10k_fwsm_t _regval)
{
    return((e10k_ext_err_ind_t )((_regval & 0x1f80000) >> 19));
}

static inline e10k_fwsm_t e10k_fwsm_exterr_ind_insert(e10k_fwsm_t _regval, e10k_ext_err_ind_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_exterr_ind_insert(e10k_fwsm_t _regval, e10k_ext_err_ind_t _fieldval)
{
    return((_regval & 0xfe07ffff) | (0x1f80000 & (((e10k_fwsm_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_fwsm_pcie_cfgerr_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_pcie_cfgerr_extract(e10k_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_fwsm_t e10k_fwsm_pcie_cfgerr_insert(e10k_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_pcie_cfgerr_insert(e10k_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_fwsm_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_fwsm_sdes0_err_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_sdes0_err_extract(e10k_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_fwsm_t e10k_fwsm_sdes0_err_insert(e10k_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_sdes0_err_insert(e10k_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_fwsm_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_fwsm_sdes1_err_extract(e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_sdes1_err_extract(e10k_fwsm_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_fwsm_t e10k_fwsm_sdes1_err_insert(e10k_fwsm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_sdes1_err_insert(e10k_fwsm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_fwsm_t )(_fieldval)) << 27)));
}

static inline int e10k_fwsm_prtval(char *_s, size_t _size, e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline int e10k_fwsm_prtval(char *_s, size_t _size, e10k_fwsm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fwsmbi =\t%" PRIx8 "\t(Firmware Semaphore)\n", e10k_fwsm_fwsmbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fw_mode_prtval(_s + _r, _avail, e10k_fwsm_fw_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Firmware Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eep_relind =\t%" PRIx8 "\t(EEPROM Reloaded Indication)\n", e10k_fwsm_eep_relind_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_valid =\t%" PRIx8 "\t(Firmware Valid)\n", e10k_fwsm_fw_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset_cnt =\t%" PRIx8 "\t(Reset Counter)\n", e10k_fwsm_reset_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " exterr_ind =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ext_err_ind_prtval(_s + _r, _avail, e10k_fwsm_exterr_ind_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(External Error Indication)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_cfgerr =\t%" PRIx8 "\t(PCIe Configuration Error Indication)\n", e10k_fwsm_pcie_cfgerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdes0_err =\t%" PRIx8 "\t(PHY/SERDES0 Configuration Error Indication)\n", e10k_fwsm_sdes0_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdes1_err =\t%" PRIx8 "\t(PHY/SERDES1 Configuration Error Indication)\n", e10k_fwsm_sdes1_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_swfw_sync_t
 * Description: Implicit type of Software Firmware Synchronization register
 * Fields:
 *   sw_eepsm	(size 1, offset 0, init 0):	RW	EEPROM access is owned by software
 *   sw_physm0	(size 1, offset 1, init 0):	RW	PHY 0 access is owned by software
 *   sw_physm1	(size 1, offset 2, init 0):	RW	PHY 1 access is owned by software
 *   sw_maccsrsm	(size 1, offset 3, init 0):	RW	Software owns access to shared CSRs
 *   sw_flsm	(size 1, offset 4, init 0):	RW	Software Flash semaphore
 *   fw_eepsm	(size 1, offset 5, init 0):	RO	EEPROM access is owned by firmware
 *   fw_physm0	(size 1, offset 6, init 0):	RO	PHY 0 access is owned by firmware
 *   fw_physm1	(size 1, offset 7, init 0):	RO	PHY 1 access is owned by firmware
 *   fw_maccsrsm	(size 1, offset 8, init 0):	RO	Firmware owns access to shared CSRs
 *   fw_flsm	(size 1, offset 9, init 0):	RO	Firmware Flash semaphore
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
typedef uint32_t e10k_swfw_sync_t;
#define e10k_swfw_sync_default 0x0
static inline uint8_t e10k_swfw_sync_sw_eepsm_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_eepsm_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_sw_eepsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_sw_eepsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_swfw_sync_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_swfw_sync_sw_physm0_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_physm0_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_sw_physm0_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_sw_physm0_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_swfw_sync_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_swfw_sync_sw_physm1_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_physm1_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_sw_physm1_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_sw_physm1_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_swfw_sync_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_swfw_sync_sw_maccsrsm_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_maccsrsm_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_sw_maccsrsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_sw_maccsrsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_swfw_sync_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_swfw_sync_sw_flsm_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_flsm_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_sw_flsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_sw_flsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_swfw_sync_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_swfw_sync_fw_eepsm_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_eepsm_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_fw_eepsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_fw_eepsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_swfw_sync_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_swfw_sync_fw_physm0_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_physm0_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_fw_physm0_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_fw_physm0_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_swfw_sync_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_swfw_sync_fw_physm1_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_physm1_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_fw_physm1_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_fw_physm1_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_swfw_sync_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_swfw_sync_fw_maccsrsm_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_maccsrsm_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_fw_maccsrsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_fw_maccsrsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_swfw_sync_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_swfw_sync_fw_flsm_extract(e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_flsm_extract(e10k_swfw_sync_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_fw_flsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_fw_flsm_insert(e10k_swfw_sync_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_swfw_sync_t )(_fieldval)) << 9)));
}

static inline int e10k_swfw_sync_prtval(char *_s, size_t _size, e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline int e10k_swfw_sync_prtval(char *_s, size_t _size, e10k_swfw_sync_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_eepsm =\t%" PRIx8 "\t(EEPROM access is owned by software)\n", e10k_swfw_sync_sw_eepsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_physm0 =\t%" PRIx8 "\t(PHY 0 access is owned by software)\n", e10k_swfw_sync_sw_physm0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_physm1 =\t%" PRIx8 "\t(PHY 1 access is owned by software)\n", e10k_swfw_sync_sw_physm1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_maccsrsm =\t%" PRIx8 "\t(Software owns access to shared CSRs)\n", e10k_swfw_sync_sw_maccsrsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_flsm =\t%" PRIx8 "\t(Software Flash semaphore)\n", e10k_swfw_sync_sw_flsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_eepsm =\t%" PRIx8 "\t(EEPROM access is owned by firmware)\n", e10k_swfw_sync_fw_eepsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_physm0 =\t%" PRIx8 "\t(PHY 0 access is owned by firmware)\n", e10k_swfw_sync_fw_physm0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_physm1 =\t%" PRIx8 "\t(PHY 1 access is owned by firmware)\n", e10k_swfw_sync_fw_physm1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_maccsrsm =\t%" PRIx8 "\t(Firmware owns access to shared CSRs)\n", e10k_swfw_sync_fw_maccsrsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_flsm =\t%" PRIx8 "\t(Firmware Flash semaphore)\n", e10k_swfw_sync_fw_flsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_gcr_ext_t
 * Description: Implicit type of PCIe Control Extended Register register
 * Fields:
 *   vtmode	(size 2, offset 0, init 0):	RW	VT mode of operation
 *   _anon2	(size 2, offset 2, init 0):	RSVD	_
 *   apbacd	(size 1, offset 4, init 0):	RW	Auto PBA Clear Disable
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
typedef uint32_t e10k_gcr_ext_t;
#define e10k_gcr_ext_default 0x0
static inline e10k_vt_mode_t e10k_gcr_ext_vtmode_extract(e10k_gcr_ext_t _regval) __attribute__ ((always_inline));
static inline e10k_vt_mode_t e10k_gcr_ext_vtmode_extract(e10k_gcr_ext_t _regval)
{
    return((e10k_vt_mode_t )((_regval & 0x3) >> 0));
}

static inline e10k_gcr_ext_t e10k_gcr_ext_vtmode_insert(e10k_gcr_ext_t _regval, e10k_vt_mode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gcr_ext_t e10k_gcr_ext_vtmode_insert(e10k_gcr_ext_t _regval, e10k_vt_mode_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e10k_gcr_ext_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_gcr_ext_apbacd_extract(e10k_gcr_ext_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gcr_ext_apbacd_extract(e10k_gcr_ext_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_gcr_ext_t e10k_gcr_ext_apbacd_insert(e10k_gcr_ext_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gcr_ext_t e10k_gcr_ext_apbacd_insert(e10k_gcr_ext_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_gcr_ext_t )(_fieldval)) << 4)));
}

static inline int e10k_gcr_ext_prtval(char *_s, size_t _size, e10k_gcr_ext_t _regval) __attribute__ ((always_inline));
static inline int e10k_gcr_ext_prtval(char *_s, size_t _size, e10k_gcr_ext_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vtmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vt_mode_prtval(_s + _r, _avail, e10k_gcr_ext_vtmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VT mode of operation)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apbacd =\t%" PRIx8 "\t(Auto PBA Clear Disable)\n", e10k_gcr_ext_apbacd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mrevid_t
 * Description: Implicit type of Mirrored Revision ID register
 * Fields:
 *   eeprom_rev	(size 8, offset 0, init 0):	RO	Mirroring of rev ID loaded from EEPROM
 *   default_rev	(size 8, offset 8, init 0):	RO	Mirroring of default rev ID, before EEPROM load
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_mrevid_t;
#define e10k_mrevid_default 0x0
static inline uint8_t e10k_mrevid_eeprom_rev_extract(e10k_mrevid_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mrevid_eeprom_rev_extract(e10k_mrevid_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e10k_mrevid_t e10k_mrevid_eeprom_rev_insert(e10k_mrevid_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrevid_t e10k_mrevid_eeprom_rev_insert(e10k_mrevid_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_mrevid_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_mrevid_default_rev_extract(e10k_mrevid_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mrevid_default_rev_extract(e10k_mrevid_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e10k_mrevid_t e10k_mrevid_default_rev_insert(e10k_mrevid_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrevid_t e10k_mrevid_default_rev_insert(e10k_mrevid_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e10k_mrevid_t )(_fieldval)) << 8)));
}

static inline int e10k_mrevid_prtval(char *_s, size_t _size, e10k_mrevid_t _regval) __attribute__ ((always_inline));
static inline int e10k_mrevid_prtval(char *_s, size_t _size, e10k_mrevid_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eeprom_rev =\t%" PRIx8 "\t(Mirroring of rev ID loaded from EEPROM)\n", e10k_mrevid_eeprom_rev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " default_rev =\t%" PRIx8 "\t(Mirroring of default rev ID, before EEPROM load)\n", e10k_mrevid_default_rev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_picause_t
 * Description: Implicit type of PCIe Interrupt Cause register
 * Fields:
 *   ca	(size 1, offset 0, init 0):	RWC	PCI completion abort exception
 *   ua	(size 1, offset 1, init 0):	RWC	Unsupported I/O address exception
 *   be	(size 1, offset 2, init 0):	RWC	Wrong byte-enable exception in the FUNC unit
 *   to	(size 1, offset 3, init 0):	RWC	PCI timeout exception in the FUNC unit
 *   bmef	(size 1, offset 4, init 0):	RWC	Bus master enable of the PF or one of the VFs is de-asserted
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
typedef uint32_t e10k_picause_t;
#define e10k_picause_default 0x0
static inline uint8_t e10k_picause_ca_extract(e10k_picause_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_ca_extract(e10k_picause_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_picause_t e10k_picause_ca_insert(e10k_picause_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_picause_t e10k_picause_ca_insert(e10k_picause_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_picause_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_picause_ua_extract(e10k_picause_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_ua_extract(e10k_picause_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_picause_t e10k_picause_ua_insert(e10k_picause_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_picause_t e10k_picause_ua_insert(e10k_picause_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_picause_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_picause_be_extract(e10k_picause_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_be_extract(e10k_picause_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_picause_t e10k_picause_be_insert(e10k_picause_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_picause_t e10k_picause_be_insert(e10k_picause_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_picause_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_picause_to_extract(e10k_picause_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_to_extract(e10k_picause_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_picause_t e10k_picause_to_insert(e10k_picause_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_picause_t e10k_picause_to_insert(e10k_picause_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_picause_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_picause_bmef_extract(e10k_picause_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_bmef_extract(e10k_picause_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_picause_t e10k_picause_bmef_insert(e10k_picause_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_picause_t e10k_picause_bmef_insert(e10k_picause_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_picause_t )(_fieldval)) << 4)));
}

static inline int e10k_picause_prtval(char *_s, size_t _size, e10k_picause_t _regval) __attribute__ ((always_inline));
static inline int e10k_picause_prtval(char *_s, size_t _size, e10k_picause_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ca =\t%" PRIx8 "\t(PCI completion abort exception)\n", e10k_picause_ca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ua =\t%" PRIx8 "\t(Unsupported I/O address exception)\n", e10k_picause_ua_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Wrong byte-enable exception in the FUNC unit)\n", e10k_picause_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " to =\t%" PRIx8 "\t(PCI timeout exception in the FUNC unit)\n", e10k_picause_to_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bmef =\t%" PRIx8 "\t(Bus master enable of the PF or one of the VFs is de-asserted)\n", e10k_picause_bmef_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_piena_t
 * Description: Implicit type of PCIe Interrupt Enable register
 * Fields:
 *   ca	(size 1, offset 0, init 0):	RW	Enable PCI completion abort interrupt
 *   ua	(size 1, offset 1, init 0):	RW	Enable unsupported I/O address interrupt
 *   be	(size 1, offset 2, init 0):	RW	Enable wrong byte-enable interrupt
 *   to	(size 1, offset 3, init 0):	RW	Enable PCI timeout interrupt
 *   bmef	(size 1, offset 4, init 0):	RW	Enable bus master enable interrupt
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
typedef uint32_t e10k_piena_t;
#define e10k_piena_default 0x0
static inline uint8_t e10k_piena_ca_extract(e10k_piena_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_ca_extract(e10k_piena_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_piena_t e10k_piena_ca_insert(e10k_piena_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_piena_t e10k_piena_ca_insert(e10k_piena_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_piena_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_piena_ua_extract(e10k_piena_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_ua_extract(e10k_piena_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_piena_t e10k_piena_ua_insert(e10k_piena_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_piena_t e10k_piena_ua_insert(e10k_piena_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_piena_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_piena_be_extract(e10k_piena_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_be_extract(e10k_piena_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_piena_t e10k_piena_be_insert(e10k_piena_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_piena_t e10k_piena_be_insert(e10k_piena_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_piena_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_piena_to_extract(e10k_piena_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_to_extract(e10k_piena_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_piena_t e10k_piena_to_insert(e10k_piena_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_piena_t e10k_piena_to_insert(e10k_piena_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_piena_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_piena_bmef_extract(e10k_piena_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_bmef_extract(e10k_piena_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_piena_t e10k_piena_bmef_insert(e10k_piena_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_piena_t e10k_piena_bmef_insert(e10k_piena_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_piena_t )(_fieldval)) << 4)));
}

static inline int e10k_piena_prtval(char *_s, size_t _size, e10k_piena_t _regval) __attribute__ ((always_inline));
static inline int e10k_piena_prtval(char *_s, size_t _size, e10k_piena_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ca =\t%" PRIx8 "\t(Enable PCI completion abort interrupt)\n", e10k_piena_ca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ua =\t%" PRIx8 "\t(Enable unsupported I/O address interrupt)\n", e10k_piena_ua_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Enable wrong byte-enable interrupt)\n", e10k_piena_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " to =\t%" PRIx8 "\t(Enable PCI timeout interrupt)\n", e10k_piena_to_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bmef =\t%" PRIx8 "\t(Enable bus master enable interrupt)\n", e10k_piena_bmef_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eicr_t
 * Description: Implicit type of Extended Interrupt Cause Register register
 * Fields:
 *   rtxq	(size 16, offset 0, init 0):	RWC	Receive/Transmit Queue Interrupts
 *   flow_dir	(size 1, offset 16, init 0):	RWC	Flow Director Exception
 *   rx_miss	(size 1, offset 17, init 0):	RWC	Rx Miss
 *   pci_ex	(size 1, offset 18, init 0):	RWC	PCI Timeout Exception
 *   mailbox	(size 1, offset 19, init 0):	RWC	VF to PF MailBox Interrupt
 *   lsc	(size 1, offset 20, init 0):	RWC	Link Status Change
 *   linksec	(size 1, offset 21, init 0):	RWC	LinkSec
 *   mng	(size 1, offset 22, init 0):	RWC	Manageability Event Detected
 *   _anon23	(size 1, offset 23, init 0):	RSVD	_
 *   gpi_spd0	(size 1, offset 24, init 0):	RWC	General Purpose Interrupt on SDP0
 *   gpi_spd1	(size 1, offset 25, init 0):	RWC	General Purpose Interrupt on SDP1
 *   gpi_spd2	(size 1, offset 26, init 0):	RWC	General Purpose Interrupt on SDP2
 *   gpi_spd3	(size 1, offset 27, init 0):	RWC	General Purpose Interrupt on SDP3
 *   ecc	(size 1, offset 28, init 0):	RWC	Unrecoverable ECC Error
 *   _anon29	(size 1, offset 29, init 0):	RSVD	_
 *   tcp_timer	(size 1, offset 30, init 0):	RWC	TCP Timer Expired
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_eicr_t;
#define e10k_eicr_default 0x0
static inline uint16_t e10k_eicr_rtxq_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_eicr_rtxq_extract(e10k_eicr_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_eicr_t e10k_eicr_rtxq_insert(e10k_eicr_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_rtxq_insert(e10k_eicr_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_eicr_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_eicr_flow_dir_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_flow_dir_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_eicr_t e10k_eicr_flow_dir_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_flow_dir_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_eicr_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_eicr_rx_miss_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_rx_miss_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_eicr_t e10k_eicr_rx_miss_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_rx_miss_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_eicr_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_eicr_pci_ex_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_pci_ex_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_eicr_t e10k_eicr_pci_ex_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_pci_ex_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_eicr_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_eicr_mailbox_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_mailbox_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_eicr_t e10k_eicr_mailbox_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_mailbox_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_eicr_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_eicr_lsc_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_lsc_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_eicr_t e10k_eicr_lsc_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_lsc_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_eicr_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_eicr_linksec_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_linksec_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_eicr_t e10k_eicr_linksec_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_linksec_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_eicr_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_eicr_mng_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_mng_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_eicr_t e10k_eicr_mng_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_mng_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_eicr_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_eicr_gpi_spd0_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_gpi_spd0_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_eicr_t e10k_eicr_gpi_spd0_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_gpi_spd0_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_eicr_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_eicr_gpi_spd1_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_gpi_spd1_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_eicr_t e10k_eicr_gpi_spd1_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_gpi_spd1_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_eicr_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_eicr_gpi_spd2_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_gpi_spd2_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_eicr_t e10k_eicr_gpi_spd2_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_gpi_spd2_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_eicr_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_eicr_gpi_spd3_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_gpi_spd3_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_eicr_t e10k_eicr_gpi_spd3_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_gpi_spd3_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_eicr_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_eicr_ecc_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_ecc_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_eicr_t e10k_eicr_ecc_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_ecc_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_eicr_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_eicr_tcp_timer_extract(e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_tcp_timer_extract(e10k_eicr_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_eicr_t e10k_eicr_tcp_timer_insert(e10k_eicr_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_tcp_timer_insert(e10k_eicr_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_eicr_t )(_fieldval)) << 30)));
}

static inline int e10k_eicr_prtval(char *_s, size_t _size, e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline int e10k_eicr_prtval(char *_s, size_t _size, e10k_eicr_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtxq =\t%" PRIx16 "\t(Receive/Transmit Queue Interrupts)\n", e10k_eicr_rtxq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flow_dir =\t%" PRIx8 "\t(Flow Director Exception)\n", e10k_eicr_flow_dir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_miss =\t%" PRIx8 "\t(Rx Miss)\n", e10k_eicr_rx_miss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_ex =\t%" PRIx8 "\t(PCI Timeout Exception)\n", e10k_eicr_pci_ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mailbox =\t%" PRIx8 "\t(VF to PF MailBox Interrupt)\n", e10k_eicr_mailbox_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsc =\t%" PRIx8 "\t(Link Status Change)\n", e10k_eicr_lsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " linksec =\t%" PRIx8 "\t(LinkSec)\n", e10k_eicr_linksec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mng =\t%" PRIx8 "\t(Manageability Event Detected)\n", e10k_eicr_mng_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_spd0 =\t%" PRIx8 "\t(General Purpose Interrupt on SDP0)\n", e10k_eicr_gpi_spd0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_spd1 =\t%" PRIx8 "\t(General Purpose Interrupt on SDP1)\n", e10k_eicr_gpi_spd1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_spd2 =\t%" PRIx8 "\t(General Purpose Interrupt on SDP2)\n", e10k_eicr_gpi_spd2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_spd3 =\t%" PRIx8 "\t(General Purpose Interrupt on SDP3)\n", e10k_eicr_gpi_spd3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ecc =\t%" PRIx8 "\t(Unrecoverable ECC Error)\n", e10k_eicr_ecc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_timer =\t%" PRIx8 "\t(TCP Timer Expired)\n", e10k_eicr_tcp_timer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eics_t
 * Description: Implicit type of Extended Interrupt Cause Set Register register
 * Fields:
 *   cause	(size 31, offset 0, init 0):	WO	Interrupt Cause Set
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_eics_t;
#define e10k_eics_default 0x0
static inline uint32_t e10k_eics_cause_extract(e10k_eics_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eics_cause_extract(e10k_eics_t _regval)
{
    return((uint32_t )((_regval & 0x7fffffff) >> 0));
}

static inline e10k_eics_t e10k_eics_cause_insert(e10k_eics_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eics_t e10k_eics_cause_insert(e10k_eics_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x80000000) | (0x7fffffff & (((e10k_eics_t )(_fieldval)) << 0)));
}

static inline int e10k_eics_prtval(char *_s, size_t _size, e10k_eics_t _regval) __attribute__ ((always_inline));
static inline int e10k_eics_prtval(char *_s, size_t _size, e10k_eics_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Cause Set)\n", e10k_eics_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eims_t
 * Description: Implicit type of Extended Interrupt Mask Set/Read Register register
 * Fields:
 *   cause	(size 31, offset 0, init 0):	RWS	Interrupt Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_eims_t;
#define e10k_eims_default 0x0
static inline uint32_t e10k_eims_cause_extract(e10k_eims_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eims_cause_extract(e10k_eims_t _regval)
{
    return((uint32_t )((_regval & 0x7fffffff) >> 0));
}

static inline e10k_eims_t e10k_eims_cause_insert(e10k_eims_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eims_t e10k_eims_cause_insert(e10k_eims_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x80000000) | (0x7fffffff & (((e10k_eims_t )(_fieldval)) << 0)));
}

static inline int e10k_eims_prtval(char *_s, size_t _size, e10k_eims_t _regval) __attribute__ ((always_inline));
static inline int e10k_eims_prtval(char *_s, size_t _size, e10k_eims_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Enable)\n", e10k_eims_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eimc_t
 * Description: Implicit type of Extended Interrupt Mask Clear Register register
 * Fields:
 *   cause	(size 31, offset 0, init 0):	WO	Interrupt Mask
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_eimc_t;
#define e10k_eimc_default 0x0
static inline uint32_t e10k_eimc_cause_extract(e10k_eimc_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eimc_cause_extract(e10k_eimc_t _regval)
{
    return((uint32_t )((_regval & 0x7fffffff) >> 0));
}

static inline e10k_eimc_t e10k_eimc_cause_insert(e10k_eimc_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eimc_t e10k_eimc_cause_insert(e10k_eimc_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x80000000) | (0x7fffffff & (((e10k_eimc_t )(_fieldval)) << 0)));
}

static inline int e10k_eimc_prtval(char *_s, size_t _size, e10k_eimc_t _regval) __attribute__ ((always_inline));
static inline int e10k_eimc_prtval(char *_s, size_t _size, e10k_eimc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Mask)\n", e10k_eimc_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eiac_t
 * Description: Implicit type of Extended Interrupt Auto Clear Register register
 * Fields:
 *   rtxq	(size 16, offset 0, init 0):	RW	RTxQ Auto Clear
 *   _anon16	(size 14, offset 16, init 0):	RSVD	_
 *   tcp_timer	(size 1, offset 30, init 0):	RW	TCP Timer Auto Clear
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_eiac_t;
#define e10k_eiac_default 0x0
static inline uint16_t e10k_eiac_rtxq_extract(e10k_eiac_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_eiac_rtxq_extract(e10k_eiac_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_eiac_t e10k_eiac_rtxq_insert(e10k_eiac_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eiac_t e10k_eiac_rtxq_insert(e10k_eiac_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_eiac_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_eiac_tcp_timer_extract(e10k_eiac_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eiac_tcp_timer_extract(e10k_eiac_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_eiac_t e10k_eiac_tcp_timer_insert(e10k_eiac_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eiac_t e10k_eiac_tcp_timer_insert(e10k_eiac_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_eiac_t )(_fieldval)) << 30)));
}

static inline int e10k_eiac_prtval(char *_s, size_t _size, e10k_eiac_t _regval) __attribute__ ((always_inline));
static inline int e10k_eiac_prtval(char *_s, size_t _size, e10k_eiac_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtxq =\t%" PRIx16 "\t(RTxQ Auto Clear)\n", e10k_eiac_rtxq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_timer =\t%" PRIx8 "\t(TCP Timer Auto Clear)\n", e10k_eiac_tcp_timer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eiam_t
 * Description: Implicit type of Extended Interrupt Auto Mask Enable Register register
 * Fields:
 *   cause	(size 31, offset 0, init 0):	RW	Auto Mask
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_eiam_t;
#define e10k_eiam_default 0x0
static inline uint32_t e10k_eiam_cause_extract(e10k_eiam_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eiam_cause_extract(e10k_eiam_t _regval)
{
    return((uint32_t )((_regval & 0x7fffffff) >> 0));
}

static inline e10k_eiam_t e10k_eiam_cause_insert(e10k_eiam_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eiam_t e10k_eiam_cause_insert(e10k_eiam_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x80000000) | (0x7fffffff & (((e10k_eiam_t )(_fieldval)) << 0)));
}

static inline int e10k_eiam_prtval(char *_s, size_t _size, e10k_eiam_t _regval) __attribute__ ((always_inline));
static inline int e10k_eiam_prtval(char *_s, size_t _size, e10k_eiam_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Auto Mask)\n", e10k_eiam_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eicsn_t
 * Description: Implicit type of Extended Interrupt Cause Set Registers register array
 * Fields:
 *   cause	(size 32, offset 0, init 0):	NOATTR	Interrupt Cause Set
 */
typedef uint32_t e10k_eicsn_t;
#define e10k_eicsn_default 0x0
static inline uint32_t e10k_eicsn_cause_extract(e10k_eicsn_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eicsn_cause_extract(e10k_eicsn_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_eicsn_t e10k_eicsn_cause_insert(e10k_eicsn_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eicsn_t e10k_eicsn_cause_insert(e10k_eicsn_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_eicsn_t )(_fieldval)) << 0)));
}

static inline int e10k_eicsn_prtval(char *_s, size_t _size, e10k_eicsn_t _regval) __attribute__ ((always_inline));
static inline int e10k_eicsn_prtval(char *_s, size_t _size, e10k_eicsn_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Cause Set)\n", e10k_eicsn_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eimsn_t
 * Description: Implicit type of Extended Interrupt Mask Set/Read Registers register array
 * Fields:
 *   cause	(size 32, offset 0, init 0):	RWS	Interrupt Enable
 */
typedef uint32_t e10k_eimsn_t;
#define e10k_eimsn_default 0x0
static inline uint32_t e10k_eimsn_cause_extract(e10k_eimsn_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eimsn_cause_extract(e10k_eimsn_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_eimsn_t e10k_eimsn_cause_insert(e10k_eimsn_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eimsn_t e10k_eimsn_cause_insert(e10k_eimsn_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_eimsn_t )(_fieldval)) << 0)));
}

static inline int e10k_eimsn_prtval(char *_s, size_t _size, e10k_eimsn_t _regval) __attribute__ ((always_inline));
static inline int e10k_eimsn_prtval(char *_s, size_t _size, e10k_eimsn_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Enable)\n", e10k_eimsn_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eimcn_t
 * Description: Implicit type of Extended Interrupt Mask Clear Registers register array
 * Fields:
 *   cause	(size 32, offset 0, init 0):	NOATTR	Interrupt Mask
 */
typedef uint32_t e10k_eimcn_t;
#define e10k_eimcn_default 0x0
static inline uint32_t e10k_eimcn_cause_extract(e10k_eimcn_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eimcn_cause_extract(e10k_eimcn_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_eimcn_t e10k_eimcn_cause_insert(e10k_eimcn_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eimcn_t e10k_eimcn_cause_insert(e10k_eimcn_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_eimcn_t )(_fieldval)) << 0)));
}

static inline int e10k_eimcn_prtval(char *_s, size_t _size, e10k_eimcn_t _regval) __attribute__ ((always_inline));
static inline int e10k_eimcn_prtval(char *_s, size_t _size, e10k_eimcn_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Mask)\n", e10k_eimcn_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eiamn_t
 * Description: Implicit type of Extended Interrupt Auto Mask Enable registers register array
 * Fields:
 *   cause	(size 32, offset 0, init 0):	NOATTR	Auto Mask
 */
typedef uint32_t e10k_eiamn_t;
#define e10k_eiamn_default 0x0
static inline uint32_t e10k_eiamn_cause_extract(e10k_eiamn_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eiamn_cause_extract(e10k_eiamn_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_eiamn_t e10k_eiamn_cause_insert(e10k_eiamn_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eiamn_t e10k_eiamn_cause_insert(e10k_eiamn_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_eiamn_t )(_fieldval)) << 0)));
}

static inline int e10k_eiamn_prtval(char *_s, size_t _size, e10k_eiamn_t _regval) __attribute__ ((always_inline));
static inline int e10k_eiamn_prtval(char *_s, size_t _size, e10k_eiamn_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Auto Mask)\n", e10k_eiamn_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eitrsel_t
 * Description: Implicit type of MSIX to EITR Select register
 * Fields:
 *   vfselect	(size 32, offset 0, init 0):	RW	VFSelect
 */
typedef uint32_t e10k_eitrsel_t;
#define e10k_eitrsel_default 0x0
static inline uint32_t e10k_eitrsel_vfselect_extract(e10k_eitrsel_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_eitrsel_vfselect_extract(e10k_eitrsel_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_eitrsel_t e10k_eitrsel_vfselect_insert(e10k_eitrsel_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eitrsel_t e10k_eitrsel_vfselect_insert(e10k_eitrsel_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_eitrsel_t )(_fieldval)) << 0)));
}

static inline int e10k_eitrsel_prtval(char *_s, size_t _size, e10k_eitrsel_t _regval) __attribute__ ((always_inline));
static inline int e10k_eitrsel_prtval(char *_s, size_t _size, e10k_eitrsel_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vfselect =\t%" PRIx32 "\t(VFSelect)\n", e10k_eitrsel_vfselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_eitrn_t
 * Description: Extended Interrupt Throttle Register Type
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   itr_int	(size 9, offset 3, init 0):	NOATTR	Minimum inter-interrupt interval
 *   _anon12	(size 3, offset 12, init 0):	RSVD	_
 *   lli_mod	(size 1, offset 15, init 0):	NOATTR	LLI Moderation
 *   lli_credit	(size 5, offset 16, init 0):	NOATTR	LLI Credit
 *   itr_count	(size 7, offset 21, init 0):	NOATTR	ITR Counter
 *   _anon28	(size 3, offset 28, init 0):	RSVD	_
 *   cnt_wdis	(size 1, offset 31, init 0):	NOATTR	CNT_WDIS
 */
typedef uint32_t e10k_eitrn_t;
#define e10k_eitrn_default 0x0
static inline uint16_t e10k_eitrn_itr_int_extract(e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_eitrn_itr_int_extract(e10k_eitrn_t _regval)
{
    return((uint16_t )((_regval & 0xff8) >> 3));
}

static inline e10k_eitrn_t e10k_eitrn_itr_int_insert(e10k_eitrn_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitrn_itr_int_insert(e10k_eitrn_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff007) | (0xff8 & (((e10k_eitrn_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_eitrn_lli_mod_extract(e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eitrn_lli_mod_extract(e10k_eitrn_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_eitrn_t e10k_eitrn_lli_mod_insert(e10k_eitrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitrn_lli_mod_insert(e10k_eitrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_eitrn_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_eitrn_lli_credit_extract(e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eitrn_lli_credit_extract(e10k_eitrn_t _regval)
{
    return((uint8_t )((_regval & 0x1f0000) >> 16));
}

static inline e10k_eitrn_t e10k_eitrn_lli_credit_insert(e10k_eitrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitrn_lli_credit_insert(e10k_eitrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe0ffff) | (0x1f0000 & (((e10k_eitrn_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_eitrn_itr_count_extract(e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eitrn_itr_count_extract(e10k_eitrn_t _regval)
{
    return((uint8_t )((_regval & 0xfe00000) >> 21));
}

static inline e10k_eitrn_t e10k_eitrn_itr_count_insert(e10k_eitrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitrn_itr_count_insert(e10k_eitrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf01fffff) | (0xfe00000 & (((e10k_eitrn_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_eitrn_cnt_wdis_extract(e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_eitrn_cnt_wdis_extract(e10k_eitrn_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_eitrn_t e10k_eitrn_cnt_wdis_insert(e10k_eitrn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitrn_cnt_wdis_insert(e10k_eitrn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_eitrn_t )(_fieldval)) << 31)));
}

static inline int e10k_eitrn_prtval(char *_s, size_t _size, e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline int e10k_eitrn_prtval(char *_s, size_t _size, e10k_eitrn_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itr_int =\t%" PRIx16 "\t(Minimum inter-interrupt interval)\n", e10k_eitrn_itr_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli_mod =\t%" PRIx8 "\t(LLI Moderation)\n", e10k_eitrn_lli_mod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli_credit =\t%" PRIx8 "\t(LLI Credit)\n", e10k_eitrn_lli_credit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itr_count =\t%" PRIx8 "\t(ITR Counter)\n", e10k_eitrn_itr_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cnt_wdis =\t%" PRIx8 "\t(CNT_WDIS)\n", e10k_eitrn_cnt_wdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_l34timir_t
 * Description: Implicit type of L3 L4 Tuples Immediate Interrupt Rx register array
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   size_bp	(size 1, offset 12, init 0):	NOATTR	Size Bypass
 *   _anon13	(size 6, offset 13, init 0):	MBZ	_
 *   _anon19	(size 1, offset 19, init 1):	MB1	_
 *   lli	(size 1, offset 20, init 0):	NOATTR	Low Latency Interrupt
 *   rx_queue	(size 7, offset 21, init 0):	NOATTR	Rx Queue
 *   _anon28	(size 4, offset 28, init 0):	MBZ	_
 */
typedef uint32_t e10k_l34timir_t;
#define e10k_l34timir_default 0x80000
static inline uint8_t e10k_l34timir_size_bp_extract(e10k_l34timir_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_l34timir_size_bp_extract(e10k_l34timir_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_l34timir_t e10k_l34timir_size_bp_insert(e10k_l34timir_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_l34timir_t e10k_l34timir_size_bp_insert(e10k_l34timir_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_l34timir_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_l34timir_lli_extract(e10k_l34timir_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_l34timir_lli_extract(e10k_l34timir_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_l34timir_t e10k_l34timir_lli_insert(e10k_l34timir_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_l34timir_t e10k_l34timir_lli_insert(e10k_l34timir_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_l34timir_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_l34timir_rx_queue_extract(e10k_l34timir_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_l34timir_rx_queue_extract(e10k_l34timir_t _regval)
{
    return((uint8_t )((_regval & 0xfe00000) >> 21));
}

static inline e10k_l34timir_t e10k_l34timir_rx_queue_insert(e10k_l34timir_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_l34timir_t e10k_l34timir_rx_queue_insert(e10k_l34timir_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf01fffff) | (0xfe00000 & (((e10k_l34timir_t )(_fieldval)) << 21)));
}

static inline int e10k_l34timir_prtval(char *_s, size_t _size, e10k_l34timir_t _regval) __attribute__ ((always_inline));
static inline int e10k_l34timir_prtval(char *_s, size_t _size, e10k_l34timir_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size_bp =\t%" PRIx8 "\t(Size Bypass)\n", e10k_l34timir_size_bp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli =\t%" PRIx8 "\t(Low Latency Interrupt)\n", e10k_l34timir_lli_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_queue =\t%" PRIx8 "\t(Rx Queue)\n", e10k_l34timir_rx_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_llithresh_t
 * Description: Implicit type of LLI Size Threshol register
 * Fields:
 *   sz_thresh	(size 12, offset 0, init 0):	RW	Size Threshold
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
typedef uint32_t e10k_llithresh_t;
#define e10k_llithresh_default 0x0
static inline uint16_t e10k_llithresh_sz_thresh_extract(e10k_llithresh_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_llithresh_sz_thresh_extract(e10k_llithresh_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e10k_llithresh_t e10k_llithresh_sz_thresh_insert(e10k_llithresh_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_llithresh_t e10k_llithresh_sz_thresh_insert(e10k_llithresh_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e10k_llithresh_t )(_fieldval)) << 0)));
}

static inline int e10k_llithresh_prtval(char *_s, size_t _size, e10k_llithresh_t _regval) __attribute__ ((always_inline));
static inline int e10k_llithresh_prtval(char *_s, size_t _size, e10k_llithresh_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sz_thresh =\t%" PRIx16 "\t(Size Threshold)\n", e10k_llithresh_sz_thresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_imirvp_t
 * Description: Implicit type of Immediate Interrupt Rx VLAN Priority Register register
 * Fields:
 *   vlan_pri	(size 3, offset 0, init 0):	RW	VLAN Priority
 *   vlan_pri_en	(size 1, offset 3, init 0):	RW	VLAN Priority Enable
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
typedef uint32_t e10k_imirvp_t;
#define e10k_imirvp_default 0x0
static inline uint8_t e10k_imirvp_vlan_pri_extract(e10k_imirvp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_imirvp_vlan_pri_extract(e10k_imirvp_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_imirvp_t e10k_imirvp_vlan_pri_insert(e10k_imirvp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_imirvp_t e10k_imirvp_vlan_pri_insert(e10k_imirvp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_imirvp_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_imirvp_vlan_pri_en_extract(e10k_imirvp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_imirvp_vlan_pri_en_extract(e10k_imirvp_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_imirvp_t e10k_imirvp_vlan_pri_en_insert(e10k_imirvp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_imirvp_t e10k_imirvp_vlan_pri_en_insert(e10k_imirvp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_imirvp_t )(_fieldval)) << 3)));
}

static inline int e10k_imirvp_prtval(char *_s, size_t _size, e10k_imirvp_t _regval) __attribute__ ((always_inline));
static inline int e10k_imirvp_prtval(char *_s, size_t _size, e10k_imirvp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan_pri =\t%" PRIx8 "\t(VLAN Priority)\n", e10k_imirvp_vlan_pri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan_pri_en =\t%" PRIx8 "\t(VLAN Priority Enable)\n", e10k_imirvp_vlan_pri_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_ivar_t
 * Description: Implicit type of Interrupt Vector Allocation Registers register array
 * Fields:
 *   i_alloc0	(size 6, offset 0, init 0):	NOATTR	The interrupt allocation for Rx queue 2n
 *   _anon6	(size 1, offset 6, init 0):	RSVD	_
 *   i_allocval0	(size 1, offset 7, init 0):	NOATTR	Interrupt allocation 0 valid
 *   i_alloc1	(size 6, offset 8, init 0):	NOATTR	The interrupt allocation for Tx queue 2n
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   i_allocval1	(size 1, offset 15, init 0):	NOATTR	Interrupt allocation 1 valid
 *   i_alloc2	(size 6, offset 16, init 0):	NOATTR	The interrupt allocation for Rx queue 2n+1
 *   _anon22	(size 1, offset 22, init 0):	RSVD	_
 *   i_allocval2	(size 1, offset 23, init 0):	NOATTR	Interrupt allocation 2 valid
 *   i_alloc3	(size 6, offset 24, init 0):	NOATTR	The interrupt allocation for Tx queue 2n+1
 *   _anon30	(size 1, offset 30, init 0):	RSVD	_
 *   i_allocval3	(size 1, offset 31, init 0):	NOATTR	Interrupt allocation 3 valid
 */
typedef uint32_t e10k_ivar_t;
#define e10k_ivar_default 0x0
static inline uint8_t e10k_ivar_i_alloc0_extract(e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_alloc0_extract(e10k_ivar_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline e10k_ivar_t e10k_ivar_i_alloc0_insert(e10k_ivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_i_alloc0_insert(e10k_ivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((e10k_ivar_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_ivar_i_allocval0_extract(e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_allocval0_extract(e10k_ivar_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_ivar_t e10k_ivar_i_allocval0_insert(e10k_ivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_i_allocval0_insert(e10k_ivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_ivar_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_ivar_i_alloc1_extract(e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_alloc1_extract(e10k_ivar_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline e10k_ivar_t e10k_ivar_i_alloc1_insert(e10k_ivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_i_alloc1_insert(e10k_ivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((e10k_ivar_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_ivar_i_allocval1_extract(e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_allocval1_extract(e10k_ivar_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_ivar_t e10k_ivar_i_allocval1_insert(e10k_ivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_i_allocval1_insert(e10k_ivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_ivar_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_ivar_i_alloc2_extract(e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_alloc2_extract(e10k_ivar_t _regval)
{
    return((uint8_t )((_regval & 0x3f0000) >> 16));
}

static inline e10k_ivar_t e10k_ivar_i_alloc2_insert(e10k_ivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_i_alloc2_insert(e10k_ivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffc0ffff) | (0x3f0000 & (((e10k_ivar_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_ivar_i_allocval2_extract(e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_allocval2_extract(e10k_ivar_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_ivar_t e10k_ivar_i_allocval2_insert(e10k_ivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_i_allocval2_insert(e10k_ivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_ivar_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_ivar_i_alloc3_extract(e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_alloc3_extract(e10k_ivar_t _regval)
{
    return((uint8_t )((_regval & 0x3f000000) >> 24));
}

static inline e10k_ivar_t e10k_ivar_i_alloc3_insert(e10k_ivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_i_alloc3_insert(e10k_ivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xc0ffffff) | (0x3f000000 & (((e10k_ivar_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_ivar_i_allocval3_extract(e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_allocval3_extract(e10k_ivar_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_ivar_t e10k_ivar_i_allocval3_insert(e10k_ivar_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_i_allocval3_insert(e10k_ivar_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_ivar_t )(_fieldval)) << 31)));
}

static inline int e10k_ivar_prtval(char *_s, size_t _size, e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline int e10k_ivar_prtval(char *_s, size_t _size, e10k_ivar_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc0 =\t%" PRIx8 "\t(The interrupt allocation for Rx queue 2n)\n", e10k_ivar_i_alloc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval0 =\t%" PRIx8 "\t(Interrupt allocation 0 valid)\n", e10k_ivar_i_allocval0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc1 =\t%" PRIx8 "\t(The interrupt allocation for Tx queue 2n)\n", e10k_ivar_i_alloc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval1 =\t%" PRIx8 "\t(Interrupt allocation 1 valid)\n", e10k_ivar_i_allocval1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc2 =\t%" PRIx8 "\t(The interrupt allocation for Rx queue 2n+1)\n", e10k_ivar_i_alloc2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval2 =\t%" PRIx8 "\t(Interrupt allocation 2 valid)\n", e10k_ivar_i_allocval2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc3 =\t%" PRIx8 "\t(The interrupt allocation for Tx queue 2n+1)\n", e10k_ivar_i_alloc3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval3 =\t%" PRIx8 "\t(Interrupt allocation 3 valid)\n", e10k_ivar_i_allocval3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_ivar_misc_t
 * Description: Implicit type of Miscellaneous Interrupt Vector Allocation register
 * Fields:
 *   i_alloc0	(size 7, offset 0, init 0):	RW	MSI-X vector assigned to the TCP timer interrupt
 *   i_allocval0	(size 1, offset 7, init 0):	RW	Interrupt allocation 0 valid
 *   i_alloc1	(size 7, offset 8, init 0):	RW	MSI-X vector assigned to the other interrupt cause
 *   i_allocval1	(size 1, offset 15, init 0):	RW	Interrupt allocation 1 valid
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_ivar_misc_t;
#define e10k_ivar_misc_default 0x0
static inline uint8_t e10k_ivar_misc_i_alloc0_extract(e10k_ivar_misc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_misc_i_alloc0_extract(e10k_ivar_misc_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline e10k_ivar_misc_t e10k_ivar_misc_i_alloc0_insert(e10k_ivar_misc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_misc_t e10k_ivar_misc_i_alloc0_insert(e10k_ivar_misc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((e10k_ivar_misc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_ivar_misc_i_allocval0_extract(e10k_ivar_misc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_misc_i_allocval0_extract(e10k_ivar_misc_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_ivar_misc_t e10k_ivar_misc_i_allocval0_insert(e10k_ivar_misc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_misc_t e10k_ivar_misc_i_allocval0_insert(e10k_ivar_misc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_ivar_misc_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_ivar_misc_i_alloc1_extract(e10k_ivar_misc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_misc_i_alloc1_extract(e10k_ivar_misc_t _regval)
{
    return((uint8_t )((_regval & 0x7f00) >> 8));
}

static inline e10k_ivar_misc_t e10k_ivar_misc_i_alloc1_insert(e10k_ivar_misc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_misc_t e10k_ivar_misc_i_alloc1_insert(e10k_ivar_misc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff80ff) | (0x7f00 & (((e10k_ivar_misc_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_ivar_misc_i_allocval1_extract(e10k_ivar_misc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_misc_i_allocval1_extract(e10k_ivar_misc_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_ivar_misc_t e10k_ivar_misc_i_allocval1_insert(e10k_ivar_misc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ivar_misc_t e10k_ivar_misc_i_allocval1_insert(e10k_ivar_misc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_ivar_misc_t )(_fieldval)) << 15)));
}

static inline int e10k_ivar_misc_prtval(char *_s, size_t _size, e10k_ivar_misc_t _regval) __attribute__ ((always_inline));
static inline int e10k_ivar_misc_prtval(char *_s, size_t _size, e10k_ivar_misc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc0 =\t%" PRIx8 "\t(MSI-X vector assigned to the TCP timer interrupt)\n", e10k_ivar_misc_i_alloc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval0 =\t%" PRIx8 "\t(Interrupt allocation 0 valid)\n", e10k_ivar_misc_i_allocval0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc1 =\t%" PRIx8 "\t(MSI-X vector assigned to the other interrupt cause)\n", e10k_ivar_misc_i_alloc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval1 =\t%" PRIx8 "\t(Interrupt allocation 1 valid)\n", e10k_ivar_misc_i_allocval1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_gpie_t
 * Description: Implicit type of General Purpose Interrupt Enable register
 * Fields:
 *   spd0_gpien	(size 1, offset 0, init 0):	RW	General Purpose Interrupt Detection Enable for SDP0
 *   spd1_gpien	(size 1, offset 1, init 0):	RW	General Purpose Interrupt Detection Enable for SDP1
 *   spd2_gpien	(size 1, offset 2, init 0):	RW	General Purpose Interrupt Detection Enable for SDP2
 *   spd3_gpien	(size 1, offset 3, init 0):	RW	General Purpose Interrupt Detection Enable for SDP3
 *   msix	(size 1, offset 4, init 0):	RW	MSI-X Mode enable
 *   ocd	(size 1, offset 5, init 0):	RW	Other Clear Disable
 *   eimen	(size 1, offset 6, init 0):	RW	EICS Immediate Interrupt Enable
 *   ll_int	(size 4, offset 7, init 0):	RW	Low latency Credits Increment Rate
 *   rsc_delay	(size 3, offset 11, init 0):	RW	RSC Delay
 *   vt_mode	(size 2, offset 14, init 0):	RW	VT_Mode
 *   _anon16	(size 14, offset 16, init 0):	RSVD	_
 *   eiame	(size 1, offset 30, init 0):	RW	Extended Interrupt Auto Mask Enable
 *   pba_sup	(size 1, offset 31, init 0):	RW	BA Support
 */
typedef uint32_t e10k_gpie_t;
#define e10k_gpie_default 0x0
static inline uint8_t e10k_gpie_spd0_gpien_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_spd0_gpien_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_gpie_t e10k_gpie_spd0_gpien_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_spd0_gpien_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_gpie_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_gpie_spd1_gpien_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_spd1_gpien_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_gpie_t e10k_gpie_spd1_gpien_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_spd1_gpien_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_gpie_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_gpie_spd2_gpien_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_spd2_gpien_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_gpie_t e10k_gpie_spd2_gpien_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_spd2_gpien_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_gpie_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_gpie_spd3_gpien_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_spd3_gpien_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_gpie_t e10k_gpie_spd3_gpien_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_spd3_gpien_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_gpie_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_gpie_msix_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_msix_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_gpie_t e10k_gpie_msix_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_msix_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_gpie_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_gpie_ocd_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_ocd_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_gpie_t e10k_gpie_ocd_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_ocd_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_gpie_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_gpie_eimen_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_eimen_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_gpie_t e10k_gpie_eimen_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_eimen_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_gpie_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_gpie_ll_int_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_ll_int_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x780) >> 7));
}

static inline e10k_gpie_t e10k_gpie_ll_int_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_ll_int_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff87f) | (0x780 & (((e10k_gpie_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_gpie_rsc_delay_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_rsc_delay_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x3800) >> 11));
}

static inline e10k_gpie_t e10k_gpie_rsc_delay_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_rsc_delay_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc7ff) | (0x3800 & (((e10k_gpie_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_gpie_vt_mode_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_vt_mode_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0xc000) >> 14));
}

static inline e10k_gpie_t e10k_gpie_vt_mode_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_vt_mode_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((e10k_gpie_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_gpie_eiame_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_eiame_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_gpie_t e10k_gpie_eiame_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_eiame_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_gpie_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_gpie_pba_sup_extract(e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_pba_sup_extract(e10k_gpie_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_gpie_t e10k_gpie_pba_sup_insert(e10k_gpie_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_pba_sup_insert(e10k_gpie_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_gpie_t )(_fieldval)) << 31)));
}

static inline int e10k_gpie_prtval(char *_s, size_t _size, e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline int e10k_gpie_prtval(char *_s, size_t _size, e10k_gpie_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd0_gpien =\t%" PRIx8 "\t(General Purpose Interrupt Detection Enable for SDP0)\n", e10k_gpie_spd0_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd1_gpien =\t%" PRIx8 "\t(General Purpose Interrupt Detection Enable for SDP1)\n", e10k_gpie_spd1_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd2_gpien =\t%" PRIx8 "\t(General Purpose Interrupt Detection Enable for SDP2)\n", e10k_gpie_spd2_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd3_gpien =\t%" PRIx8 "\t(General Purpose Interrupt Detection Enable for SDP3)\n", e10k_gpie_spd3_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(MSI-X Mode enable)\n", e10k_gpie_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocd =\t%" PRIx8 "\t(Other Clear Disable)\n", e10k_gpie_ocd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eimen =\t%" PRIx8 "\t(EICS Immediate Interrupt Enable)\n", e10k_gpie_eimen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ll_int =\t%" PRIx8 "\t(Low latency Credits Increment Rate)\n", e10k_gpie_ll_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_delay =\t%" PRIx8 "\t(RSC Delay)\n", e10k_gpie_rsc_delay_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vt_mode =\t%" PRIx8 "\t(VT_Mode)\n", e10k_gpie_vt_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eiame =\t%" PRIx8 "\t(Extended Interrupt Auto Mask Enable)\n", e10k_gpie_eiame_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pba_sup =\t%" PRIx8 "\t(BA Support)\n", e10k_gpie_pba_sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pbacl_t
 * Description: Implicit type of MSI-X PBA Clear register array
 * Fields:
 *   penbitclr	(size 32, offset 0, init 0):	RWC	MSI-X Pending Bits Clear
 */
typedef uint32_t e10k_pbacl_t;
#define e10k_pbacl_default 0x0
static inline uint32_t e10k_pbacl_penbitclr_extract(e10k_pbacl_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_pbacl_penbitclr_extract(e10k_pbacl_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_pbacl_t e10k_pbacl_penbitclr_insert(e10k_pbacl_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pbacl_t e10k_pbacl_penbitclr_insert(e10k_pbacl_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_pbacl_t )(_fieldval)) << 0)));
}

static inline int e10k_pbacl_prtval(char *_s, size_t _size, e10k_pbacl_t _regval) __attribute__ ((always_inline));
static inline int e10k_pbacl_prtval(char *_s, size_t _size, e10k_pbacl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " penbitclr =\t%" PRIx32 "\t(MSI-X Pending Bits Clear)\n", e10k_pbacl_penbitclr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fctrl_t
 * Description: Implicit type of Filter Control Register register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   sbp	(size 1, offset 1, init 0):	RW	Store Bad Packets
 *   _anon2	(size 6, offset 2, init 0):	RSVD	_
 *   mpe	(size 1, offset 8, init 0):	RW	Multicast Promiscuous Enable
 *   upe	(size 1, offset 9, init 0):	RW	Unicast Promiscuous Enable
 *   bam	(size 1, offset 10, init 0):	RW	Broadcast Accept Mode
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
typedef uint32_t e10k_fctrl_t;
#define e10k_fctrl_default 0x0
static inline uint8_t e10k_fctrl_sbp_extract(e10k_fctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fctrl_sbp_extract(e10k_fctrl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_fctrl_t e10k_fctrl_sbp_insert(e10k_fctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fctrl_t e10k_fctrl_sbp_insert(e10k_fctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_fctrl_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_fctrl_mpe_extract(e10k_fctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fctrl_mpe_extract(e10k_fctrl_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_fctrl_t e10k_fctrl_mpe_insert(e10k_fctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fctrl_t e10k_fctrl_mpe_insert(e10k_fctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_fctrl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_fctrl_upe_extract(e10k_fctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fctrl_upe_extract(e10k_fctrl_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_fctrl_t e10k_fctrl_upe_insert(e10k_fctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fctrl_t e10k_fctrl_upe_insert(e10k_fctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_fctrl_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_fctrl_bam_extract(e10k_fctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fctrl_bam_extract(e10k_fctrl_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_fctrl_t e10k_fctrl_bam_insert(e10k_fctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fctrl_t e10k_fctrl_bam_insert(e10k_fctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_fctrl_t )(_fieldval)) << 10)));
}

static inline int e10k_fctrl_prtval(char *_s, size_t _size, e10k_fctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_fctrl_prtval(char *_s, size_t _size, e10k_fctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sbp =\t%" PRIx8 "\t(Store Bad Packets)\n", e10k_fctrl_sbp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpe =\t%" PRIx8 "\t(Multicast Promiscuous Enable)\n", e10k_fctrl_mpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " upe =\t%" PRIx8 "\t(Unicast Promiscuous Enable)\n", e10k_fctrl_upe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bam =\t%" PRIx8 "\t(Broadcast Accept Mode)\n", e10k_fctrl_bam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vlnctrl_t
 * Description: Implicit type of VLAN Control Register register
 * Fields:
 *   vet	(size 16, offset 0, init 0):	RW	VLAN Ether Type
 *   _anon16	(size 12, offset 16, init 0):	RSVD	_
 *   cfi	(size 1, offset 28, init 0):	RW	Canonical Form Indicator Bit Value
 *   cfien	(size 1, offset 29, init 0):	RW	Canonical Form Indicator Enable
 *   vfe	(size 1, offset 30, init 0):	RW	VLAN Filter Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_vlnctrl_t;
#define e10k_vlnctrl_default 0x0
static inline uint16_t e10k_vlnctrl_vet_extract(e10k_vlnctrl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_vlnctrl_vet_extract(e10k_vlnctrl_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_vlnctrl_t e10k_vlnctrl_vet_insert(e10k_vlnctrl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vlnctrl_t e10k_vlnctrl_vet_insert(e10k_vlnctrl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_vlnctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_vlnctrl_cfi_extract(e10k_vlnctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vlnctrl_cfi_extract(e10k_vlnctrl_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_vlnctrl_t e10k_vlnctrl_cfi_insert(e10k_vlnctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vlnctrl_t e10k_vlnctrl_cfi_insert(e10k_vlnctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_vlnctrl_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_vlnctrl_cfien_extract(e10k_vlnctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vlnctrl_cfien_extract(e10k_vlnctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_vlnctrl_t e10k_vlnctrl_cfien_insert(e10k_vlnctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vlnctrl_t e10k_vlnctrl_cfien_insert(e10k_vlnctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_vlnctrl_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_vlnctrl_vfe_extract(e10k_vlnctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_vlnctrl_vfe_extract(e10k_vlnctrl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_vlnctrl_t e10k_vlnctrl_vfe_insert(e10k_vlnctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vlnctrl_t e10k_vlnctrl_vfe_insert(e10k_vlnctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_vlnctrl_t )(_fieldval)) << 30)));
}

static inline int e10k_vlnctrl_prtval(char *_s, size_t _size, e10k_vlnctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_vlnctrl_prtval(char *_s, size_t _size, e10k_vlnctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vet =\t%" PRIx16 "\t(VLAN Ether Type)\n", e10k_vlnctrl_vet_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfi =\t%" PRIx8 "\t(Canonical Form Indicator Bit Value)\n", e10k_vlnctrl_cfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfien =\t%" PRIx8 "\t(Canonical Form Indicator Enable)\n", e10k_vlnctrl_cfien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vfe =\t%" PRIx8 "\t(VLAN Filter Enable)\n", e10k_vlnctrl_vfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mcstctrl_t
 * Description: Implicit type of Multicast Control Register register
 * Fields:
 *   mo	(size 2, offset 0, init 0):	RW	Multicast Offset
 *   mfe	(size 1, offset 2, init 0):	RW	Multicast Filter Enable
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_mcstctrl_t;
#define e10k_mcstctrl_default 0x0
static inline uint8_t e10k_mcstctrl_mo_extract(e10k_mcstctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mcstctrl_mo_extract(e10k_mcstctrl_t _regval)
{
    return((uint8_t )((_regval & 0x3) >> 0));
}

static inline e10k_mcstctrl_t e10k_mcstctrl_mo_insert(e10k_mcstctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mcstctrl_t e10k_mcstctrl_mo_insert(e10k_mcstctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e10k_mcstctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_mcstctrl_mfe_extract(e10k_mcstctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mcstctrl_mfe_extract(e10k_mcstctrl_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_mcstctrl_t e10k_mcstctrl_mfe_insert(e10k_mcstctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mcstctrl_t e10k_mcstctrl_mfe_insert(e10k_mcstctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_mcstctrl_t )(_fieldval)) << 2)));
}

static inline int e10k_mcstctrl_prtval(char *_s, size_t _size, e10k_mcstctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_mcstctrl_prtval(char *_s, size_t _size, e10k_mcstctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mo =\t%" PRIx8 "\t(Multicast Offset)\n", e10k_mcstctrl_mo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mfe =\t%" PRIx8 "\t(Multicast Filter Enable)\n", e10k_mcstctrl_mfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_psrtype_t
 * Description: Implicit type of Packet Split Receive Type Register register array
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   split_nfs	(size 1, offset 1, init 0):	NOATTR	Split received NFS packets after NFS header
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   split_tcp	(size 1, offset 4, init 0):	NOATTR	Split received TCP packets after TCP header
 *   split_udp	(size 1, offset 5, init 0):	NOATTR	Split received UDP packets after UDP header
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   split_ip4	(size 1, offset 8, init 0):	NOATTR	Split received IPv4 packets after IPv4 header
 *   split_ip6	(size 1, offset 9, init 0):	NOATTR	Split received IPv6 packets after IPv6 header
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   split_l2	(size 1, offset 12, init 0):	NOATTR	Split received L2 packets after L2 header
 *   _anon13	(size 16, offset 13, init 0):	MBZ	_
 *   rqpl	(size 3, offset 29, init 0):	NOATTR	Number of bits to use for RSS redirection
 */
typedef uint32_t e10k_psrtype_t;
#define e10k_psrtype_default 0x0
static inline uint8_t e10k_psrtype_split_nfs_extract(e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_nfs_extract(e10k_psrtype_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_psrtype_t e10k_psrtype_split_nfs_insert(e10k_psrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_split_nfs_insert(e10k_psrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_psrtype_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_psrtype_split_tcp_extract(e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_tcp_extract(e10k_psrtype_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_psrtype_t e10k_psrtype_split_tcp_insert(e10k_psrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_split_tcp_insert(e10k_psrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_psrtype_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_psrtype_split_udp_extract(e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_udp_extract(e10k_psrtype_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_psrtype_t e10k_psrtype_split_udp_insert(e10k_psrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_split_udp_insert(e10k_psrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_psrtype_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_psrtype_split_ip4_extract(e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_ip4_extract(e10k_psrtype_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_psrtype_t e10k_psrtype_split_ip4_insert(e10k_psrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_split_ip4_insert(e10k_psrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_psrtype_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_psrtype_split_ip6_extract(e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_ip6_extract(e10k_psrtype_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_psrtype_t e10k_psrtype_split_ip6_insert(e10k_psrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_split_ip6_insert(e10k_psrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_psrtype_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_psrtype_split_l2_extract(e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_l2_extract(e10k_psrtype_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_psrtype_t e10k_psrtype_split_l2_insert(e10k_psrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_split_l2_insert(e10k_psrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_psrtype_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_psrtype_rqpl_extract(e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_rqpl_extract(e10k_psrtype_t _regval)
{
    return((uint8_t )((_regval & 0xe0000000) >> 29));
}

static inline e10k_psrtype_t e10k_psrtype_rqpl_insert(e10k_psrtype_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_rqpl_insert(e10k_psrtype_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x1fffffff) | (0xe0000000 & (((e10k_psrtype_t )(_fieldval)) << 29)));
}

static inline int e10k_psrtype_prtval(char *_s, size_t _size, e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline int e10k_psrtype_prtval(char *_s, size_t _size, e10k_psrtype_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_nfs =\t%" PRIx8 "\t(Split received NFS packets after NFS header)\n", e10k_psrtype_split_nfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_tcp =\t%" PRIx8 "\t(Split received TCP packets after TCP header)\n", e10k_psrtype_split_tcp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_udp =\t%" PRIx8 "\t(Split received UDP packets after UDP header)\n", e10k_psrtype_split_udp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_ip4 =\t%" PRIx8 "\t(Split received IPv4 packets after IPv4 header)\n", e10k_psrtype_split_ip4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_ip6 =\t%" PRIx8 "\t(Split received IPv6 packets after IPv6 header)\n", e10k_psrtype_split_ip6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_l2 =\t%" PRIx8 "\t(Split received L2 packets after L2 header)\n", e10k_psrtype_split_l2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqpl =\t%" PRIx8 "\t(Number of bits to use for RSS redirection)\n", e10k_psrtype_rqpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rxcsum_t
 * Description: Implicit type of Receive Checksum Control register
 * Fields:
 *   _anon0	(size 12, offset 0, init 0):	RSVD	_
 *   ippcse	(size 1, offset 12, init 0):	RW	IP Payload Checksum Enable
 *   pscd	(size 1, offset 13, init 0):	RW	RSS/Fragment Checksum Status Selection
 *   _anon14	(size 18, offset 14, init 0):	RSVD	_
 */
typedef uint32_t e10k_rxcsum_t;
#define e10k_rxcsum_default 0x0
static inline uint8_t e10k_rxcsum_ippcse_extract(e10k_rxcsum_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxcsum_ippcse_extract(e10k_rxcsum_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_rxcsum_t e10k_rxcsum_ippcse_insert(e10k_rxcsum_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxcsum_t e10k_rxcsum_ippcse_insert(e10k_rxcsum_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_rxcsum_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_rxcsum_pscd_extract(e10k_rxcsum_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxcsum_pscd_extract(e10k_rxcsum_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_rxcsum_t e10k_rxcsum_pscd_insert(e10k_rxcsum_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxcsum_t e10k_rxcsum_pscd_insert(e10k_rxcsum_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_rxcsum_t )(_fieldval)) << 13)));
}

static inline int e10k_rxcsum_prtval(char *_s, size_t _size, e10k_rxcsum_t _regval) __attribute__ ((always_inline));
static inline int e10k_rxcsum_prtval(char *_s, size_t _size, e10k_rxcsum_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ippcse =\t%" PRIx8 "\t(IP Payload Checksum Enable)\n", e10k_rxcsum_ippcse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pscd =\t%" PRIx8 "\t(RSS/Fragment Checksum Status Selection)\n", e10k_rxcsum_pscd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rfctl_t
 * Description: Implicit type of Receive Filter Control Register register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rsc_dis	(size 1, offset 5, init 0):	RW	RSC Disable
 *   nfsw_dis	(size 1, offset 6, init 0):	RW	Disable filtering of NFS write request headers
 *   nfsr_dis	(size 1, offset 7, init 0):	RW	Disable filtering of NFS read reply headers
 *   nfs_ver	(size 2, offset 8, init 0):	RW	NFS version recognized by the hardware
 *   ipv6_dis	(size 1, offset 10, init 0):	RW	Disable IPv6 packet filtering
 *   _anon11	(size 1, offset 11, init 0):	MBZ	_
 *   _anon12	(size 2, offset 12, init 0):	RSVD	_
 *   ipfrsp_dis	(size 1, offset 14, init 0):	RW	IP Fragment Split Disable
 *   _anon15	(size 3, offset 15, init 0):	RSVD	_
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
typedef uint32_t e10k_rfctl_t;
#define e10k_rfctl_default 0x0
static inline uint8_t e10k_rfctl_rsc_dis_extract(e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_rsc_dis_extract(e10k_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_rfctl_t e10k_rfctl_rsc_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rfctl_t e10k_rfctl_rsc_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_rfctl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_rfctl_nfsw_dis_extract(e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_nfsw_dis_extract(e10k_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_rfctl_t e10k_rfctl_nfsw_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rfctl_t e10k_rfctl_nfsw_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_rfctl_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_rfctl_nfsr_dis_extract(e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_nfsr_dis_extract(e10k_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_rfctl_t e10k_rfctl_nfsr_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rfctl_t e10k_rfctl_nfsr_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_rfctl_t )(_fieldval)) << 7)));
}

static inline e10k_nfs_version_t e10k_rfctl_nfs_ver_extract(e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline e10k_nfs_version_t e10k_rfctl_nfs_ver_extract(e10k_rfctl_t _regval)
{
    return((e10k_nfs_version_t )((_regval & 0x300) >> 8));
}

static inline e10k_rfctl_t e10k_rfctl_nfs_ver_insert(e10k_rfctl_t _regval, e10k_nfs_version_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rfctl_t e10k_rfctl_nfs_ver_insert(e10k_rfctl_t _regval, e10k_nfs_version_t _fieldval)
{
    return((_regval & 0xfffffcff) | (0x300 & (((e10k_rfctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_rfctl_ipv6_dis_extract(e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_ipv6_dis_extract(e10k_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_rfctl_t e10k_rfctl_ipv6_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rfctl_t e10k_rfctl_ipv6_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_rfctl_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_rfctl_ipfrsp_dis_extract(e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_ipfrsp_dis_extract(e10k_rfctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_rfctl_t e10k_rfctl_ipfrsp_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rfctl_t e10k_rfctl_ipfrsp_dis_insert(e10k_rfctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_rfctl_t )(_fieldval)) << 14)));
}

static inline int e10k_rfctl_prtval(char *_s, size_t _size, e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_rfctl_prtval(char *_s, size_t _size, e10k_rfctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_dis =\t%" PRIx8 "\t(RSC Disable)\n", e10k_rfctl_rsc_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfsw_dis =\t%" PRIx8 "\t(Disable filtering of NFS write request headers)\n", e10k_rfctl_nfsw_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfsr_dis =\t%" PRIx8 "\t(Disable filtering of NFS read reply headers)\n", e10k_rfctl_nfsr_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfs_ver =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_nfs_version_prtval(_s + _r, _avail, e10k_rfctl_nfs_ver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(NFS version recognized by the hardware)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6_dis =\t%" PRIx8 "\t(Disable IPv6 packet filtering)\n", e10k_rfctl_ipv6_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipfrsp_dis =\t%" PRIx8 "\t(IP Fragment Split Disable)\n", e10k_rfctl_ipfrsp_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mta_t
 * Description: Implicit type of Multicast Table Array register array
 * Fields:
 *   bit_vec	(size 32, offset 0, init 0):	NOATTR	Bit Vector
 */
typedef uint32_t e10k_mta_t;
#define e10k_mta_default 0x0
static inline uint32_t e10k_mta_bit_vec_extract(e10k_mta_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_mta_bit_vec_extract(e10k_mta_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_mta_t e10k_mta_bit_vec_insert(e10k_mta_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mta_t e10k_mta_bit_vec_insert(e10k_mta_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_mta_t )(_fieldval)) << 0)));
}

static inline int e10k_mta_prtval(char *_s, size_t _size, e10k_mta_t _regval) __attribute__ ((always_inline));
static inline int e10k_mta_prtval(char *_s, size_t _size, e10k_mta_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bit_vec =\t%" PRIx32 "\t(Bit Vector)\n", e10k_mta_bit_vec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_ral_t
 * Description: Implicit type of Receive Address Low register array
 * Fields:
 *   ral	(size 32, offset 0, init 0):	NOATTR	Receive Address Low
 */
typedef uint32_t e10k_ral_t;
#define e10k_ral_default 0x0
static inline uint32_t e10k_ral_ral_extract(e10k_ral_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_ral_ral_extract(e10k_ral_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_ral_t e10k_ral_ral_insert(e10k_ral_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ral_t e10k_ral_ral_insert(e10k_ral_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_ral_t )(_fieldval)) << 0)));
}

static inline int e10k_ral_prtval(char *_s, size_t _size, e10k_ral_t _regval) __attribute__ ((always_inline));
static inline int e10k_ral_prtval(char *_s, size_t _size, e10k_ral_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ral =\t%" PRIx32 "\t(Receive Address Low)\n", e10k_ral_ral_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rah_t
 * Description: Implicit type of Receive Address High register array
 * Fields:
 *   rah	(size 16, offset 0, init 0):	NOATTR	Receive Address High
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   av	(size 1, offset 31, init 0):	NOATTR	Address Valid
 */
typedef uint32_t e10k_rah_t;
#define e10k_rah_default 0x0
static inline uint16_t e10k_rah_rah_extract(e10k_rah_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rah_rah_extract(e10k_rah_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_rah_t e10k_rah_rah_insert(e10k_rah_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rah_t e10k_rah_rah_insert(e10k_rah_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_rah_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rah_av_extract(e10k_rah_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rah_av_extract(e10k_rah_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_rah_t e10k_rah_av_insert(e10k_rah_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rah_t e10k_rah_av_insert(e10k_rah_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_rah_t )(_fieldval)) << 31)));
}

static inline int e10k_rah_prtval(char *_s, size_t _size, e10k_rah_t _regval) __attribute__ ((always_inline));
static inline int e10k_rah_prtval(char *_s, size_t _size, e10k_rah_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rah =\t%" PRIx16 "\t(Receive Address High)\n", e10k_rah_rah_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " av =\t%" PRIx8 "\t(Address Valid)\n", e10k_rah_av_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mpsar_t
 * Description: Implicit type of MAC Pool Select Array register array
 * Fields:
 *   pool_ena	(size 32, offset 0, init 0):	NOATTR	Pool Enable Bit Array
 */
typedef uint32_t e10k_mpsar_t;
#define e10k_mpsar_default 0x0
static inline uint32_t e10k_mpsar_pool_ena_extract(e10k_mpsar_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_mpsar_pool_ena_extract(e10k_mpsar_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_mpsar_t e10k_mpsar_pool_ena_insert(e10k_mpsar_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mpsar_t e10k_mpsar_pool_ena_insert(e10k_mpsar_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_mpsar_t )(_fieldval)) << 0)));
}

static inline int e10k_mpsar_prtval(char *_s, size_t _size, e10k_mpsar_t _regval) __attribute__ ((always_inline));
static inline int e10k_mpsar_prtval(char *_s, size_t _size, e10k_mpsar_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool_ena =\t%" PRIx32 "\t(Pool Enable Bit Array)\n", e10k_mpsar_pool_ena_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_vfta_t
 * Description: Implicit type of VLAN Filter Table Array register array
 * Fields:
 *   vlan_flt	(size 32, offset 0, init 0):	NOATTR	VLAN Filter
 */
typedef uint32_t e10k_vfta_t;
#define e10k_vfta_default 0x0
static inline uint32_t e10k_vfta_vlan_flt_extract(e10k_vfta_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_vfta_vlan_flt_extract(e10k_vfta_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_vfta_t e10k_vfta_vlan_flt_insert(e10k_vfta_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_vfta_t e10k_vfta_vlan_flt_insert(e10k_vfta_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_vfta_t )(_fieldval)) << 0)));
}

static inline int e10k_vfta_prtval(char *_s, size_t _size, e10k_vfta_t _regval) __attribute__ ((always_inline));
static inline int e10k_vfta_prtval(char *_s, size_t _size, e10k_vfta_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan_flt =\t%" PRIx32 "\t(VLAN Filter)\n", e10k_vfta_vlan_flt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mrqc_t
 * Description: Implicit type of Multiple Receive Queues Command Register register
 * Fields:
 *   mrque	(size 4, offset 0, init 0):	RW	Multiple Receive Queues Enable
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   en_tcpip4	(size 1, offset 16, init 0):	RW	Enable TcpIPv4 hash function
 *   en_ip4	(size 1, offset 17, init 0):	RW	Enable IPv4 hash function
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   en_ip6	(size 1, offset 20, init 0):	RW	Enable IPv6 hash function
 *   en_tcpip6	(size 1, offset 21, init 0):	RW	Enable TcpIPv6 hash function
 *   en_udp4	(size 1, offset 22, init 0):	RW	Enable UdpIPV4
 *   en_udp6	(size 1, offset 23, init 0):	RW	Enable UdpIPV6
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t e10k_mrqc_t;
#define e10k_mrqc_default 0x0
static inline e10k_mrq_mode_t e10k_mrqc_mrque_extract(e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline e10k_mrq_mode_t e10k_mrqc_mrque_extract(e10k_mrqc_t _regval)
{
    return((e10k_mrq_mode_t )((_regval & 0xf) >> 0));
}

static inline e10k_mrqc_t e10k_mrqc_mrque_insert(e10k_mrqc_t _regval, e10k_mrq_mode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_mrque_insert(e10k_mrqc_t _regval, e10k_mrq_mode_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((e10k_mrqc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_mrqc_en_tcpip4_extract(e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_tcpip4_extract(e10k_mrqc_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_mrqc_t e10k_mrqc_en_tcpip4_insert(e10k_mrqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_en_tcpip4_insert(e10k_mrqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_mrqc_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_mrqc_en_ip4_extract(e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_ip4_extract(e10k_mrqc_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_mrqc_t e10k_mrqc_en_ip4_insert(e10k_mrqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_en_ip4_insert(e10k_mrqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_mrqc_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_mrqc_en_ip6_extract(e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_ip6_extract(e10k_mrqc_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_mrqc_t e10k_mrqc_en_ip6_insert(e10k_mrqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_en_ip6_insert(e10k_mrqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_mrqc_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_mrqc_en_tcpip6_extract(e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_tcpip6_extract(e10k_mrqc_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_mrqc_t e10k_mrqc_en_tcpip6_insert(e10k_mrqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_en_tcpip6_insert(e10k_mrqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_mrqc_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_mrqc_en_udp4_extract(e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_udp4_extract(e10k_mrqc_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_mrqc_t e10k_mrqc_en_udp4_insert(e10k_mrqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_en_udp4_insert(e10k_mrqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_mrqc_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_mrqc_en_udp6_extract(e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_udp6_extract(e10k_mrqc_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_mrqc_t e10k_mrqc_en_udp6_insert(e10k_mrqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_en_udp6_insert(e10k_mrqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_mrqc_t )(_fieldval)) << 23)));
}

static inline int e10k_mrqc_prtval(char *_s, size_t _size, e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline int e10k_mrqc_prtval(char *_s, size_t _size, e10k_mrqc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mrque =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mrq_mode_prtval(_s + _r, _avail, e10k_mrqc_mrque_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Multiple Receive Queues Enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_tcpip4 =\t%" PRIx8 "\t(Enable TcpIPv4 hash function)\n", e10k_mrqc_en_tcpip4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_ip4 =\t%" PRIx8 "\t(Enable IPv4 hash function)\n", e10k_mrqc_en_ip4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_ip6 =\t%" PRIx8 "\t(Enable IPv6 hash function)\n", e10k_mrqc_en_ip6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_tcpip6 =\t%" PRIx8 "\t(Enable TcpIPv6 hash function)\n", e10k_mrqc_en_tcpip6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_udp4 =\t%" PRIx8 "\t(Enable UdpIPV4)\n", e10k_mrqc_en_udp4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_udp6 =\t%" PRIx8 "\t(Enable UdpIPV6)\n", e10k_mrqc_en_udp6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rqtc_t
 * Description: Implicit type of RSS Queues Per Traffic Class Register register
 * Fields:
 *   rqtc0	(size 3, offset 0, init 0):	RW	Number of bits to use for RSS redirection TC0
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   rqtc1	(size 3, offset 4, init 0):	RW	Number of bits to use for RSS redirection TC1
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   rqtc2	(size 3, offset 8, init 0):	RW	Number of bits to use for RSS redirection TC2
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   rqtc3	(size 3, offset 12, init 0):	RW	Number of bits to use for RSS redirection TC3
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   rqtc4	(size 3, offset 16, init 0):	RW	Number of bits to use for RSS redirection TC4
 *   _anon19	(size 1, offset 19, init 0):	RSVD	_
 *   rqtc5	(size 3, offset 20, init 0):	RW	Number of bits to use for RSS redirection TC5
 *   _anon23	(size 1, offset 23, init 0):	RSVD	_
 *   rqtc6	(size 3, offset 24, init 0):	RW	Number of bits to use for RSS redirection TC6
 *   _anon27	(size 1, offset 27, init 0):	RSVD	_
 *   rqtc7	(size 3, offset 28, init 0):	RW	Number of bits to use for RSS redirection TC7
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_rqtc_t;
#define e10k_rqtc_default 0x0
static inline uint8_t e10k_rqtc_rqtc0_extract(e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc0_extract(e10k_rqtc_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_rqtc_t e10k_rqtc_rqtc0_insert(e10k_rqtc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rqtc0_insert(e10k_rqtc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_rqtc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rqtc_rqtc1_extract(e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc1_extract(e10k_rqtc_t _regval)
{
    return((uint8_t )((_regval & 0x70) >> 4));
}

static inline e10k_rqtc_t e10k_rqtc_rqtc1_insert(e10k_rqtc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rqtc1_insert(e10k_rqtc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff8f) | (0x70 & (((e10k_rqtc_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_rqtc_rqtc2_extract(e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc2_extract(e10k_rqtc_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline e10k_rqtc_t e10k_rqtc_rqtc2_insert(e10k_rqtc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rqtc2_insert(e10k_rqtc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((e10k_rqtc_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_rqtc_rqtc3_extract(e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc3_extract(e10k_rqtc_t _regval)
{
    return((uint8_t )((_regval & 0x7000) >> 12));
}

static inline e10k_rqtc_t e10k_rqtc_rqtc3_insert(e10k_rqtc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rqtc3_insert(e10k_rqtc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff8fff) | (0x7000 & (((e10k_rqtc_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_rqtc_rqtc4_extract(e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc4_extract(e10k_rqtc_t _regval)
{
    return((uint8_t )((_regval & 0x70000) >> 16));
}

static inline e10k_rqtc_t e10k_rqtc_rqtc4_insert(e10k_rqtc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rqtc4_insert(e10k_rqtc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((e10k_rqtc_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_rqtc_rqtc5_extract(e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc5_extract(e10k_rqtc_t _regval)
{
    return((uint8_t )((_regval & 0x700000) >> 20));
}

static inline e10k_rqtc_t e10k_rqtc_rqtc5_insert(e10k_rqtc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rqtc5_insert(e10k_rqtc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff8fffff) | (0x700000 & (((e10k_rqtc_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_rqtc_rqtc6_extract(e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc6_extract(e10k_rqtc_t _regval)
{
    return((uint8_t )((_regval & 0x7000000) >> 24));
}

static inline e10k_rqtc_t e10k_rqtc_rqtc6_insert(e10k_rqtc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rqtc6_insert(e10k_rqtc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf8ffffff) | (0x7000000 & (((e10k_rqtc_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_rqtc_rqtc7_extract(e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc7_extract(e10k_rqtc_t _regval)
{
    return((uint8_t )((_regval & 0x70000000) >> 28));
}

static inline e10k_rqtc_t e10k_rqtc_rqtc7_insert(e10k_rqtc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rqtc7_insert(e10k_rqtc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x8fffffff) | (0x70000000 & (((e10k_rqtc_t )(_fieldval)) << 28)));
}

static inline int e10k_rqtc_prtval(char *_s, size_t _size, e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline int e10k_rqtc_prtval(char *_s, size_t _size, e10k_rqtc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc0 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC0)\n", e10k_rqtc_rqtc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc1 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC1)\n", e10k_rqtc_rqtc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc2 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC2)\n", e10k_rqtc_rqtc2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc3 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC3)\n", e10k_rqtc_rqtc3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc4 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC4)\n", e10k_rqtc_rqtc4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc5 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC5)\n", e10k_rqtc_rqtc5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc6 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC6)\n", e10k_rqtc_rqtc6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc7 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC7)\n", e10k_rqtc_rqtc7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rssrk_t
 * Description: Implicit type of RSS Random Key Register register array
 * Fields:
 *   key	(size 32, offset 0, init 0):	NOATTR	RSS Key Word n (bytes 4*n to 4*n+3) of the RSS random key
 */
typedef uint32_t e10k_rssrk_t;
#define e10k_rssrk_default 0x0
static inline uint32_t e10k_rssrk_key_extract(e10k_rssrk_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_rssrk_key_extract(e10k_rssrk_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_rssrk_t e10k_rssrk_key_insert(e10k_rssrk_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rssrk_t e10k_rssrk_key_insert(e10k_rssrk_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_rssrk_t )(_fieldval)) << 0)));
}

static inline int e10k_rssrk_prtval(char *_s, size_t _size, e10k_rssrk_t _regval) __attribute__ ((always_inline));
static inline int e10k_rssrk_prtval(char *_s, size_t _size, e10k_rssrk_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " key =\t%" PRIx32 "\t(RSS Key Word n (bytes 4*n to 4*n+3) of the RSS random key)\n", e10k_rssrk_key_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_reta_t
 * Description: Implicit type of Redirection Table register array
 * Fields:
 *   entry0	(size 4, offset 0, init 0):	NOATTR	RSS output index for hash value 4n+0
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   entry1	(size 4, offset 8, init 0):	NOATTR	RSS output index for hash value 4n+1
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   entry2	(size 4, offset 16, init 0):	NOATTR	RSS output index for hash value 4n+2
 *   _anon20	(size 4, offset 20, init 0):	RSVD	_
 *   entry3	(size 4, offset 24, init 0):	NOATTR	RSS output index for hash value 4n+3
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t e10k_reta_t;
#define e10k_reta_default 0x0
static inline uint8_t e10k_reta_entry0_extract(e10k_reta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_reta_entry0_extract(e10k_reta_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline e10k_reta_t e10k_reta_entry0_insert(e10k_reta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_reta_t e10k_reta_entry0_insert(e10k_reta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((e10k_reta_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_reta_entry1_extract(e10k_reta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_reta_entry1_extract(e10k_reta_t _regval)
{
    return((uint8_t )((_regval & 0xf00) >> 8));
}

static inline e10k_reta_t e10k_reta_entry1_insert(e10k_reta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_reta_t e10k_reta_entry1_insert(e10k_reta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((e10k_reta_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_reta_entry2_extract(e10k_reta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_reta_entry2_extract(e10k_reta_t _regval)
{
    return((uint8_t )((_regval & 0xf0000) >> 16));
}

static inline e10k_reta_t e10k_reta_entry2_insert(e10k_reta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_reta_t e10k_reta_entry2_insert(e10k_reta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((e10k_reta_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_reta_entry3_extract(e10k_reta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_reta_entry3_extract(e10k_reta_t _regval)
{
    return((uint8_t )((_regval & 0xf000000) >> 24));
}

static inline e10k_reta_t e10k_reta_entry3_insert(e10k_reta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_reta_t e10k_reta_entry3_insert(e10k_reta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((e10k_reta_t )(_fieldval)) << 24)));
}

static inline int e10k_reta_prtval(char *_s, size_t _size, e10k_reta_t _regval) __attribute__ ((always_inline));
static inline int e10k_reta_prtval(char *_s, size_t _size, e10k_reta_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry0 =\t%" PRIx8 "\t(RSS output index for hash value 4n+0)\n", e10k_reta_entry0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry1 =\t%" PRIx8 "\t(RSS output index for hash value 4n+1)\n", e10k_reta_entry1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry2 =\t%" PRIx8 "\t(RSS output index for hash value 4n+2)\n", e10k_reta_entry2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry3 =\t%" PRIx8 "\t(RSS output index for hash value 4n+3)\n", e10k_reta_entry3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_saqf_t
 * Description: Implicit type of Source Address Queue Filter register array
 * Fields:
 *   src_addr	(size 32, offset 0, init 0):	NOATTR	IP Source Address
 */
typedef uint32_t e10k_saqf_t;
#define e10k_saqf_default 0x0
static inline uint32_t e10k_saqf_src_addr_extract(e10k_saqf_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_saqf_src_addr_extract(e10k_saqf_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_saqf_t e10k_saqf_src_addr_insert(e10k_saqf_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_saqf_t e10k_saqf_src_addr_insert(e10k_saqf_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_saqf_t )(_fieldval)) << 0)));
}

static inline int e10k_saqf_prtval(char *_s, size_t _size, e10k_saqf_t _regval) __attribute__ ((always_inline));
static inline int e10k_saqf_prtval(char *_s, size_t _size, e10k_saqf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " src_addr =\t%" PRIx32 "\t(IP Source Address)\n", e10k_saqf_src_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_daqf_t
 * Description: Implicit type of Destination Address Queue Filter register array
 * Fields:
 *   dst_addr	(size 32, offset 0, init 0):	NOATTR	IP Destination Address
 */
typedef uint32_t e10k_daqf_t;
#define e10k_daqf_default 0x0
static inline uint32_t e10k_daqf_dst_addr_extract(e10k_daqf_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_daqf_dst_addr_extract(e10k_daqf_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_daqf_t e10k_daqf_dst_addr_insert(e10k_daqf_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_daqf_t e10k_daqf_dst_addr_insert(e10k_daqf_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_daqf_t )(_fieldval)) << 0)));
}

static inline int e10k_daqf_prtval(char *_s, size_t _size, e10k_daqf_t _regval) __attribute__ ((always_inline));
static inline int e10k_daqf_prtval(char *_s, size_t _size, e10k_daqf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_addr =\t%" PRIx32 "\t(IP Destination Address)\n", e10k_daqf_dst_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_sdpqf_t
 * Description: Implicit type of Source Destination Port Queue Filter register array
 * Fields:
 *   src_port	(size 16, offset 0, init 0):	NOATTR	TCP/UDP Source Port
 *   dst_port	(size 16, offset 16, init 0):	NOATTR	TCP/UDP Destination Port
 */
typedef uint32_t e10k_sdpqf_t;
#define e10k_sdpqf_default 0x0
static inline uint16_t e10k_sdpqf_src_port_extract(e10k_sdpqf_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_sdpqf_src_port_extract(e10k_sdpqf_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_sdpqf_t e10k_sdpqf_src_port_insert(e10k_sdpqf_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sdpqf_t e10k_sdpqf_src_port_insert(e10k_sdpqf_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_sdpqf_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_sdpqf_dst_port_extract(e10k_sdpqf_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_sdpqf_dst_port_extract(e10k_sdpqf_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_sdpqf_t e10k_sdpqf_dst_port_insert(e10k_sdpqf_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sdpqf_t e10k_sdpqf_dst_port_insert(e10k_sdpqf_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_sdpqf_t )(_fieldval)) << 16)));
}

static inline int e10k_sdpqf_prtval(char *_s, size_t _size, e10k_sdpqf_t _regval) __attribute__ ((always_inline));
static inline int e10k_sdpqf_prtval(char *_s, size_t _size, e10k_sdpqf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " src_port =\t%" PRIx16 "\t(TCP/UDP Source Port)\n", e10k_sdpqf_src_port_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_port =\t%" PRIx16 "\t(TCP/UDP Destination Port)\n", e10k_sdpqf_dst_port_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_ftqf_t
 * Description: Implicit type of Five tuple Queue Filter register array
 * Fields:
 *   protocol	(size 2, offset 0, init 0):	NOATTR	IP L4 protocol
 *   priority	(size 3, offset 2, init 0):	NOATTR	Priority value in case more than one 5-tuple filter matches
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   pool	(size 6, offset 8, init 0):	NOATTR	The pool Index of the pool associated with this filter
 *   _anon14	(size 11, offset 14, init 0):	MBZ	_
 *   m_srcaddr	(size 1, offset 25, init 0):	NOATTR	Mask source address comparison
 *   m_dstaddr	(size 1, offset 26, init 0):	NOATTR	Mask destination address comparison
 *   m_srcport	(size 1, offset 27, init 0):	NOATTR	Mask source port comparison
 *   m_dstport	(size 1, offset 28, init 0):	NOATTR	Mask destination port comparison
 *   m_protocol	(size 1, offset 29, init 0):	NOATTR	Mask protocol comparison
 *   pool_mask	(size 1, offset 30, init 0):	NOATTR	Mask bit for the Pool field
 *   queue_en	(size 1, offset 31, init 0):	NOATTR	Queue Enable
 */
typedef uint32_t e10k_ftqf_t;
#define e10k_ftqf_default 0x0
static inline e10k_l4_proto_t e10k_ftqf_protocol_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline e10k_l4_proto_t e10k_ftqf_protocol_extract(e10k_ftqf_t _regval)
{
    return((e10k_l4_proto_t )((_regval & 0x3) >> 0));
}

static inline e10k_ftqf_t e10k_ftqf_protocol_insert(e10k_ftqf_t _regval, e10k_l4_proto_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_protocol_insert(e10k_ftqf_t _regval, e10k_l4_proto_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e10k_ftqf_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_ftqf_priority_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_priority_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x1c) >> 2));
}

static inline e10k_ftqf_t e10k_ftqf_priority_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_priority_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe3) | (0x1c & (((e10k_ftqf_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_ftqf_pool_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_pool_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline e10k_ftqf_t e10k_ftqf_pool_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_pool_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((e10k_ftqf_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_ftqf_m_srcaddr_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_srcaddr_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_ftqf_t e10k_ftqf_m_srcaddr_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_m_srcaddr_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_ftqf_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_ftqf_m_dstaddr_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_dstaddr_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_ftqf_t e10k_ftqf_m_dstaddr_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_m_dstaddr_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_ftqf_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_ftqf_m_srcport_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_srcport_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_ftqf_t e10k_ftqf_m_srcport_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_m_srcport_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_ftqf_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_ftqf_m_dstport_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_dstport_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_ftqf_t e10k_ftqf_m_dstport_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_m_dstport_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_ftqf_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_ftqf_m_protocol_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_protocol_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_ftqf_t e10k_ftqf_m_protocol_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_m_protocol_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_ftqf_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_ftqf_pool_mask_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_pool_mask_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_ftqf_t e10k_ftqf_pool_mask_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_pool_mask_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_ftqf_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_ftqf_queue_en_extract(e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_queue_en_extract(e10k_ftqf_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_ftqf_t e10k_ftqf_queue_en_insert(e10k_ftqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_queue_en_insert(e10k_ftqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_ftqf_t )(_fieldval)) << 31)));
}

static inline int e10k_ftqf_prtval(char *_s, size_t _size, e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline int e10k_ftqf_prtval(char *_s, size_t _size, e10k_ftqf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " protocol =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_l4_proto_prtval(_s + _r, _avail, e10k_ftqf_protocol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IP L4 protocol)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority value in case more than one 5-tuple filter matches)\n", e10k_ftqf_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool =\t%" PRIx8 "\t(The pool Index of the pool associated with this filter)\n", e10k_ftqf_pool_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_srcaddr =\t%" PRIx8 "\t(Mask source address comparison)\n", e10k_ftqf_m_srcaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_dstaddr =\t%" PRIx8 "\t(Mask destination address comparison)\n", e10k_ftqf_m_dstaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_srcport =\t%" PRIx8 "\t(Mask source port comparison)\n", e10k_ftqf_m_srcport_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_dstport =\t%" PRIx8 "\t(Mask destination port comparison)\n", e10k_ftqf_m_dstport_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_protocol =\t%" PRIx8 "\t(Mask protocol comparison)\n", e10k_ftqf_m_protocol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool_mask =\t%" PRIx8 "\t(Mask bit for the Pool field)\n", e10k_ftqf_pool_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_en =\t%" PRIx8 "\t(Queue Enable)\n", e10k_ftqf_queue_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_synqf_t
 * Description: Implicit type of SYN Packet Queue Filter register
 * Fields:
 *   queue_en	(size 1, offset 0, init 0):	RW	Queue Enable
 *   rx_queue	(size 7, offset 1, init 0):	RW	Identifies an Rx queue associated with SYN packets
 *   _anon8	(size 23, offset 8, init 0):	RSVD	_
 *   synqfp	(size 1, offset 31, init 0):	RW	Defines the priority between SYNQF and 5-tuples filter
 */
typedef uint32_t e10k_synqf_t;
#define e10k_synqf_default 0x0
static inline uint8_t e10k_synqf_queue_en_extract(e10k_synqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_synqf_queue_en_extract(e10k_synqf_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_synqf_t e10k_synqf_queue_en_insert(e10k_synqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_synqf_t e10k_synqf_queue_en_insert(e10k_synqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_synqf_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_synqf_rx_queue_extract(e10k_synqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_synqf_rx_queue_extract(e10k_synqf_t _regval)
{
    return((uint8_t )((_regval & 0xfe) >> 1));
}

static inline e10k_synqf_t e10k_synqf_rx_queue_insert(e10k_synqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_synqf_t e10k_synqf_rx_queue_insert(e10k_synqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff01) | (0xfe & (((e10k_synqf_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_synqf_synqfp_extract(e10k_synqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_synqf_synqfp_extract(e10k_synqf_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_synqf_t e10k_synqf_synqfp_insert(e10k_synqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_synqf_t e10k_synqf_synqfp_insert(e10k_synqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_synqf_t )(_fieldval)) << 31)));
}

static inline int e10k_synqf_prtval(char *_s, size_t _size, e10k_synqf_t _regval) __attribute__ ((always_inline));
static inline int e10k_synqf_prtval(char *_s, size_t _size, e10k_synqf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_en =\t%" PRIx8 "\t(Queue Enable)\n", e10k_synqf_queue_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_queue =\t%" PRIx8 "\t(Identifies an Rx queue associated with SYN packets)\n", e10k_synqf_rx_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " synqfp =\t%" PRIx8 "\t(Defines the priority between SYNQF and 5-tuples filter)\n", e10k_synqf_synqfp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_etqf_t
 * Description: Implicit type of EType Queue Filter register array
 * Fields:
 *   etype	(size 16, offset 0, init 0):	NOATTR	Identifies the protocol running on top of IEEE 802
 *   uprio	(size 3, offset 16, init 0):	NOATTR	User Priority
 *   uprio_en	(size 1, offset 19, init 0):	NOATTR	User Priority Enable
 *   pool	(size 6, offset 20, init 0):	NOATTR	Determines the target pool for the packet
 *   pool_en	(size 1, offset 26, init 0):	NOATTR	Pool Enable
 *   fcoe	(size 1, offset 27, init 0):	NOATTR	FCoE
 *   _anon28	(size 2, offset 28, init 0):	RSVD	_
 *   timestamp	(size 1, offset 30, init 0):	NOATTR	IEEE 1588 time stamp
 *   filter_en	(size 1, offset 31, init 0):	NOATTR	Filter Enable
 */
typedef uint32_t e10k_etqf_t;
#define e10k_etqf_default 0x0
static inline uint16_t e10k_etqf_etype_extract(e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_etqf_etype_extract(e10k_etqf_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_etqf_t e10k_etqf_etype_insert(e10k_etqf_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_etype_insert(e10k_etqf_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_etqf_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_etqf_uprio_extract(e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_uprio_extract(e10k_etqf_t _regval)
{
    return((uint8_t )((_regval & 0x70000) >> 16));
}

static inline e10k_etqf_t e10k_etqf_uprio_insert(e10k_etqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_uprio_insert(e10k_etqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((e10k_etqf_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_etqf_uprio_en_extract(e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_uprio_en_extract(e10k_etqf_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_etqf_t e10k_etqf_uprio_en_insert(e10k_etqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_uprio_en_insert(e10k_etqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_etqf_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_etqf_pool_extract(e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_pool_extract(e10k_etqf_t _regval)
{
    return((uint8_t )((_regval & 0x3f00000) >> 20));
}

static inline e10k_etqf_t e10k_etqf_pool_insert(e10k_etqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_pool_insert(e10k_etqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfc0fffff) | (0x3f00000 & (((e10k_etqf_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_etqf_pool_en_extract(e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_pool_en_extract(e10k_etqf_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_etqf_t e10k_etqf_pool_en_insert(e10k_etqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_pool_en_insert(e10k_etqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_etqf_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_etqf_fcoe_extract(e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_fcoe_extract(e10k_etqf_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_etqf_t e10k_etqf_fcoe_insert(e10k_etqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_fcoe_insert(e10k_etqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_etqf_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_etqf_timestamp_extract(e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_timestamp_extract(e10k_etqf_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_etqf_t e10k_etqf_timestamp_insert(e10k_etqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_timestamp_insert(e10k_etqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_etqf_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_etqf_filter_en_extract(e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_filter_en_extract(e10k_etqf_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_etqf_t e10k_etqf_filter_en_insert(e10k_etqf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_filter_en_insert(e10k_etqf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_etqf_t )(_fieldval)) << 31)));
}

static inline int e10k_etqf_prtval(char *_s, size_t _size, e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline int e10k_etqf_prtval(char *_s, size_t _size, e10k_etqf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " etype =\t%" PRIx16 "\t(Identifies the protocol running on top of IEEE 802)\n", e10k_etqf_etype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uprio =\t%" PRIx8 "\t(User Priority)\n", e10k_etqf_uprio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uprio_en =\t%" PRIx8 "\t(User Priority Enable)\n", e10k_etqf_uprio_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool =\t%" PRIx8 "\t(Determines the target pool for the packet)\n", e10k_etqf_pool_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool_en =\t%" PRIx8 "\t(Pool Enable)\n", e10k_etqf_pool_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcoe =\t%" PRIx8 "\t(FCoE)\n", e10k_etqf_fcoe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " timestamp =\t%" PRIx8 "\t(IEEE 1588 time stamp)\n", e10k_etqf_timestamp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " filter_en =\t%" PRIx8 "\t(Filter Enable)\n", e10k_etqf_filter_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_etqs_t
 * Description: Implicit type of EType Queue Select register array
 * Fields:
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   rx_queue	(size 7, offset 16, init 0):	NOATTR	Identifies the Rx queue associated with this EType
 *   _anon23	(size 6, offset 23, init 0):	RSVD	_
 *   lli	(size 1, offset 29, init 0):	NOATTR	When set, packets that match this filter generate a LLI
 *   _anon30	(size 1, offset 30, init 0):	RSVD	_
 *   queue_en	(size 1, offset 31, init 0):	NOATTR	Queue Enable
 */
typedef uint32_t e10k_etqs_t;
#define e10k_etqs_default 0x0
static inline uint8_t e10k_etqs_rx_queue_extract(e10k_etqs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqs_rx_queue_extract(e10k_etqs_t _regval)
{
    return((uint8_t )((_regval & 0x7f0000) >> 16));
}

static inline e10k_etqs_t e10k_etqs_rx_queue_insert(e10k_etqs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqs_t e10k_etqs_rx_queue_insert(e10k_etqs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff80ffff) | (0x7f0000 & (((e10k_etqs_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_etqs_lli_extract(e10k_etqs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqs_lli_extract(e10k_etqs_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_etqs_t e10k_etqs_lli_insert(e10k_etqs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqs_t e10k_etqs_lli_insert(e10k_etqs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_etqs_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_etqs_queue_en_extract(e10k_etqs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_etqs_queue_en_extract(e10k_etqs_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_etqs_t e10k_etqs_queue_en_insert(e10k_etqs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_etqs_t e10k_etqs_queue_en_insert(e10k_etqs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_etqs_t )(_fieldval)) << 31)));
}

static inline int e10k_etqs_prtval(char *_s, size_t _size, e10k_etqs_t _regval) __attribute__ ((always_inline));
static inline int e10k_etqs_prtval(char *_s, size_t _size, e10k_etqs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_queue =\t%" PRIx8 "\t(Identifies the Rx queue associated with this EType)\n", e10k_etqs_rx_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli =\t%" PRIx8 "\t(When set, packets that match this filter generate a LLI)\n", e10k_etqs_lli_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_en =\t%" PRIx8 "\t(Queue Enable)\n", e10k_etqs_queue_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rxfeccerr0_t
 * Description: Implicit type of Rx Filter ECC Err Insertion 0 register
 * Fields:
 *   _anon0	(size 9, offset 0, init 0):	RSVD	_
 *   eccflt_en	(size 1, offset 9, init 0):	RW	Filter ECC Error indication Enablement
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
typedef uint32_t e10k_rxfeccerr0_t;
#define e10k_rxfeccerr0_default 0x0
static inline uint8_t e10k_rxfeccerr0_eccflt_en_extract(e10k_rxfeccerr0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxfeccerr0_eccflt_en_extract(e10k_rxfeccerr0_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_rxfeccerr0_t e10k_rxfeccerr0_eccflt_en_insert(e10k_rxfeccerr0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxfeccerr0_t e10k_rxfeccerr0_eccflt_en_insert(e10k_rxfeccerr0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_rxfeccerr0_t )(_fieldval)) << 9)));
}

static inline int e10k_rxfeccerr0_prtval(char *_s, size_t _size, e10k_rxfeccerr0_t _regval) __attribute__ ((always_inline));
static inline int e10k_rxfeccerr0_prtval(char *_s, size_t _size, e10k_rxfeccerr0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eccflt_en =\t%" PRIx8 "\t(Filter ECC Error indication Enablement)\n", e10k_rxfeccerr0_eccflt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rxdctl_t
 * Description: Receive Descriptor Control
 * Fields:
 *   _anon0	(size 25, offset 0, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	NOATTR	Receive Queue Enable
 *   _anon26	(size 4, offset 26, init 0):	RSVD	_
 *   vme	(size 1, offset 30, init 0):	NOATTR	VLAN Mode Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_rxdctl_t;
#define e10k_rxdctl_default 0x0
static inline uint8_t e10k_rxdctl_enable_extract(e10k_rxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxdctl_enable_extract(e10k_rxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_rxdctl_t e10k_rxdctl_enable_insert(e10k_rxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxdctl_t e10k_rxdctl_enable_insert(e10k_rxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_rxdctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_rxdctl_vme_extract(e10k_rxdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxdctl_vme_extract(e10k_rxdctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_rxdctl_t e10k_rxdctl_vme_insert(e10k_rxdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxdctl_t e10k_rxdctl_vme_insert(e10k_rxdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_rxdctl_t )(_fieldval)) << 30)));
}

static inline int e10k_rxdctl_prtval(char *_s, size_t _size, e10k_rxdctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_rxdctl_prtval(char *_s, size_t _size, e10k_rxdctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Receive Queue Enable)\n", e10k_rxdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN Mode Enable)\n", e10k_rxdctl_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_srrctl_t
 * Description: Split Receive Control Registers
 * Fields:
 *   bsz_pkt	(size 5, offset 0, init 0):	NOATTR	Receive Buffer Size for Packet Buffer
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   bsz_hdr	(size 6, offset 8, init 0):	NOATTR	Receive Buffer Size for Header Buffer
 *   _anon14	(size 8, offset 14, init 0):	RSVD	_
 *   rdmts	(size 3, offset 22, init 0):	NOATTR	Receive Descriptor Minimum Threshold Size
 *   desctype	(size 3, offset 25, init 0):	NOATTR	Define the descriptor type
 *   drop_en	(size 1, offset 28, init 0):	NOATTR	Drop Enabled
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
typedef uint32_t e10k_srrctl_t;
#define e10k_srrctl_default 0x0
static inline uint8_t e10k_srrctl_bsz_pkt_extract(e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_bsz_pkt_extract(e10k_srrctl_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline e10k_srrctl_t e10k_srrctl_bsz_pkt_insert(e10k_srrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_bsz_pkt_insert(e10k_srrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((e10k_srrctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_srrctl_bsz_hdr_extract(e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_bsz_hdr_extract(e10k_srrctl_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline e10k_srrctl_t e10k_srrctl_bsz_hdr_insert(e10k_srrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_bsz_hdr_insert(e10k_srrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((e10k_srrctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_srrctl_rdmts_extract(e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_rdmts_extract(e10k_srrctl_t _regval)
{
    return((uint8_t )((_regval & 0x1c00000) >> 22));
}

static inline e10k_srrctl_t e10k_srrctl_rdmts_insert(e10k_srrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_rdmts_insert(e10k_srrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfe3fffff) | (0x1c00000 & (((e10k_srrctl_t )(_fieldval)) << 22)));
}

static inline e10k_rx_desctype_t e10k_srrctl_desctype_extract(e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline e10k_rx_desctype_t e10k_srrctl_desctype_extract(e10k_srrctl_t _regval)
{
    return((e10k_rx_desctype_t )((_regval & 0xe000000) >> 25));
}

static inline e10k_srrctl_t e10k_srrctl_desctype_insert(e10k_srrctl_t _regval, e10k_rx_desctype_t _fieldval) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_desctype_insert(e10k_srrctl_t _regval, e10k_rx_desctype_t _fieldval)
{
    return((_regval & 0xf1ffffff) | (0xe000000 & (((e10k_srrctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_srrctl_drop_en_extract(e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_drop_en_extract(e10k_srrctl_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_srrctl_t e10k_srrctl_drop_en_insert(e10k_srrctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_drop_en_insert(e10k_srrctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_srrctl_t )(_fieldval)) << 28)));
}

static inline int e10k_srrctl_prtval(char *_s, size_t _size, e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_srrctl_prtval(char *_s, size_t _size, e10k_srrctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_pkt =\t%" PRIx8 "\t(Receive Buffer Size for Packet Buffer)\n", e10k_srrctl_bsz_pkt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_hdr =\t%" PRIx8 "\t(Receive Buffer Size for Header Buffer)\n", e10k_srrctl_bsz_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdmts =\t%" PRIx8 "\t(Receive Descriptor Minimum Threshold Size)\n", e10k_srrctl_rdmts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desctype =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rx_desctype_prtval(_s + _r, _avail, e10k_srrctl_desctype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Define the descriptor type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop_en =\t%" PRIx8 "\t(Drop Enabled)\n", e10k_srrctl_drop_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rdrxctl_t
 * Description: Implicit type of Receive DMA Control Register register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   crcstrip	(size 1, offset 1, init 0):	RW	Rx CRC Strip indication to the Rx DMA unit
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   dma_initok	(size 1, offset 3, init 0):	RO	DMA Init Done
 *   _anon4	(size 13, offset 4, init 0):	RSVD	_
 *   rscfrstsz	(size 5, offset 17, init 0):	MBZ	Defines a minimum packet size for a RSC packet
 *   _anon22	(size 3, offset 22, init 0):	RSVD	_
 *   rscackc	(size 1, offset 25, init 1):	MB1	RSC Coalescing on ACK Change
 *   fcoe_wrfix	(size 1, offset 26, init 1):	MB1	FCoE Write Exchange Fix
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t e10k_rdrxctl_t;
#define e10k_rdrxctl_default 0x6000000
static inline uint8_t e10k_rdrxctl_crcstrip_extract(e10k_rdrxctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rdrxctl_crcstrip_extract(e10k_rdrxctl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_rdrxctl_t e10k_rdrxctl_crcstrip_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rdrxctl_t e10k_rdrxctl_crcstrip_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_rdrxctl_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_rdrxctl_dma_initok_extract(e10k_rdrxctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rdrxctl_dma_initok_extract(e10k_rdrxctl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_rdrxctl_t e10k_rdrxctl_dma_initok_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rdrxctl_t e10k_rdrxctl_dma_initok_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_rdrxctl_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_rdrxctl_rscfrstsz_extract(e10k_rdrxctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rdrxctl_rscfrstsz_extract(e10k_rdrxctl_t _regval)
{
    return((uint8_t )((_regval & 0x3e0000) >> 17));
}

static inline e10k_rdrxctl_t e10k_rdrxctl_rscfrstsz_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rdrxctl_t e10k_rdrxctl_rscfrstsz_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffc1ffff) | (0x3e0000 & (((e10k_rdrxctl_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_rdrxctl_rscackc_extract(e10k_rdrxctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rdrxctl_rscackc_extract(e10k_rdrxctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_rdrxctl_t e10k_rdrxctl_rscackc_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rdrxctl_t e10k_rdrxctl_rscackc_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_rdrxctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_rdrxctl_fcoe_wrfix_extract(e10k_rdrxctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rdrxctl_fcoe_wrfix_extract(e10k_rdrxctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_rdrxctl_t e10k_rdrxctl_fcoe_wrfix_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rdrxctl_t e10k_rdrxctl_fcoe_wrfix_insert(e10k_rdrxctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_rdrxctl_t )(_fieldval)) << 26)));
}

static inline int e10k_rdrxctl_prtval(char *_s, size_t _size, e10k_rdrxctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_rdrxctl_prtval(char *_s, size_t _size, e10k_rdrxctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crcstrip =\t%" PRIx8 "\t(Rx CRC Strip indication to the Rx DMA unit)\n", e10k_rdrxctl_crcstrip_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_initok =\t%" PRIx8 "\t(DMA Init Done)\n", e10k_rdrxctl_dma_initok_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rscfrstsz =\t%" PRIx8 "\t(Defines a minimum packet size for a RSC packet)\n", e10k_rdrxctl_rscfrstsz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rscackc =\t%" PRIx8 "\t(RSC Coalescing on ACK Change)\n", e10k_rdrxctl_rscackc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcoe_wrfix =\t%" PRIx8 "\t(FCoE Write Exchange Fix)\n", e10k_rdrxctl_fcoe_wrfix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rxpbsize_t
 * Description: Implicit type of Receive Packet Buffer Size register array
 * Fields:
 *   _anon0	(size 10, offset 0, init 0):	RSVD	_
 *   size	(size 10, offset 10, init 0):	NOATTR	Receive Packet Buffer Size for traffic class n
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t e10k_rxpbsize_t;
#define e10k_rxpbsize_default 0x0
static inline uint16_t e10k_rxpbsize_size_extract(e10k_rxpbsize_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rxpbsize_size_extract(e10k_rxpbsize_t _regval)
{
    return((uint16_t )((_regval & 0xffc00) >> 10));
}

static inline e10k_rxpbsize_t e10k_rxpbsize_size_insert(e10k_rxpbsize_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxpbsize_t e10k_rxpbsize_size_insert(e10k_rxpbsize_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfff003ff) | (0xffc00 & (((e10k_rxpbsize_t )(_fieldval)) << 10)));
}

static inline int e10k_rxpbsize_prtval(char *_s, size_t _size, e10k_rxpbsize_t _regval) __attribute__ ((always_inline));
static inline int e10k_rxpbsize_prtval(char *_s, size_t _size, e10k_rxpbsize_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Receive Packet Buffer Size for traffic class n)\n", e10k_rxpbsize_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rxctrl_t
 * Description: Implicit type of Receive Control Register register
 * Fields:
 *   rxen	(size 1, offset 0, init 0):	RW	Receive Enable
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
typedef uint32_t e10k_rxctrl_t;
#define e10k_rxctrl_default 0x0
static inline uint8_t e10k_rxctrl_rxen_extract(e10k_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxctrl_rxen_extract(e10k_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_rxctrl_t e10k_rxctrl_rxen_insert(e10k_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxctrl_t e10k_rxctrl_rxen_insert(e10k_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_rxctrl_t )(_fieldval)) << 0)));
}

static inline int e10k_rxctrl_prtval(char *_s, size_t _size, e10k_rxctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_rxctrl_prtval(char *_s, size_t _size, e10k_rxctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxen =\t%" PRIx8 "\t(Receive Enable)\n", e10k_rxctrl_rxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rxmemwrap_t
 * Description: Implicit type of Rx Packet Buffer Flush Detect register
 * Fields:
 *   tc0_wrap	(size 3, offset 0, init 0):	RO	Packet Buffer 0 Wrap Around Counter
 *   tc0_empty	(size 1, offset 3, init 0):	RO	Packet Buffer 0 Empty
 *   tc1_wrap	(size 3, offset 4, init 0):	RO	Packet Buffer 1 Wrap Around Counter
 *   tc1_empty	(size 1, offset 7, init 0):	RO	Packet Buffer 1 Empty
 *   tc2_wrap	(size 3, offset 8, init 0):	RO	Packet Buffer 2 Wrap Around Counter
 *   tc2_empty	(size 1, offset 11, init 0):	RO	Packet Buffer 2 Empty
 *   tc3_wrap	(size 3, offset 12, init 0):	RO	Packet Buffer 3 Wrap Around Counter
 *   tc3_empty	(size 1, offset 15, init 0):	RO	Packet Buffer 3 Empty
 *   tc4_wrap	(size 3, offset 16, init 0):	RO	Packet Buffer 4 Wrap Around Counter
 *   tc4_empty	(size 1, offset 19, init 0):	RO	Packet Buffer 4 Empty
 *   tc5_wrap	(size 3, offset 20, init 0):	RO	Packet Buffer 5 Wrap Around Counter
 *   tc5_empty	(size 1, offset 23, init 0):	RO	Packet Buffer 5 Empty
 *   tc6_wrap	(size 3, offset 24, init 0):	RO	Packet Buffer 6 Wrap Around Counter
 *   tc6_empty	(size 1, offset 27, init 0):	RO	Packet Buffer 6 Empty
 *   tc7_wrap	(size 3, offset 28, init 0):	RO	Packet Buffer 7 Wrap Around Counter
 *   tc7_empty	(size 1, offset 31, init 0):	RO	Packet Buffer 7 Empty
 */
typedef uint32_t e10k_rxmemwrap_t;
#define e10k_rxmemwrap_default 0x0
static inline uint8_t e10k_rxmemwrap_tc0_wrap_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc0_wrap_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc0_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc0_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_rxmemwrap_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rxmemwrap_tc0_empty_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc0_empty_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc0_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc0_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_rxmemwrap_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_rxmemwrap_tc1_wrap_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc1_wrap_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x70) >> 4));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc1_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc1_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff8f) | (0x70 & (((e10k_rxmemwrap_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_rxmemwrap_tc1_empty_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc1_empty_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc1_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc1_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_rxmemwrap_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_rxmemwrap_tc2_wrap_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc2_wrap_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x700) >> 8));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc2_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc2_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff8ff) | (0x700 & (((e10k_rxmemwrap_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_rxmemwrap_tc2_empty_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc2_empty_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc2_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc2_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_rxmemwrap_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_rxmemwrap_tc3_wrap_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc3_wrap_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x7000) >> 12));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc3_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc3_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff8fff) | (0x7000 & (((e10k_rxmemwrap_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_rxmemwrap_tc3_empty_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc3_empty_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc3_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc3_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_rxmemwrap_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_rxmemwrap_tc4_wrap_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc4_wrap_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x70000) >> 16));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc4_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc4_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((e10k_rxmemwrap_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_rxmemwrap_tc4_empty_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc4_empty_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc4_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc4_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_rxmemwrap_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_rxmemwrap_tc5_wrap_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc5_wrap_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x700000) >> 20));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc5_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc5_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff8fffff) | (0x700000 & (((e10k_rxmemwrap_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_rxmemwrap_tc5_empty_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc5_empty_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc5_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc5_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_rxmemwrap_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_rxmemwrap_tc6_wrap_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc6_wrap_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x7000000) >> 24));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc6_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc6_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf8ffffff) | (0x7000000 & (((e10k_rxmemwrap_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_rxmemwrap_tc6_empty_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc6_empty_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc6_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc6_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_rxmemwrap_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_rxmemwrap_tc7_wrap_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc7_wrap_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x70000000) >> 28));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc7_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc7_wrap_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x8fffffff) | (0x70000000 & (((e10k_rxmemwrap_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_rxmemwrap_tc7_empty_extract(e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc7_empty_extract(e10k_rxmemwrap_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc7_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_tc7_empty_insert(e10k_rxmemwrap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_rxmemwrap_t )(_fieldval)) << 31)));
}

static inline int e10k_rxmemwrap_prtval(char *_s, size_t _size, e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline int e10k_rxmemwrap_prtval(char *_s, size_t _size, e10k_rxmemwrap_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc0_wrap =\t%" PRIx8 "\t(Packet Buffer 0 Wrap Around Counter)\n", e10k_rxmemwrap_tc0_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc0_empty =\t%" PRIx8 "\t(Packet Buffer 0 Empty)\n", e10k_rxmemwrap_tc0_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc1_wrap =\t%" PRIx8 "\t(Packet Buffer 1 Wrap Around Counter)\n", e10k_rxmemwrap_tc1_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc1_empty =\t%" PRIx8 "\t(Packet Buffer 1 Empty)\n", e10k_rxmemwrap_tc1_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc2_wrap =\t%" PRIx8 "\t(Packet Buffer 2 Wrap Around Counter)\n", e10k_rxmemwrap_tc2_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc2_empty =\t%" PRIx8 "\t(Packet Buffer 2 Empty)\n", e10k_rxmemwrap_tc2_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc3_wrap =\t%" PRIx8 "\t(Packet Buffer 3 Wrap Around Counter)\n", e10k_rxmemwrap_tc3_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc3_empty =\t%" PRIx8 "\t(Packet Buffer 3 Empty)\n", e10k_rxmemwrap_tc3_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc4_wrap =\t%" PRIx8 "\t(Packet Buffer 4 Wrap Around Counter)\n", e10k_rxmemwrap_tc4_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc4_empty =\t%" PRIx8 "\t(Packet Buffer 4 Empty)\n", e10k_rxmemwrap_tc4_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc5_wrap =\t%" PRIx8 "\t(Packet Buffer 5 Wrap Around Counter)\n", e10k_rxmemwrap_tc5_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc5_empty =\t%" PRIx8 "\t(Packet Buffer 5 Empty)\n", e10k_rxmemwrap_tc5_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc6_wrap =\t%" PRIx8 "\t(Packet Buffer 6 Wrap Around Counter)\n", e10k_rxmemwrap_tc6_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc6_empty =\t%" PRIx8 "\t(Packet Buffer 6 Empty)\n", e10k_rxmemwrap_tc6_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc7_wrap =\t%" PRIx8 "\t(Packet Buffer 7 Wrap Around Counter)\n", e10k_rxmemwrap_tc7_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc7_empty =\t%" PRIx8 "\t(Packet Buffer 7 Empty)\n", e10k_rxmemwrap_tc7_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rscdbu_t
 * Description: Implicit type of RSC Data Buffer Control Register register
 * Fields:
 *   _anon0	(size 7, offset 0, init 0):	RSVD	_
 *   rscackdis	(size 1, offset 7, init 0):	RW	Disable RSC for ACK packets
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t e10k_rscdbu_t;
#define e10k_rscdbu_default 0x0
static inline uint8_t e10k_rscdbu_rscackdis_extract(e10k_rscdbu_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rscdbu_rscackdis_extract(e10k_rscdbu_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_rscdbu_t e10k_rscdbu_rscackdis_insert(e10k_rscdbu_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rscdbu_t e10k_rscdbu_rscackdis_insert(e10k_rscdbu_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_rscdbu_t )(_fieldval)) << 7)));
}

static inline int e10k_rscdbu_prtval(char *_s, size_t _size, e10k_rscdbu_t _regval) __attribute__ ((always_inline));
static inline int e10k_rscdbu_prtval(char *_s, size_t _size, e10k_rscdbu_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rscackdis =\t%" PRIx8 "\t(Disable RSC for ACK packets)\n", e10k_rscdbu_rscackdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rscctl_t
 * Description: RSC Control
 * Fields:
 *   rsc_en	(size 1, offset 0, init 0):	NOATTR	RSC Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   maxdesc	(size 2, offset 2, init 0):	NOATTR	Maximum descriptors per Large receive
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
typedef uint32_t e10k_rscctl_t;
#define e10k_rscctl_default 0x0
static inline uint8_t e10k_rscctl_rsc_en_extract(e10k_rscctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rscctl_rsc_en_extract(e10k_rscctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_rscctl_t e10k_rscctl_rsc_en_insert(e10k_rscctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rscctl_t e10k_rscctl_rsc_en_insert(e10k_rscctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_rscctl_t )(_fieldval)) << 0)));
}

static inline e10k_rsc_maxdesc_t e10k_rscctl_maxdesc_extract(e10k_rscctl_t _regval) __attribute__ ((always_inline));
static inline e10k_rsc_maxdesc_t e10k_rscctl_maxdesc_extract(e10k_rscctl_t _regval)
{
    return((e10k_rsc_maxdesc_t )((_regval & 0xc) >> 2));
}

static inline e10k_rscctl_t e10k_rscctl_maxdesc_insert(e10k_rscctl_t _regval, e10k_rsc_maxdesc_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rscctl_t e10k_rscctl_maxdesc_insert(e10k_rscctl_t _regval, e10k_rsc_maxdesc_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((e10k_rscctl_t )(_fieldval)) << 2)));
}

static inline int e10k_rscctl_prtval(char *_s, size_t _size, e10k_rscctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_rscctl_prtval(char *_s, size_t _size, e10k_rscctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_en =\t%" PRIx8 "\t(RSC Enable)\n", e10k_rscctl_rsc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxdesc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rsc_maxdesc_prtval(_s + _r, _avail, e10k_rscctl_maxdesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Maximum descriptors per Large receive)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_dtxmxszrq_t
 * Description: Implicit type of DMA Tx TCP Max Allow Size Requests register
 * Fields:
 *   max_bytes	(size 12, offset 0, init 0):	RW	Max allowed number of bytes requests
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
typedef uint32_t e10k_dtxmxszrq_t;
#define e10k_dtxmxszrq_default 0x0
static inline uint16_t e10k_dtxmxszrq_max_bytes_extract(e10k_dtxmxszrq_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_dtxmxszrq_max_bytes_extract(e10k_dtxmxszrq_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e10k_dtxmxszrq_t e10k_dtxmxszrq_max_bytes_insert(e10k_dtxmxszrq_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dtxmxszrq_t e10k_dtxmxszrq_max_bytes_insert(e10k_dtxmxszrq_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e10k_dtxmxszrq_t )(_fieldval)) << 0)));
}

static inline int e10k_dtxmxszrq_prtval(char *_s, size_t _size, e10k_dtxmxszrq_t _regval) __attribute__ ((always_inline));
static inline int e10k_dtxmxszrq_prtval(char *_s, size_t _size, e10k_dtxmxszrq_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max_bytes =\t%" PRIx16 "\t(Max allowed number of bytes requests)\n", e10k_dtxmxszrq_max_bytes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_dmatxctl_t
 * Description: Implicit type of DMA Tx Control register
 * Fields:
 *   txen	(size 1, offset 0, init 0):	RW	Transmit Enable
 *   _anon1	(size 2, offset 1, init 0):	RSVD	_
 *   gdv	(size 1, offset 3, init 0):	RW	Global Double VLAN Mode
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   vlet	(size 16, offset 16, init 0):	RW	VLAN Ether-Type
 */
typedef uint32_t e10k_dmatxctl_t;
#define e10k_dmatxctl_default 0x0
static inline uint8_t e10k_dmatxctl_txen_extract(e10k_dmatxctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dmatxctl_txen_extract(e10k_dmatxctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_dmatxctl_t e10k_dmatxctl_txen_insert(e10k_dmatxctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dmatxctl_t e10k_dmatxctl_txen_insert(e10k_dmatxctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_dmatxctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_dmatxctl_gdv_extract(e10k_dmatxctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dmatxctl_gdv_extract(e10k_dmatxctl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_dmatxctl_t e10k_dmatxctl_gdv_insert(e10k_dmatxctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dmatxctl_t e10k_dmatxctl_gdv_insert(e10k_dmatxctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_dmatxctl_t )(_fieldval)) << 3)));
}

static inline uint16_t e10k_dmatxctl_vlet_extract(e10k_dmatxctl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_dmatxctl_vlet_extract(e10k_dmatxctl_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_dmatxctl_t e10k_dmatxctl_vlet_insert(e10k_dmatxctl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dmatxctl_t e10k_dmatxctl_vlet_insert(e10k_dmatxctl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_dmatxctl_t )(_fieldval)) << 16)));
}

static inline int e10k_dmatxctl_prtval(char *_s, size_t _size, e10k_dmatxctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_dmatxctl_prtval(char *_s, size_t _size, e10k_dmatxctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txen =\t%" PRIx8 "\t(Transmit Enable)\n", e10k_dmatxctl_txen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gdv =\t%" PRIx8 "\t(Global Double VLAN Mode)\n", e10k_dmatxctl_gdv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlet =\t%" PRIx16 "\t(VLAN Ether-Type)\n", e10k_dmatxctl_vlet_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_dtxtcpflgl_t
 * Description: Implicit type of DMA Tx TCP Flags Control Low register
 * Fields:
 *   tcp_flgfsts	(size 12, offset 0, init 0):	RW	TCP Flags First Segment
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   tcp_flgmdls	(size 12, offset 16, init 0):	RW	TCP Flags Middle Segments
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t e10k_dtxtcpflgl_t;
#define e10k_dtxtcpflgl_default 0x0
static inline uint16_t e10k_dtxtcpflgl_tcp_flgfsts_extract(e10k_dtxtcpflgl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_dtxtcpflgl_tcp_flgfsts_extract(e10k_dtxtcpflgl_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e10k_dtxtcpflgl_t e10k_dtxtcpflgl_tcp_flgfsts_insert(e10k_dtxtcpflgl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dtxtcpflgl_t e10k_dtxtcpflgl_tcp_flgfsts_insert(e10k_dtxtcpflgl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e10k_dtxtcpflgl_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_dtxtcpflgl_tcp_flgmdls_extract(e10k_dtxtcpflgl_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_dtxtcpflgl_tcp_flgmdls_extract(e10k_dtxtcpflgl_t _regval)
{
    return((uint16_t )((_regval & 0xfff0000) >> 16));
}

static inline e10k_dtxtcpflgl_t e10k_dtxtcpflgl_tcp_flgmdls_insert(e10k_dtxtcpflgl_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dtxtcpflgl_t e10k_dtxtcpflgl_tcp_flgmdls_insert(e10k_dtxtcpflgl_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xf000ffff) | (0xfff0000 & (((e10k_dtxtcpflgl_t )(_fieldval)) << 16)));
}

static inline int e10k_dtxtcpflgl_prtval(char *_s, size_t _size, e10k_dtxtcpflgl_t _regval) __attribute__ ((always_inline));
static inline int e10k_dtxtcpflgl_prtval(char *_s, size_t _size, e10k_dtxtcpflgl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_flgfsts =\t%" PRIx16 "\t(TCP Flags First Segment)\n", e10k_dtxtcpflgl_tcp_flgfsts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_flgmdls =\t%" PRIx16 "\t(TCP Flags Middle Segments)\n", e10k_dtxtcpflgl_tcp_flgmdls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_dtxtcpflgh_t
 * Description: Implicit type of DMA Tx TCP Flags Control High register
 * Fields:
 *   tcp_flglsts	(size 12, offset 0, init 0):	RW	TCP Flags Last Segment
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
typedef uint32_t e10k_dtxtcpflgh_t;
#define e10k_dtxtcpflgh_default 0x0
static inline uint16_t e10k_dtxtcpflgh_tcp_flglsts_extract(e10k_dtxtcpflgh_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_dtxtcpflgh_tcp_flglsts_extract(e10k_dtxtcpflgh_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e10k_dtxtcpflgh_t e10k_dtxtcpflgh_tcp_flglsts_insert(e10k_dtxtcpflgh_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dtxtcpflgh_t e10k_dtxtcpflgh_tcp_flglsts_insert(e10k_dtxtcpflgh_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e10k_dtxtcpflgh_t )(_fieldval)) << 0)));
}

static inline int e10k_dtxtcpflgh_prtval(char *_s, size_t _size, e10k_dtxtcpflgh_t _regval) __attribute__ ((always_inline));
static inline int e10k_dtxtcpflgh_prtval(char *_s, size_t _size, e10k_dtxtcpflgh_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_flglsts =\t%" PRIx16 "\t(TCP Flags Last Segment)\n", e10k_dtxtcpflgh_tcp_flglsts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_txdctl_t
 * Description: Implicit type of Transmit Descriptor Control register array
 * Fields:
 *   pthresh	(size 7, offset 0, init 0):	NOATTR	Pre-Fetch Threshold
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   hthresh	(size 7, offset 8, init 0):	NOATTR	Host Threshold
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   wthresh	(size 7, offset 16, init 0):	NOATTR	Write-Back Threshold
 *   _anon23	(size 2, offset 23, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	NOATTR	Transmit Queue Enable
 *   swflsh	(size 1, offset 26, init 0):	NOATTR	Transmit Software Flush
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t e10k_txdctl_t;
#define e10k_txdctl_default 0x0
static inline uint8_t e10k_txdctl_pthresh_extract(e10k_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_pthresh_extract(e10k_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline e10k_txdctl_t e10k_txdctl_pthresh_insert(e10k_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_txdctl_t e10k_txdctl_pthresh_insert(e10k_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((e10k_txdctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_txdctl_hthresh_extract(e10k_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_hthresh_extract(e10k_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f00) >> 8));
}

static inline e10k_txdctl_t e10k_txdctl_hthresh_insert(e10k_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_txdctl_t e10k_txdctl_hthresh_insert(e10k_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff80ff) | (0x7f00 & (((e10k_txdctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_txdctl_wthresh_extract(e10k_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_wthresh_extract(e10k_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0x7f0000) >> 16));
}

static inline e10k_txdctl_t e10k_txdctl_wthresh_insert(e10k_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_txdctl_t e10k_txdctl_wthresh_insert(e10k_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff80ffff) | (0x7f0000 & (((e10k_txdctl_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_txdctl_enable_extract(e10k_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_enable_extract(e10k_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_txdctl_t e10k_txdctl_enable_insert(e10k_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_txdctl_t e10k_txdctl_enable_insert(e10k_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_txdctl_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_txdctl_swflsh_extract(e10k_txdctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_swflsh_extract(e10k_txdctl_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_txdctl_t e10k_txdctl_swflsh_insert(e10k_txdctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_txdctl_t e10k_txdctl_swflsh_insert(e10k_txdctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_txdctl_t )(_fieldval)) << 26)));
}

static inline int e10k_txdctl_prtval(char *_s, size_t _size, e10k_txdctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_txdctl_prtval(char *_s, size_t _size, e10k_txdctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Pre-Fetch Threshold)\n", e10k_txdctl_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host Threshold)\n", e10k_txdctl_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write-Back Threshold)\n", e10k_txdctl_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Transmit Queue Enable)\n", e10k_txdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swflsh =\t%" PRIx8 "\t(Transmit Software Flush)\n", e10k_txdctl_swflsh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_tdwbal_t
 * Description: Implicit type of Tx Descriptor Completion Write Back Address Low register array
 * Fields:
 *   headwb_en	(size 1, offset 0, init 0):	NOATTR	Head Write-Back Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   headwb_low	(size 30, offset 2, init 0):	NOATTR	Lowest 32 bits of the head write-back memory location
 */
typedef uint32_t e10k_tdwbal_t;
#define e10k_tdwbal_default 0x0
static inline uint8_t e10k_tdwbal_headwb_en_extract(e10k_tdwbal_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_tdwbal_headwb_en_extract(e10k_tdwbal_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_tdwbal_t e10k_tdwbal_headwb_en_insert(e10k_tdwbal_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tdwbal_t e10k_tdwbal_headwb_en_insert(e10k_tdwbal_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_tdwbal_t )(_fieldval)) << 0)));
}

static inline uint32_t e10k_tdwbal_headwb_low_extract(e10k_tdwbal_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_tdwbal_headwb_low_extract(e10k_tdwbal_t _regval)
{
    return((uint32_t )((_regval & 0xfffffffc) >> 2));
}

static inline e10k_tdwbal_t e10k_tdwbal_headwb_low_insert(e10k_tdwbal_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tdwbal_t e10k_tdwbal_headwb_low_insert(e10k_tdwbal_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x3) | (0xfffffffc & (((e10k_tdwbal_t )(_fieldval)) << 2)));
}

static inline int e10k_tdwbal_prtval(char *_s, size_t _size, e10k_tdwbal_t _regval) __attribute__ ((always_inline));
static inline int e10k_tdwbal_prtval(char *_s, size_t _size, e10k_tdwbal_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_en =\t%" PRIx8 "\t(Head Write-Back Enable)\n", e10k_tdwbal_headwb_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_low =\t%" PRIx32 "\t(Lowest 32 bits of the head write-back memory location)\n", e10k_tdwbal_headwb_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_tdwbah_t
 * Description: Implicit type of Tx Descriptor Completion Write Back Address High register array
 * Fields:
 *   headwb_high	(size 32, offset 0, init 0):	NOATTR	Highest 32 bits of the head write-back memory location
 */
typedef uint32_t e10k_tdwbah_t;
#define e10k_tdwbah_default 0x0
static inline uint32_t e10k_tdwbah_headwb_high_extract(e10k_tdwbah_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_tdwbah_headwb_high_extract(e10k_tdwbah_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_tdwbah_t e10k_tdwbah_headwb_high_insert(e10k_tdwbah_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tdwbah_t e10k_tdwbah_headwb_high_insert(e10k_tdwbah_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_tdwbah_t )(_fieldval)) << 0)));
}

static inline int e10k_tdwbah_prtval(char *_s, size_t _size, e10k_tdwbah_t _regval) __attribute__ ((always_inline));
static inline int e10k_tdwbah_prtval(char *_s, size_t _size, e10k_tdwbah_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_high =\t%" PRIx32 "\t(Highest 32 bits of the head write-back memory location)\n", e10k_tdwbah_headwb_high_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_txpbsize_t
 * Description: Implicit type of Transmit Packet Buffer Size register array
 * Fields:
 *   _anon0	(size 10, offset 0, init 0):	RSVD	_
 *   size	(size 10, offset 10, init 0):	NOATTR	Transmit packet buffer size of TCn
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t e10k_txpbsize_t;
#define e10k_txpbsize_default 0x0
static inline uint16_t e10k_txpbsize_size_extract(e10k_txpbsize_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_txpbsize_size_extract(e10k_txpbsize_t _regval)
{
    return((uint16_t )((_regval & 0xffc00) >> 10));
}

static inline e10k_txpbsize_t e10k_txpbsize_size_insert(e10k_txpbsize_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_txpbsize_t e10k_txpbsize_size_insert(e10k_txpbsize_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfff003ff) | (0xffc00 & (((e10k_txpbsize_t )(_fieldval)) << 10)));
}

static inline int e10k_txpbsize_prtval(char *_s, size_t _size, e10k_txpbsize_t _regval) __attribute__ ((always_inline));
static inline int e10k_txpbsize_prtval(char *_s, size_t _size, e10k_txpbsize_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Transmit packet buffer size of TCn)\n", e10k_txpbsize_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mngtxmap_t
 * Description: Implicit type of Manageability Transmit TC Mapping register
 * Fields:
 *   map	(size 3, offset 0, init 0):	RW	Map value indicates the TC that the transmit manageability traffic is routed to
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_mngtxmap_t;
#define e10k_mngtxmap_default 0x0
static inline uint8_t e10k_mngtxmap_map_extract(e10k_mngtxmap_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mngtxmap_map_extract(e10k_mngtxmap_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_mngtxmap_t e10k_mngtxmap_map_insert(e10k_mngtxmap_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mngtxmap_t e10k_mngtxmap_map_insert(e10k_mngtxmap_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_mngtxmap_t )(_fieldval)) << 0)));
}

static inline int e10k_mngtxmap_prtval(char *_s, size_t _size, e10k_mngtxmap_t _regval) __attribute__ ((always_inline));
static inline int e10k_mngtxmap_prtval(char *_s, size_t _size, e10k_mngtxmap_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " map =\t%" PRIx8 "\t(Map value indicates the TC that the transmit manageability traffic is routed to)\n", e10k_mngtxmap_map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mtqc_t
 * Description: Implicit type of Multiple Transmit Queues Command Register register
 * Fields:
 *   rt_en	(size 1, offset 0, init 0):	RW	DCB Enabled Mode
 *   vt_en	(size 1, offset 1, init 0):	RW	Virtualization Enabled Mode
 *   num_tc	(size 2, offset 2, init 0):	RW	Number of TCs or Number of Tx Queues per Pools
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
typedef uint32_t e10k_mtqc_t;
#define e10k_mtqc_default 0x0
static inline uint8_t e10k_mtqc_rt_en_extract(e10k_mtqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mtqc_rt_en_extract(e10k_mtqc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_mtqc_t e10k_mtqc_rt_en_insert(e10k_mtqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mtqc_t e10k_mtqc_rt_en_insert(e10k_mtqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_mtqc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_mtqc_vt_en_extract(e10k_mtqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mtqc_vt_en_extract(e10k_mtqc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_mtqc_t e10k_mtqc_vt_en_insert(e10k_mtqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mtqc_t e10k_mtqc_vt_en_insert(e10k_mtqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_mtqc_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_mtqc_num_tc_extract(e10k_mtqc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mtqc_num_tc_extract(e10k_mtqc_t _regval)
{
    return((uint8_t )((_regval & 0xc) >> 2));
}

static inline e10k_mtqc_t e10k_mtqc_num_tc_insert(e10k_mtqc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mtqc_t e10k_mtqc_num_tc_insert(e10k_mtqc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff3) | (0xc & (((e10k_mtqc_t )(_fieldval)) << 2)));
}

static inline int e10k_mtqc_prtval(char *_s, size_t _size, e10k_mtqc_t _regval) __attribute__ ((always_inline));
static inline int e10k_mtqc_prtval(char *_s, size_t _size, e10k_mtqc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rt_en =\t%" PRIx8 "\t(DCB Enabled Mode)\n", e10k_mtqc_rt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vt_en =\t%" PRIx8 "\t(Virtualization Enabled Mode)\n", e10k_mtqc_vt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " num_tc =\t%" PRIx8 "\t(Number of TCs or Number of Tx Queues per Pools)\n", e10k_mtqc_num_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_txpbthresh_t
 * Description: Implicit type of Tx Packet Buffer Threshold register array
 * Fields:
 *   thresh	(size 10, offset 0, init 0):	NOATTR	Threshold used for checking room place in Tx packet buffer of TCn
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
typedef uint32_t e10k_txpbthresh_t;
#define e10k_txpbthresh_default 0x0
static inline uint16_t e10k_txpbthresh_thresh_extract(e10k_txpbthresh_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_txpbthresh_thresh_extract(e10k_txpbthresh_t _regval)
{
    return((uint16_t )((_regval & 0x3ff) >> 0));
}

static inline e10k_txpbthresh_t e10k_txpbthresh_thresh_insert(e10k_txpbthresh_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_txpbthresh_t e10k_txpbthresh_thresh_insert(e10k_txpbthresh_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffc00) | (0x3ff & (((e10k_txpbthresh_t )(_fieldval)) << 0)));
}

static inline int e10k_txpbthresh_prtval(char *_s, size_t _size, e10k_txpbthresh_t _regval) __attribute__ ((always_inline));
static inline int e10k_txpbthresh_prtval(char *_s, size_t _size, e10k_txpbthresh_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " thresh =\t%" PRIx16 "\t(Threshold used for checking room place in Tx packet buffer of TCn)\n", e10k_txpbthresh_thresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rtrpcs_t
 * Description: Implicit type of DCB Receive Packet Plane Control and Status register
 * Fields:
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   rrm	(size 1, offset 1, init 0):	RW	Receive Recycle Mode
 *   rac	(size 1, offset 2, init 0):	RW	Receive Arbitration Control
 *   _anon3	(size 13, offset 3, init 0):	RSVD	_
 *   lrpb	(size 3, offset 16, init 0):	RW	Last Received Packet Buffer Status Indication
 *   _anon19	(size 13, offset 19, init 0):	RSVD	_
 */
typedef uint32_t e10k_rtrpcs_t;
#define e10k_rtrpcs_default 0x0
static inline uint8_t e10k_rtrpcs_rrm_extract(e10k_rtrpcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpcs_rrm_extract(e10k_rtrpcs_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_rtrpcs_t e10k_rtrpcs_rrm_insert(e10k_rtrpcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrpcs_t e10k_rtrpcs_rrm_insert(e10k_rtrpcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_rtrpcs_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_rtrpcs_rac_extract(e10k_rtrpcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpcs_rac_extract(e10k_rtrpcs_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_rtrpcs_t e10k_rtrpcs_rac_insert(e10k_rtrpcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrpcs_t e10k_rtrpcs_rac_insert(e10k_rtrpcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_rtrpcs_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_rtrpcs_lrpb_extract(e10k_rtrpcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpcs_lrpb_extract(e10k_rtrpcs_t _regval)
{
    return((uint8_t )((_regval & 0x70000) >> 16));
}

static inline e10k_rtrpcs_t e10k_rtrpcs_lrpb_insert(e10k_rtrpcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrpcs_t e10k_rtrpcs_lrpb_insert(e10k_rtrpcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff8ffff) | (0x70000 & (((e10k_rtrpcs_t )(_fieldval)) << 16)));
}

static inline int e10k_rtrpcs_prtval(char *_s, size_t _size, e10k_rtrpcs_t _regval) __attribute__ ((always_inline));
static inline int e10k_rtrpcs_prtval(char *_s, size_t _size, e10k_rtrpcs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rrm =\t%" PRIx8 "\t(Receive Recycle Mode)\n", e10k_rtrpcs_rrm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rac =\t%" PRIx8 "\t(Receive Arbitration Control)\n", e10k_rtrpcs_rac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lrpb =\t%" PRIx8 "\t(Last Received Packet Buffer Status Indication)\n", e10k_rtrpcs_lrpb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rttdcs_t
 * Description: Implicit type of DCP Transmit Descriptor Plane Control and Status register
 * Fields:
 *   tdpac	(size 1, offset 0, init 0):	RW	TC Transmit Descriptor Plane Arbitration Control
 *   vmpac	(size 1, offset 1, init 0):	RW	VM Transmit Descriptor Plane Arbitration Control
 *   _anon2	(size 2, offset 2, init 0):	RSVD	_
 *   tdrm	(size 1, offset 4, init 0):	RW	TC Transmit descriptor plane recycle mode
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   arbdis	(size 1, offset 6, init 0):	RW	DCB Arbiters Disable
 *   _anon7	(size 10, offset 7, init 0):	RSVD	_
 *   lttdesc	(size 3, offset 17, init 0):	RO	Last Transmitted TC
 *   _anon20	(size 2, offset 20, init 0):	RSVD	_
 *   bdpm	(size 1, offset 22, init 0):	RW	Bypass data pipe Monitor
 *   bpbfsm	(size 1, offset 23, init 0):	RW	Bypass Packet Buffer Free Space Monitor
 *   _anon24	(size 7, offset 24, init 0):	RSVD	_
 *   speed_chg	(size 1, offset 31, init 0):	RW	Link speed has changed
 */
typedef uint32_t e10k_rttdcs_t;
#define e10k_rttdcs_default 0x0
static inline uint8_t e10k_rttdcs_tdpac_extract(e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_tdpac_extract(e10k_rttdcs_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_rttdcs_t e10k_rttdcs_tdpac_insert(e10k_rttdcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_tdpac_insert(e10k_rttdcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_rttdcs_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rttdcs_vmpac_extract(e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_vmpac_extract(e10k_rttdcs_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_rttdcs_t e10k_rttdcs_vmpac_insert(e10k_rttdcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_vmpac_insert(e10k_rttdcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_rttdcs_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_rttdcs_tdrm_extract(e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_tdrm_extract(e10k_rttdcs_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_rttdcs_t e10k_rttdcs_tdrm_insert(e10k_rttdcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_tdrm_insert(e10k_rttdcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_rttdcs_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_rttdcs_arbdis_extract(e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_arbdis_extract(e10k_rttdcs_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_rttdcs_t e10k_rttdcs_arbdis_insert(e10k_rttdcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_arbdis_insert(e10k_rttdcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_rttdcs_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_rttdcs_lttdesc_extract(e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_lttdesc_extract(e10k_rttdcs_t _regval)
{
    return((uint8_t )((_regval & 0xe0000) >> 17));
}

static inline e10k_rttdcs_t e10k_rttdcs_lttdesc_insert(e10k_rttdcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_lttdesc_insert(e10k_rttdcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff1ffff) | (0xe0000 & (((e10k_rttdcs_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_rttdcs_bdpm_extract(e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_bdpm_extract(e10k_rttdcs_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_rttdcs_t e10k_rttdcs_bdpm_insert(e10k_rttdcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_bdpm_insert(e10k_rttdcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_rttdcs_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_rttdcs_bpbfsm_extract(e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_bpbfsm_extract(e10k_rttdcs_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_rttdcs_t e10k_rttdcs_bpbfsm_insert(e10k_rttdcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_bpbfsm_insert(e10k_rttdcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_rttdcs_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_rttdcs_speed_chg_extract(e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_speed_chg_extract(e10k_rttdcs_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_rttdcs_t e10k_rttdcs_speed_chg_insert(e10k_rttdcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_speed_chg_insert(e10k_rttdcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_rttdcs_t )(_fieldval)) << 31)));
}

static inline int e10k_rttdcs_prtval(char *_s, size_t _size, e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline int e10k_rttdcs_prtval(char *_s, size_t _size, e10k_rttdcs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tdpac =\t%" PRIx8 "\t(TC Transmit Descriptor Plane Arbitration Control)\n", e10k_rttdcs_tdpac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vmpac =\t%" PRIx8 "\t(VM Transmit Descriptor Plane Arbitration Control)\n", e10k_rttdcs_vmpac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tdrm =\t%" PRIx8 "\t(TC Transmit descriptor plane recycle mode)\n", e10k_rttdcs_tdrm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arbdis =\t%" PRIx8 "\t(DCB Arbiters Disable)\n", e10k_rttdcs_arbdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lttdesc =\t%" PRIx8 "\t(Last Transmitted TC)\n", e10k_rttdcs_lttdesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bdpm =\t%" PRIx8 "\t(Bypass data pipe Monitor)\n", e10k_rttdcs_bdpm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bpbfsm =\t%" PRIx8 "\t(Bypass Packet Buffer Free Space Monitor)\n", e10k_rttdcs_bpbfsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed_chg =\t%" PRIx8 "\t(Link speed has changed)\n", e10k_rttdcs_speed_chg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rttpcs_t
 * Description: Implicit type of DCB Transmit Packet Plane Control and Status register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   tppac	(size 1, offset 5, init 0):	RW	Transmit Packet Plane Arbitration Control
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   tprm	(size 1, offset 8, init 0):	RW	Transmit packet plane recycle mode
 *   _anon9	(size 13, offset 9, init 0):	RSVD	_
 *   arbd	(size 10, offset 22, init 0):	RW	ARB_delay
 */
typedef uint32_t e10k_rttpcs_t;
#define e10k_rttpcs_default 0x0
static inline uint8_t e10k_rttpcs_tppac_extract(e10k_rttpcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpcs_tppac_extract(e10k_rttpcs_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_rttpcs_t e10k_rttpcs_tppac_insert(e10k_rttpcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttpcs_t e10k_rttpcs_tppac_insert(e10k_rttpcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_rttpcs_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_rttpcs_tprm_extract(e10k_rttpcs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpcs_tprm_extract(e10k_rttpcs_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_rttpcs_t e10k_rttpcs_tprm_insert(e10k_rttpcs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttpcs_t e10k_rttpcs_tprm_insert(e10k_rttpcs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_rttpcs_t )(_fieldval)) << 8)));
}

static inline uint16_t e10k_rttpcs_arbd_extract(e10k_rttpcs_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rttpcs_arbd_extract(e10k_rttpcs_t _regval)
{
    return((uint16_t )((_regval & 0xffc00000) >> 22));
}

static inline e10k_rttpcs_t e10k_rttpcs_arbd_insert(e10k_rttpcs_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttpcs_t e10k_rttpcs_arbd_insert(e10k_rttpcs_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x3fffff) | (0xffc00000 & (((e10k_rttpcs_t )(_fieldval)) << 22)));
}

static inline int e10k_rttpcs_prtval(char *_s, size_t _size, e10k_rttpcs_t _regval) __attribute__ ((always_inline));
static inline int e10k_rttpcs_prtval(char *_s, size_t _size, e10k_rttpcs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tppac =\t%" PRIx8 "\t(Transmit Packet Plane Arbitration Control)\n", e10k_rttpcs_tppac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tprm =\t%" PRIx8 "\t(Transmit packet plane recycle mode)\n", e10k_rttpcs_tprm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arbd =\t%" PRIx16 "\t(ARB_delay)\n", e10k_rttpcs_arbd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rtrup2tc_t
 * Description: Implicit type of DCB Receive User Priority to Traffic Class register
 * Fields:
 *   up0map	(size 3, offset 0, init 0):	RW	Receive UP 0 to TC Mapping
 *   up1map	(size 3, offset 3, init 0):	RW	Receive UP 1 to TC Mapping
 *   up2map	(size 3, offset 6, init 0):	RW	Receive UP 2 to TC Mapping
 *   up3map	(size 3, offset 9, init 0):	RW	Receive UP 3 to TC Mapping
 *   up4map	(size 3, offset 12, init 0):	RW	Receive UP 4 to TC Mapping
 *   up5map	(size 3, offset 15, init 0):	RW	Receive UP 5 to TC Mapping
 *   up6map	(size 3, offset 18, init 0):	RW	Receive UP 6 to TC Mapping
 *   up7map	(size 3, offset 21, init 0):	RW	Receive UP 7 to TC Mapping
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t e10k_rtrup2tc_t;
#define e10k_rtrup2tc_default 0x0
static inline uint8_t e10k_rtrup2tc_up0map_extract(e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up0map_extract(e10k_rtrup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_up0map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_up0map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_rtrup2tc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rtrup2tc_up1map_extract(e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up1map_extract(e10k_rtrup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x38) >> 3));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_up1map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_up1map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc7) | (0x38 & (((e10k_rtrup2tc_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_rtrup2tc_up2map_extract(e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up2map_extract(e10k_rtrup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x1c0) >> 6));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_up2map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_up2map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffe3f) | (0x1c0 & (((e10k_rtrup2tc_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_rtrup2tc_up3map_extract(e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up3map_extract(e10k_rtrup2tc_t _regval)
{
    return((uint8_t )((_regval & 0xe00) >> 9));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_up3map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_up3map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff1ff) | (0xe00 & (((e10k_rtrup2tc_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_rtrup2tc_up4map_extract(e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up4map_extract(e10k_rtrup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x7000) >> 12));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_up4map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_up4map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff8fff) | (0x7000 & (((e10k_rtrup2tc_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_rtrup2tc_up5map_extract(e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up5map_extract(e10k_rtrup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x38000) >> 15));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_up5map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_up5map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffc7fff) | (0x38000 & (((e10k_rtrup2tc_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_rtrup2tc_up6map_extract(e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up6map_extract(e10k_rtrup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x1c0000) >> 18));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_up6map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_up6map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe3ffff) | (0x1c0000 & (((e10k_rtrup2tc_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_rtrup2tc_up7map_extract(e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up7map_extract(e10k_rtrup2tc_t _regval)
{
    return((uint8_t )((_regval & 0xe00000) >> 21));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_up7map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_up7map_insert(e10k_rtrup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff1fffff) | (0xe00000 & (((e10k_rtrup2tc_t )(_fieldval)) << 21)));
}

static inline int e10k_rtrup2tc_prtval(char *_s, size_t _size, e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline int e10k_rtrup2tc_prtval(char *_s, size_t _size, e10k_rtrup2tc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up0map =\t%" PRIx8 "\t(Receive UP 0 to TC Mapping)\n", e10k_rtrup2tc_up0map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up1map =\t%" PRIx8 "\t(Receive UP 1 to TC Mapping)\n", e10k_rtrup2tc_up1map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up2map =\t%" PRIx8 "\t(Receive UP 2 to TC Mapping)\n", e10k_rtrup2tc_up2map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up3map =\t%" PRIx8 "\t(Receive UP 3 to TC Mapping)\n", e10k_rtrup2tc_up3map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up4map =\t%" PRIx8 "\t(Receive UP 4 to TC Mapping)\n", e10k_rtrup2tc_up4map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up5map =\t%" PRIx8 "\t(Receive UP 5 to TC Mapping)\n", e10k_rtrup2tc_up5map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up6map =\t%" PRIx8 "\t(Receive UP 6 to TC Mapping)\n", e10k_rtrup2tc_up6map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up7map =\t%" PRIx8 "\t(Receive UP 7 to TC Mapping)\n", e10k_rtrup2tc_up7map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rttup2tc_t
 * Description: Implicit type of DCB Transmit User Priority to Traffic Class register
 * Fields:
 *   up0map	(size 3, offset 0, init 0):	RW	Receive UP 0 to TC Mapping
 *   up1map	(size 3, offset 3, init 0):	RW	Receive UP 1 to TC Mapping
 *   up2map	(size 3, offset 6, init 0):	RW	Receive UP 2 to TC Mapping
 *   up3map	(size 3, offset 9, init 0):	RW	Receive UP 3 to TC Mapping
 *   up4map	(size 3, offset 12, init 0):	RW	Receive UP 4 to TC Mapping
 *   up5map	(size 3, offset 15, init 0):	RW	Receive UP 5 to TC Mapping
 *   up6map	(size 3, offset 18, init 0):	RW	Receive UP 6 to TC Mapping
 *   up7map	(size 3, offset 21, init 0):	RW	Receive UP 7 to TC Mapping
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
typedef uint32_t e10k_rttup2tc_t;
#define e10k_rttup2tc_default 0x0
static inline uint8_t e10k_rttup2tc_up0map_extract(e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up0map_extract(e10k_rttup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_up0map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_up0map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_rttup2tc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rttup2tc_up1map_extract(e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up1map_extract(e10k_rttup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x38) >> 3));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_up1map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_up1map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc7) | (0x38 & (((e10k_rttup2tc_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_rttup2tc_up2map_extract(e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up2map_extract(e10k_rttup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x1c0) >> 6));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_up2map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_up2map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffe3f) | (0x1c0 & (((e10k_rttup2tc_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_rttup2tc_up3map_extract(e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up3map_extract(e10k_rttup2tc_t _regval)
{
    return((uint8_t )((_regval & 0xe00) >> 9));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_up3map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_up3map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff1ff) | (0xe00 & (((e10k_rttup2tc_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_rttup2tc_up4map_extract(e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up4map_extract(e10k_rttup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x7000) >> 12));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_up4map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_up4map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff8fff) | (0x7000 & (((e10k_rttup2tc_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_rttup2tc_up5map_extract(e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up5map_extract(e10k_rttup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x38000) >> 15));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_up5map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_up5map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffc7fff) | (0x38000 & (((e10k_rttup2tc_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_rttup2tc_up6map_extract(e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up6map_extract(e10k_rttup2tc_t _regval)
{
    return((uint8_t )((_regval & 0x1c0000) >> 18));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_up6map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_up6map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe3ffff) | (0x1c0000 & (((e10k_rttup2tc_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_rttup2tc_up7map_extract(e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up7map_extract(e10k_rttup2tc_t _regval)
{
    return((uint8_t )((_regval & 0xe00000) >> 21));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_up7map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_up7map_insert(e10k_rttup2tc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff1fffff) | (0xe00000 & (((e10k_rttup2tc_t )(_fieldval)) << 21)));
}

static inline int e10k_rttup2tc_prtval(char *_s, size_t _size, e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline int e10k_rttup2tc_prtval(char *_s, size_t _size, e10k_rttup2tc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up0map =\t%" PRIx8 "\t(Receive UP 0 to TC Mapping)\n", e10k_rttup2tc_up0map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up1map =\t%" PRIx8 "\t(Receive UP 1 to TC Mapping)\n", e10k_rttup2tc_up1map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up2map =\t%" PRIx8 "\t(Receive UP 2 to TC Mapping)\n", e10k_rttup2tc_up2map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up3map =\t%" PRIx8 "\t(Receive UP 3 to TC Mapping)\n", e10k_rttup2tc_up3map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up4map =\t%" PRIx8 "\t(Receive UP 4 to TC Mapping)\n", e10k_rttup2tc_up4map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up5map =\t%" PRIx8 "\t(Receive UP 5 to TC Mapping)\n", e10k_rttup2tc_up5map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up6map =\t%" PRIx8 "\t(Receive UP 6 to TC Mapping)\n", e10k_rttup2tc_up6map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up7map =\t%" PRIx8 "\t(Receive UP 7 to TC Mapping)\n", e10k_rttup2tc_up7map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rtrpt4c_t
 * Description: Implicit type of DCB Receive Packet Plane T4 Config register array
 * Fields:
 *   crq	(size 9, offset 0, init 0):	NOATTR	Credit refill quantum
 *   bwg	(size 3, offset 9, init 0):	NOATTR	Bandwidth group index
 *   mcl	(size 12, offset 12, init 0):	NOATTR	Max credit limit
 *   _anon24	(size 6, offset 24, init 0):	RSVD	_
 *   gsp	(size 1, offset 30, init 0):	NOATTR	Group strict priority
 *   lsp	(size 1, offset 31, init 0):	NOATTR	Link strict priority
 */
typedef uint32_t e10k_rtrpt4c_t;
#define e10k_rtrpt4c_default 0x0
static inline uint16_t e10k_rtrpt4c_crq_extract(e10k_rtrpt4c_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rtrpt4c_crq_extract(e10k_rtrpt4c_t _regval)
{
    return((uint16_t )((_regval & 0x1ff) >> 0));
}

static inline e10k_rtrpt4c_t e10k_rtrpt4c_crq_insert(e10k_rtrpt4c_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrpt4c_t e10k_rtrpt4c_crq_insert(e10k_rtrpt4c_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffe00) | (0x1ff & (((e10k_rtrpt4c_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rtrpt4c_bwg_extract(e10k_rtrpt4c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpt4c_bwg_extract(e10k_rtrpt4c_t _regval)
{
    return((uint8_t )((_regval & 0xe00) >> 9));
}

static inline e10k_rtrpt4c_t e10k_rtrpt4c_bwg_insert(e10k_rtrpt4c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrpt4c_t e10k_rtrpt4c_bwg_insert(e10k_rtrpt4c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff1ff) | (0xe00 & (((e10k_rtrpt4c_t )(_fieldval)) << 9)));
}

static inline uint16_t e10k_rtrpt4c_mcl_extract(e10k_rtrpt4c_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rtrpt4c_mcl_extract(e10k_rtrpt4c_t _regval)
{
    return((uint16_t )((_regval & 0xfff000) >> 12));
}

static inline e10k_rtrpt4c_t e10k_rtrpt4c_mcl_insert(e10k_rtrpt4c_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrpt4c_t e10k_rtrpt4c_mcl_insert(e10k_rtrpt4c_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xff000fff) | (0xfff000 & (((e10k_rtrpt4c_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_rtrpt4c_gsp_extract(e10k_rtrpt4c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpt4c_gsp_extract(e10k_rtrpt4c_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_rtrpt4c_t e10k_rtrpt4c_gsp_insert(e10k_rtrpt4c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrpt4c_t e10k_rtrpt4c_gsp_insert(e10k_rtrpt4c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_rtrpt4c_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_rtrpt4c_lsp_extract(e10k_rtrpt4c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpt4c_lsp_extract(e10k_rtrpt4c_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_rtrpt4c_t e10k_rtrpt4c_lsp_insert(e10k_rtrpt4c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rtrpt4c_t e10k_rtrpt4c_lsp_insert(e10k_rtrpt4c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_rtrpt4c_t )(_fieldval)) << 31)));
}

static inline int e10k_rtrpt4c_prtval(char *_s, size_t _size, e10k_rtrpt4c_t _regval) __attribute__ ((always_inline));
static inline int e10k_rtrpt4c_prtval(char *_s, size_t _size, e10k_rtrpt4c_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crq =\t%" PRIx16 "\t(Credit refill quantum)\n", e10k_rtrpt4c_crq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bwg =\t%" PRIx8 "\t(Bandwidth group index)\n", e10k_rtrpt4c_bwg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcl =\t%" PRIx16 "\t(Max credit limit)\n", e10k_rtrpt4c_mcl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gsp =\t%" PRIx8 "\t(Group strict priority)\n", e10k_rtrpt4c_gsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsp =\t%" PRIx8 "\t(Link strict priority)\n", e10k_rtrpt4c_lsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rttdt2c_t
 * Description: Implicit type of DCB Transmit Descriptor Plane T2 Config register array
 * Fields:
 *   crq	(size 9, offset 0, init 0):	NOATTR	Credit refill quantum
 *   bwg	(size 3, offset 9, init 0):	NOATTR	Bandwidth group index
 *   mcl	(size 12, offset 12, init 0):	NOATTR	Max credit limit
 *   _anon24	(size 6, offset 24, init 0):	RSVD	_
 *   gsp	(size 1, offset 30, init 0):	NOATTR	Group strict priority
 *   lsp	(size 1, offset 31, init 0):	NOATTR	Link strict priority
 */
typedef uint32_t e10k_rttdt2c_t;
#define e10k_rttdt2c_default 0x0
static inline uint16_t e10k_rttdt2c_crq_extract(e10k_rttdt2c_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rttdt2c_crq_extract(e10k_rttdt2c_t _regval)
{
    return((uint16_t )((_regval & 0x1ff) >> 0));
}

static inline e10k_rttdt2c_t e10k_rttdt2c_crq_insert(e10k_rttdt2c_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdt2c_t e10k_rttdt2c_crq_insert(e10k_rttdt2c_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffe00) | (0x1ff & (((e10k_rttdt2c_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rttdt2c_bwg_extract(e10k_rttdt2c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdt2c_bwg_extract(e10k_rttdt2c_t _regval)
{
    return((uint8_t )((_regval & 0xe00) >> 9));
}

static inline e10k_rttdt2c_t e10k_rttdt2c_bwg_insert(e10k_rttdt2c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdt2c_t e10k_rttdt2c_bwg_insert(e10k_rttdt2c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff1ff) | (0xe00 & (((e10k_rttdt2c_t )(_fieldval)) << 9)));
}

static inline uint16_t e10k_rttdt2c_mcl_extract(e10k_rttdt2c_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rttdt2c_mcl_extract(e10k_rttdt2c_t _regval)
{
    return((uint16_t )((_regval & 0xfff000) >> 12));
}

static inline e10k_rttdt2c_t e10k_rttdt2c_mcl_insert(e10k_rttdt2c_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdt2c_t e10k_rttdt2c_mcl_insert(e10k_rttdt2c_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xff000fff) | (0xfff000 & (((e10k_rttdt2c_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_rttdt2c_gsp_extract(e10k_rttdt2c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdt2c_gsp_extract(e10k_rttdt2c_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_rttdt2c_t e10k_rttdt2c_gsp_insert(e10k_rttdt2c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdt2c_t e10k_rttdt2c_gsp_insert(e10k_rttdt2c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_rttdt2c_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_rttdt2c_lsp_extract(e10k_rttdt2c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdt2c_lsp_extract(e10k_rttdt2c_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_rttdt2c_t e10k_rttdt2c_lsp_insert(e10k_rttdt2c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdt2c_t e10k_rttdt2c_lsp_insert(e10k_rttdt2c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_rttdt2c_t )(_fieldval)) << 31)));
}

static inline int e10k_rttdt2c_prtval(char *_s, size_t _size, e10k_rttdt2c_t _regval) __attribute__ ((always_inline));
static inline int e10k_rttdt2c_prtval(char *_s, size_t _size, e10k_rttdt2c_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crq =\t%" PRIx16 "\t(Credit refill quantum)\n", e10k_rttdt2c_crq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bwg =\t%" PRIx8 "\t(Bandwidth group index)\n", e10k_rttdt2c_bwg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcl =\t%" PRIx16 "\t(Max credit limit)\n", e10k_rttdt2c_mcl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gsp =\t%" PRIx8 "\t(Group strict priority)\n", e10k_rttdt2c_gsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsp =\t%" PRIx8 "\t(Link strict priority)\n", e10k_rttdt2c_lsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rttpt2c_t
 * Description: Implicit type of DCB Transmit Packet Plane T2 Config register array
 * Fields:
 *   crq	(size 9, offset 0, init 0):	NOATTR	Credit refill quantum
 *   bwg	(size 3, offset 9, init 0):	NOATTR	Bandwidth group index
 *   mcl	(size 12, offset 12, init 0):	NOATTR	Max credit limit
 *   _anon24	(size 6, offset 24, init 0):	RSVD	_
 *   gsp	(size 1, offset 30, init 0):	NOATTR	Group strict priority
 *   lsp	(size 1, offset 31, init 0):	NOATTR	Link strict priority
 */
typedef uint32_t e10k_rttpt2c_t;
#define e10k_rttpt2c_default 0x0
static inline uint16_t e10k_rttpt2c_crq_extract(e10k_rttpt2c_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rttpt2c_crq_extract(e10k_rttpt2c_t _regval)
{
    return((uint16_t )((_regval & 0x1ff) >> 0));
}

static inline e10k_rttpt2c_t e10k_rttpt2c_crq_insert(e10k_rttpt2c_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttpt2c_t e10k_rttpt2c_crq_insert(e10k_rttpt2c_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffffe00) | (0x1ff & (((e10k_rttpt2c_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_rttpt2c_bwg_extract(e10k_rttpt2c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpt2c_bwg_extract(e10k_rttpt2c_t _regval)
{
    return((uint8_t )((_regval & 0xe00) >> 9));
}

static inline e10k_rttpt2c_t e10k_rttpt2c_bwg_insert(e10k_rttpt2c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttpt2c_t e10k_rttpt2c_bwg_insert(e10k_rttpt2c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff1ff) | (0xe00 & (((e10k_rttpt2c_t )(_fieldval)) << 9)));
}

static inline uint16_t e10k_rttpt2c_mcl_extract(e10k_rttpt2c_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rttpt2c_mcl_extract(e10k_rttpt2c_t _regval)
{
    return((uint16_t )((_regval & 0xfff000) >> 12));
}

static inline e10k_rttpt2c_t e10k_rttpt2c_mcl_insert(e10k_rttpt2c_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttpt2c_t e10k_rttpt2c_mcl_insert(e10k_rttpt2c_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xff000fff) | (0xfff000 & (((e10k_rttpt2c_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_rttpt2c_gsp_extract(e10k_rttpt2c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpt2c_gsp_extract(e10k_rttpt2c_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_rttpt2c_t e10k_rttpt2c_gsp_insert(e10k_rttpt2c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttpt2c_t e10k_rttpt2c_gsp_insert(e10k_rttpt2c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_rttpt2c_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_rttpt2c_lsp_extract(e10k_rttpt2c_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpt2c_lsp_extract(e10k_rttpt2c_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_rttpt2c_t e10k_rttpt2c_lsp_insert(e10k_rttpt2c_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttpt2c_t e10k_rttpt2c_lsp_insert(e10k_rttpt2c_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_rttpt2c_t )(_fieldval)) << 31)));
}

static inline int e10k_rttpt2c_prtval(char *_s, size_t _size, e10k_rttpt2c_t _regval) __attribute__ ((always_inline));
static inline int e10k_rttpt2c_prtval(char *_s, size_t _size, e10k_rttpt2c_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crq =\t%" PRIx16 "\t(Credit refill quantum)\n", e10k_rttpt2c_crq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bwg =\t%" PRIx8 "\t(Bandwidth group index)\n", e10k_rttpt2c_bwg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcl =\t%" PRIx16 "\t(Max credit limit)\n", e10k_rttpt2c_mcl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gsp =\t%" PRIx8 "\t(Group strict priority)\n", e10k_rttpt2c_gsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsp =\t%" PRIx8 "\t(Link strict priority)\n", e10k_rttpt2c_lsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rttdqsel_t
 * Description: Implicit type of DCB Transmit Descriptor Plane Queue Select register
 * Fields:
 *   txdq_idx	(size 7, offset 0, init 0):	RW	Tx Descriptor Queue Index
 *   _anon7	(size 25, offset 7, init 0):	RSVD	_
 */
typedef uint32_t e10k_rttdqsel_t;
#define e10k_rttdqsel_default 0x0
static inline uint8_t e10k_rttdqsel_txdq_idx_extract(e10k_rttdqsel_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdqsel_txdq_idx_extract(e10k_rttdqsel_t _regval)
{
    return((uint8_t )((_regval & 0x7f) >> 0));
}

static inline e10k_rttdqsel_t e10k_rttdqsel_txdq_idx_insert(e10k_rttdqsel_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdqsel_t e10k_rttdqsel_txdq_idx_insert(e10k_rttdqsel_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff80) | (0x7f & (((e10k_rttdqsel_t )(_fieldval)) << 0)));
}

static inline int e10k_rttdqsel_prtval(char *_s, size_t _size, e10k_rttdqsel_t _regval) __attribute__ ((always_inline));
static inline int e10k_rttdqsel_prtval(char *_s, size_t _size, e10k_rttdqsel_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdq_idx =\t%" PRIx8 "\t(Tx Descriptor Queue Index)\n", e10k_rttdqsel_txdq_idx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rttdt1c_t
 * Description: Implicit type of DCB Transmit Descriptor Plane T1 Config register
 * Fields:
 *   crq	(size 14, offset 0, init 0):	RW	Credit refill quantum
 *   _anon14	(size 18, offset 14, init 0):	RSVD	_
 */
typedef uint32_t e10k_rttdt1c_t;
#define e10k_rttdt1c_default 0x0
static inline uint16_t e10k_rttdt1c_crq_extract(e10k_rttdt1c_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rttdt1c_crq_extract(e10k_rttdt1c_t _regval)
{
    return((uint16_t )((_regval & 0x3fff) >> 0));
}

static inline e10k_rttdt1c_t e10k_rttdt1c_crq_insert(e10k_rttdt1c_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttdt1c_t e10k_rttdt1c_crq_insert(e10k_rttdt1c_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc000) | (0x3fff & (((e10k_rttdt1c_t )(_fieldval)) << 0)));
}

static inline int e10k_rttdt1c_prtval(char *_s, size_t _size, e10k_rttdt1c_t _regval) __attribute__ ((always_inline));
static inline int e10k_rttdt1c_prtval(char *_s, size_t _size, e10k_rttdt1c_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crq =\t%" PRIx16 "\t(Credit refill quantum)\n", e10k_rttdt1c_crq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_rttbcnrc_t
 * Description: Implicit type of DCB Transmit Rate-Scheduler Config register
 * Fields:
 *   rf_dec	(size 14, offset 0, init 0):	RW	Tx rate-scheduler rate factor hexadecimal part
 *   rf_int	(size 10, offset 14, init 0):	RW	Tx rate-scheduler rate factor integral part
 *   _anon24	(size 7, offset 24, init 0):	RSVD	_
 *   rs_ena	(size 1, offset 31, init 0):	RW	Tx rate-scheduler enable
 */
typedef uint32_t e10k_rttbcnrc_t;
#define e10k_rttbcnrc_default 0x0
static inline uint16_t e10k_rttbcnrc_rf_dec_extract(e10k_rttbcnrc_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rttbcnrc_rf_dec_extract(e10k_rttbcnrc_t _regval)
{
    return((uint16_t )((_regval & 0x3fff) >> 0));
}

static inline e10k_rttbcnrc_t e10k_rttbcnrc_rf_dec_insert(e10k_rttbcnrc_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttbcnrc_t e10k_rttbcnrc_rf_dec_insert(e10k_rttbcnrc_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffffc000) | (0x3fff & (((e10k_rttbcnrc_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_rttbcnrc_rf_int_extract(e10k_rttbcnrc_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_rttbcnrc_rf_int_extract(e10k_rttbcnrc_t _regval)
{
    return((uint16_t )((_regval & 0xffc000) >> 14));
}

static inline e10k_rttbcnrc_t e10k_rttbcnrc_rf_int_insert(e10k_rttbcnrc_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttbcnrc_t e10k_rttbcnrc_rf_int_insert(e10k_rttbcnrc_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xff003fff) | (0xffc000 & (((e10k_rttbcnrc_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_rttbcnrc_rs_ena_extract(e10k_rttbcnrc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_rttbcnrc_rs_ena_extract(e10k_rttbcnrc_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_rttbcnrc_t e10k_rttbcnrc_rs_ena_insert(e10k_rttbcnrc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_rttbcnrc_t e10k_rttbcnrc_rs_ena_insert(e10k_rttbcnrc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_rttbcnrc_t )(_fieldval)) << 31)));
}

static inline int e10k_rttbcnrc_prtval(char *_s, size_t _size, e10k_rttbcnrc_t _regval) __attribute__ ((always_inline));
static inline int e10k_rttbcnrc_prtval(char *_s, size_t _size, e10k_rttbcnrc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rf_dec =\t%" PRIx16 "\t(Tx rate-scheduler rate factor hexadecimal part)\n", e10k_rttbcnrc_rf_dec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rf_int =\t%" PRIx16 "\t(Tx rate-scheduler rate factor integral part)\n", e10k_rttbcnrc_rf_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs_ena =\t%" PRIx8 "\t(Tx rate-scheduler enable)\n", e10k_rttbcnrc_rs_ena_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_dca_rxctrl_t
 * Description: Rx DCA Control Register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rxdca_desc	(size 1, offset 5, init 0):	NOATTR	Descriptor DCA EN
 *   rxdca_hdr	(size 1, offset 6, init 0):	NOATTR	Rx Header DCA EN
 *   rxdca_payl	(size 1, offset 7, init 0):	NOATTR	Payload DCA EN
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   rxdesc_rdro	(size 1, offset 9, init 0):	NOATTR	Rx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   rxdesc_wbro	(size 1, offset 11, init 0):	MBZ	Rx Descriptor Write Back Relax Order Enable
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   rxdata_wrro	(size 1, offset 13, init 0):	NOATTR	Rx data Write Relax Order Enable
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   rxhdr_ro	(size 1, offset 15, init 0):	NOATTR	Rx Split Header Relax Order Enable
 *   _anon16	(size 8, offset 16, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	NOATTR	Physical ID
 */
typedef uint32_t e10k_dca_rxctrl_t;
#define e10k_dca_rxctrl_default 0x0
static inline uint8_t e10k_dca_rxctrl_rxdca_desc_extract(e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_rxdca_desc_extract(e10k_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdca_desc_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdca_desc_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_dca_rxctrl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_dca_rxctrl_rxdca_hdr_extract(e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_rxdca_hdr_extract(e10k_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdca_hdr_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdca_hdr_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_dca_rxctrl_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_dca_rxctrl_rxdca_payl_extract(e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_rxdca_payl_extract(e10k_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdca_payl_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdca_payl_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_dca_rxctrl_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_dca_rxctrl_rxdesc_rdro_extract(e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_rxdesc_rdro_extract(e10k_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdesc_rdro_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdesc_rdro_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_dca_rxctrl_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_dca_rxctrl_rxdesc_wbro_extract(e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_rxdesc_wbro_extract(e10k_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdesc_wbro_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdesc_wbro_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_dca_rxctrl_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_dca_rxctrl_rxdata_wrro_extract(e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_rxdata_wrro_extract(e10k_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdata_wrro_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxdata_wrro_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_dca_rxctrl_rxhdr_ro_extract(e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_rxhdr_ro_extract(e10k_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxhdr_ro_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_rxhdr_ro_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_dca_rxctrl_cpuid_extract(e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_cpuid_extract(e10k_dca_rxctrl_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_cpuid_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_cpuid_insert(e10k_dca_rxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 24)));
}

static inline int e10k_dca_rxctrl_prtval(char *_s, size_t _size, e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_dca_rxctrl_prtval(char *_s, size_t _size, e10k_dca_rxctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_desc =\t%" PRIx8 "\t(Descriptor DCA EN)\n", e10k_dca_rxctrl_rxdca_desc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_hdr =\t%" PRIx8 "\t(Rx Header DCA EN)\n", e10k_dca_rxctrl_rxdca_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_payl =\t%" PRIx8 "\t(Payload DCA EN)\n", e10k_dca_rxctrl_rxdca_payl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_rdro =\t%" PRIx8 "\t(Rx Descriptor Read Relax Order Enable)\n", e10k_dca_rxctrl_rxdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_wbro =\t%" PRIx8 "\t(Rx Descriptor Write Back Relax Order Enable)\n", e10k_dca_rxctrl_rxdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdata_wrro =\t%" PRIx8 "\t(Rx data Write Relax Order Enable)\n", e10k_dca_rxctrl_rxdata_wrro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxhdr_ro =\t%" PRIx8 "\t(Rx Split Header Relax Order Enable)\n", e10k_dca_rxctrl_rxhdr_ro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_dca_rxctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_dca_txctrl_t
 * Description: Implicit type of Tx DCA Control Registers register array
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   txdesc_dca	(size 1, offset 5, init 0):	NOATTR	Descriptor DCA Enable
 *   _anon6	(size 3, offset 6, init 0):	RSVD	_
 *   txdesc_rdro	(size 1, offset 9, init 0):	NOATTR	Tx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   txdesc_wbro	(size 1, offset 11, init 0):	NOATTR	Relax Order Enable of Tx Descriptor well as head pointer write back
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   txdata_rdro	(size 1, offset 13, init 0):	NOATTR	Tx Data Read Relax Order Enable
 *   _anon14	(size 10, offset 14, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	NOATTR	Physical ID
 */
typedef uint32_t e10k_dca_txctrl_t;
#define e10k_dca_txctrl_default 0x0
static inline uint8_t e10k_dca_txctrl_txdesc_dca_extract(e10k_dca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_txdesc_dca_extract(e10k_dca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_dca_txctrl_t e10k_dca_txctrl_txdesc_dca_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_txctrl_t e10k_dca_txctrl_txdesc_dca_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_dca_txctrl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_dca_txctrl_txdesc_rdro_extract(e10k_dca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_txdesc_rdro_extract(e10k_dca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_dca_txctrl_t e10k_dca_txctrl_txdesc_rdro_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_txctrl_t e10k_dca_txctrl_txdesc_rdro_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_dca_txctrl_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_dca_txctrl_txdesc_wbro_extract(e10k_dca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_txdesc_wbro_extract(e10k_dca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_dca_txctrl_t e10k_dca_txctrl_txdesc_wbro_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_txctrl_t e10k_dca_txctrl_txdesc_wbro_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_dca_txctrl_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_dca_txctrl_txdata_rdro_extract(e10k_dca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_txdata_rdro_extract(e10k_dca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_dca_txctrl_t e10k_dca_txctrl_txdata_rdro_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_txctrl_t e10k_dca_txctrl_txdata_rdro_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_dca_txctrl_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_dca_txctrl_cpuid_extract(e10k_dca_txctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_cpuid_extract(e10k_dca_txctrl_t _regval)
{
    return((uint8_t )((_regval & 0xff000000) >> 24));
}

static inline e10k_dca_txctrl_t e10k_dca_txctrl_cpuid_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_txctrl_t e10k_dca_txctrl_cpuid_insert(e10k_dca_txctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff) | (0xff000000 & (((e10k_dca_txctrl_t )(_fieldval)) << 24)));
}

static inline int e10k_dca_txctrl_prtval(char *_s, size_t _size, e10k_dca_txctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_dca_txctrl_prtval(char *_s, size_t _size, e10k_dca_txctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_dca =\t%" PRIx8 "\t(Descriptor DCA Enable)\n", e10k_dca_txctrl_txdesc_dca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_rdro =\t%" PRIx8 "\t(Tx Descriptor Read Relax Order Enable)\n", e10k_dca_txctrl_txdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_wbro =\t%" PRIx8 "\t(Relax Order Enable of Tx Descriptor well as head pointer write back)\n", e10k_dca_txctrl_txdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdata_rdro =\t%" PRIx8 "\t(Tx Data Read Relax Order Enable)\n", e10k_dca_txctrl_txdata_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_dca_txctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_dca_id_t
 * Description: Implicit type of DCA Requester ID Information Register register
 * Fields:
 *   fun_no	(size 3, offset 0, init 0):	RO	Function Number
 *   dev_no	(size 5, offset 3, init 0):	RO	Device Number
 *   bus_no	(size 8, offset 8, init 0):	RO	Bus Number
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_dca_id_t;
#define e10k_dca_id_default 0x0
static inline uint8_t e10k_dca_id_fun_no_extract(e10k_dca_id_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_id_fun_no_extract(e10k_dca_id_t _regval)
{
    return((uint8_t )((_regval & 0x7) >> 0));
}

static inline e10k_dca_id_t e10k_dca_id_fun_no_insert(e10k_dca_id_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_id_t e10k_dca_id_fun_no_insert(e10k_dca_id_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff8) | (0x7 & (((e10k_dca_id_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_dca_id_dev_no_extract(e10k_dca_id_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_id_dev_no_extract(e10k_dca_id_t _regval)
{
    return((uint8_t )((_regval & 0xf8) >> 3));
}

static inline e10k_dca_id_t e10k_dca_id_dev_no_insert(e10k_dca_id_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_id_t e10k_dca_id_dev_no_insert(e10k_dca_id_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff07) | (0xf8 & (((e10k_dca_id_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_dca_id_bus_no_extract(e10k_dca_id_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_id_bus_no_extract(e10k_dca_id_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e10k_dca_id_t e10k_dca_id_bus_no_insert(e10k_dca_id_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_id_t e10k_dca_id_bus_no_insert(e10k_dca_id_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e10k_dca_id_t )(_fieldval)) << 8)));
}

static inline int e10k_dca_id_prtval(char *_s, size_t _size, e10k_dca_id_t _regval) __attribute__ ((always_inline));
static inline int e10k_dca_id_prtval(char *_s, size_t _size, e10k_dca_id_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fun_no =\t%" PRIx8 "\t(Function Number)\n", e10k_dca_id_fun_no_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dev_no =\t%" PRIx8 "\t(Device Number)\n", e10k_dca_id_dev_no_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bus_no =\t%" PRIx8 "\t(Bus Number)\n", e10k_dca_id_bus_no_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_dca_ctrl_t
 * Description: Implicit type of DCA Control Register register
 * Fields:
 *   dca_dis	(size 1, offset 0, init 0):	RW	DCA Disable
 *   dca_mode	(size 4, offset 1, init 0):	RW	DCA Mode
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
typedef uint32_t e10k_dca_ctrl_t;
#define e10k_dca_ctrl_default 0x0
static inline uint8_t e10k_dca_ctrl_dca_dis_extract(e10k_dca_ctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_ctrl_dca_dis_extract(e10k_dca_ctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_dca_ctrl_t e10k_dca_ctrl_dca_dis_insert(e10k_dca_ctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_ctrl_t e10k_dca_ctrl_dca_dis_insert(e10k_dca_ctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_dca_ctrl_t )(_fieldval)) << 0)));
}

static inline e10k_dca_mode_t e10k_dca_ctrl_dca_mode_extract(e10k_dca_ctrl_t _regval) __attribute__ ((always_inline));
static inline e10k_dca_mode_t e10k_dca_ctrl_dca_mode_extract(e10k_dca_ctrl_t _regval)
{
    return((e10k_dca_mode_t )((_regval & 0x1e) >> 1));
}

static inline e10k_dca_ctrl_t e10k_dca_ctrl_dca_mode_insert(e10k_dca_ctrl_t _regval, e10k_dca_mode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_dca_ctrl_t e10k_dca_ctrl_dca_mode_insert(e10k_dca_ctrl_t _regval, e10k_dca_mode_t _fieldval)
{
    return((_regval & 0xffffffe1) | (0x1e & (((e10k_dca_ctrl_t )(_fieldval)) << 1)));
}

static inline int e10k_dca_ctrl_prtval(char *_s, size_t _size, e10k_dca_ctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_dca_ctrl_prtval(char *_s, size_t _size, e10k_dca_ctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dca_dis =\t%" PRIx8 "\t(DCA Disable)\n", e10k_dca_ctrl_dca_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dca_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dca_mode_prtval(_s + _r, _avail, e10k_dca_ctrl_dca_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DCA Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_secrxctrl_t
 * Description: Implicit type of Security Rx Control register
 * Fields:
 *   secrx_dis	(size 1, offset 0, init 0):	RW	Rx Security Offload Disable Bit
 *   rx_dis	(size 1, offset 1, init 0):	RW	Disable Sec Rx Path
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
typedef uint32_t e10k_secrxctrl_t;
#define e10k_secrxctrl_default 0x0
static inline uint8_t e10k_secrxctrl_secrx_dis_extract(e10k_secrxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxctrl_secrx_dis_extract(e10k_secrxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_secrxctrl_t e10k_secrxctrl_secrx_dis_insert(e10k_secrxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_secrxctrl_t e10k_secrxctrl_secrx_dis_insert(e10k_secrxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_secrxctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_secrxctrl_rx_dis_extract(e10k_secrxctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxctrl_rx_dis_extract(e10k_secrxctrl_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_secrxctrl_t e10k_secrxctrl_rx_dis_insert(e10k_secrxctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_secrxctrl_t e10k_secrxctrl_rx_dis_insert(e10k_secrxctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_secrxctrl_t )(_fieldval)) << 1)));
}

static inline int e10k_secrxctrl_prtval(char *_s, size_t _size, e10k_secrxctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_secrxctrl_prtval(char *_s, size_t _size, e10k_secrxctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " secrx_dis =\t%" PRIx8 "\t(Rx Security Offload Disable Bit)\n", e10k_secrxctrl_secrx_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_dis =\t%" PRIx8 "\t(Disable Sec Rx Path)\n", e10k_secrxctrl_rx_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_secrxstat_t
 * Description: Implicit type of Security Rx Status register
 * Fields:
 *   sr_rdy	(size 1, offset 0, init 0):	RO	Rx security block ready for mode change
 *   sr_off_dis	(size 1, offset 1, init 0):	RO	Security offload is disabled by fuse or strapping pin
 *   eec_rxerr	(size 1, offset 2, init 0):	RO	Unrecoverable ECC error in an Rx SA table occurred
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
typedef uint32_t e10k_secrxstat_t;
#define e10k_secrxstat_default 0x0
static inline uint8_t e10k_secrxstat_sr_rdy_extract(e10k_secrxstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxstat_sr_rdy_extract(e10k_secrxstat_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_secrxstat_t e10k_secrxstat_sr_rdy_insert(e10k_secrxstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_secrxstat_t e10k_secrxstat_sr_rdy_insert(e10k_secrxstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_secrxstat_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_secrxstat_sr_off_dis_extract(e10k_secrxstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxstat_sr_off_dis_extract(e10k_secrxstat_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_secrxstat_t e10k_secrxstat_sr_off_dis_insert(e10k_secrxstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_secrxstat_t e10k_secrxstat_sr_off_dis_insert(e10k_secrxstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_secrxstat_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_secrxstat_eec_rxerr_extract(e10k_secrxstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxstat_eec_rxerr_extract(e10k_secrxstat_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_secrxstat_t e10k_secrxstat_eec_rxerr_insert(e10k_secrxstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_secrxstat_t e10k_secrxstat_eec_rxerr_insert(e10k_secrxstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_secrxstat_t )(_fieldval)) << 2)));
}

static inline int e10k_secrxstat_prtval(char *_s, size_t _size, e10k_secrxstat_t _regval) __attribute__ ((always_inline));
static inline int e10k_secrxstat_prtval(char *_s, size_t _size, e10k_secrxstat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_rdy =\t%" PRIx8 "\t(Rx security block ready for mode change)\n", e10k_secrxstat_sr_rdy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_off_dis =\t%" PRIx8 "\t(Security offload is disabled by fuse or strapping pin)\n", e10k_secrxstat_sr_off_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eec_rxerr =\t%" PRIx8 "\t(Unrecoverable ECC error in an Rx SA table occurred)\n", e10k_secrxstat_eec_rxerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_tcptimer_t
 * Description: Implicit type of TCP Timer register
 * Fields:
 *   duration	(size 8, offset 0, init 0):	RW	Duration of the TCP interrupt interval, in ms
 *   kickstart	(size 1, offset 8, init 0):	RW	Counter kick-start
 *   tcpcnt_en	(size 1, offset 9, init 0):	RW	TCP Count Enable
 *   tcpcnt_fin	(size 1, offset 10, init 0):	RW	TCP Count Finish
 *   loop	(size 1, offset 11, init 0):	RW	TCP Loop
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
typedef uint32_t e10k_tcptimer_t;
#define e10k_tcptimer_default 0x0
static inline uint8_t e10k_tcptimer_duration_extract(e10k_tcptimer_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_duration_extract(e10k_tcptimer_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e10k_tcptimer_t e10k_tcptimer_duration_insert(e10k_tcptimer_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tcptimer_t e10k_tcptimer_duration_insert(e10k_tcptimer_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_tcptimer_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_tcptimer_kickstart_extract(e10k_tcptimer_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_kickstart_extract(e10k_tcptimer_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_tcptimer_t e10k_tcptimer_kickstart_insert(e10k_tcptimer_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tcptimer_t e10k_tcptimer_kickstart_insert(e10k_tcptimer_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_tcptimer_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_tcptimer_tcpcnt_en_extract(e10k_tcptimer_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_tcpcnt_en_extract(e10k_tcptimer_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_tcptimer_t e10k_tcptimer_tcpcnt_en_insert(e10k_tcptimer_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tcptimer_t e10k_tcptimer_tcpcnt_en_insert(e10k_tcptimer_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_tcptimer_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_tcptimer_tcpcnt_fin_extract(e10k_tcptimer_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_tcpcnt_fin_extract(e10k_tcptimer_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_tcptimer_t e10k_tcptimer_tcpcnt_fin_insert(e10k_tcptimer_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tcptimer_t e10k_tcptimer_tcpcnt_fin_insert(e10k_tcptimer_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_tcptimer_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_tcptimer_loop_extract(e10k_tcptimer_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_loop_extract(e10k_tcptimer_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_tcptimer_t e10k_tcptimer_loop_insert(e10k_tcptimer_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_tcptimer_t e10k_tcptimer_loop_insert(e10k_tcptimer_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_tcptimer_t )(_fieldval)) << 11)));
}

static inline int e10k_tcptimer_prtval(char *_s, size_t _size, e10k_tcptimer_t _regval) __attribute__ ((always_inline));
static inline int e10k_tcptimer_prtval(char *_s, size_t _size, e10k_tcptimer_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " duration =\t%" PRIx8 "\t(Duration of the TCP interrupt interval, in ms)\n", e10k_tcptimer_duration_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kickstart =\t%" PRIx8 "\t(Counter kick-start)\n", e10k_tcptimer_kickstart_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcpcnt_en =\t%" PRIx8 "\t(TCP Count Enable)\n", e10k_tcptimer_tcpcnt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcpcnt_fin =\t%" PRIx8 "\t(TCP Count Finish)\n", e10k_tcptimer_tcpcnt_fin_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " loop =\t%" PRIx8 "\t(TCP Loop)\n", e10k_tcptimer_loop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirctrl_t
 * Description: Implicit type of Flow Director Filters Control Register register
 * Fields:
 *   pballoc	(size 2, offset 0, init 0):	RW	Memory allocation for the flow director filters
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   init_done	(size 1, offset 3, init 0):	RW	Flow director initialization completion indication
 *   perf_match	(size 1, offset 4, init 0):	RW	Flow director filters mode of operation
 *   rep_stat	(size 1, offset 5, init 0):	RW	Report flow director filter's status on matching packets
 *   _anon6	(size 1, offset 6, init 0):	RSVD	_
 *   rep_statalw	(size 1, offset 7, init 0):	RW	Report flow director filter's status always
 *   drop_queue	(size 7, offset 8, init 0):	RW	Absolute Rx queue index used for the dropped packets
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   flex_off	(size 5, offset 16, init 0):	RW	Offset of a flexible 2-byte tuple in packet
 *   _anon21	(size 3, offset 21, init 0):	RSVD	_
 *   max_len	(size 4, offset 24, init 0):	RW	Maximum linked list length
 *   full_thresh	(size 4, offset 28, init 0):	RW	Recommended minimum number of flows that should remain unused
 */
typedef uint32_t e10k_fdirctrl_t;
#define e10k_fdirctrl_default 0x0
static inline e10k_pballoc_t e10k_fdirctrl_pballoc_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline e10k_pballoc_t e10k_fdirctrl_pballoc_extract(e10k_fdirctrl_t _regval)
{
    return((e10k_pballoc_t )((_regval & 0x3) >> 0));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_pballoc_insert(e10k_fdirctrl_t _regval, e10k_pballoc_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_pballoc_insert(e10k_fdirctrl_t _regval, e10k_pballoc_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e10k_fdirctrl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_fdirctrl_init_done_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_init_done_extract(e10k_fdirctrl_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_init_done_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_init_done_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_fdirctrl_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_fdirctrl_perf_match_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_perf_match_extract(e10k_fdirctrl_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_perf_match_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_perf_match_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_fdirctrl_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_fdirctrl_rep_stat_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_rep_stat_extract(e10k_fdirctrl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_rep_stat_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_rep_stat_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_fdirctrl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_fdirctrl_rep_statalw_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_rep_statalw_extract(e10k_fdirctrl_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_rep_statalw_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_rep_statalw_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_fdirctrl_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_fdirctrl_drop_queue_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_drop_queue_extract(e10k_fdirctrl_t _regval)
{
    return((uint8_t )((_regval & 0x7f00) >> 8));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_drop_queue_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_drop_queue_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff80ff) | (0x7f00 & (((e10k_fdirctrl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_fdirctrl_flex_off_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_flex_off_extract(e10k_fdirctrl_t _regval)
{
    return((uint8_t )((_regval & 0x1f0000) >> 16));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_flex_off_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_flex_off_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe0ffff) | (0x1f0000 & (((e10k_fdirctrl_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_fdirctrl_max_len_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_max_len_extract(e10k_fdirctrl_t _regval)
{
    return((uint8_t )((_regval & 0xf000000) >> 24));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_max_len_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_max_len_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((e10k_fdirctrl_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_fdirctrl_full_thresh_extract(e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_full_thresh_extract(e10k_fdirctrl_t _regval)
{
    return((uint8_t )((_regval & 0xf0000000) >> 28));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_full_thresh_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_full_thresh_insert(e10k_fdirctrl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff) | (0xf0000000 & (((e10k_fdirctrl_t )(_fieldval)) << 28)));
}

static inline int e10k_fdirctrl_prtval(char *_s, size_t _size, e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirctrl_prtval(char *_s, size_t _size, e10k_fdirctrl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pballoc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pballoc_prtval(_s + _r, _avail, e10k_fdirctrl_pballoc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Memory allocation for the flow director filters)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " init_done =\t%" PRIx8 "\t(Flow director initialization completion indication)\n", e10k_fdirctrl_init_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " perf_match =\t%" PRIx8 "\t(Flow director filters mode of operation)\n", e10k_fdirctrl_perf_match_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rep_stat =\t%" PRIx8 "\t(Report flow director filter's status on matching packets)\n", e10k_fdirctrl_rep_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rep_statalw =\t%" PRIx8 "\t(Report flow director filter's status always)\n", e10k_fdirctrl_rep_statalw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop_queue =\t%" PRIx8 "\t(Absolute Rx queue index used for the dropped packets)\n", e10k_fdirctrl_drop_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex_off =\t%" PRIx8 "\t(Offset of a flexible 2-byte tuple in packet)\n", e10k_fdirctrl_flex_off_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max_len =\t%" PRIx8 "\t(Maximum linked list length)\n", e10k_fdirctrl_max_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " full_thresh =\t%" PRIx8 "\t(Recommended minimum number of flows that should remain unused)\n", e10k_fdirctrl_full_thresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirhkey_t
 * Description: Implicit type of Flow Director Filters Lookup Table HASH Key register
 * Fields:
 *   key	(size 32, offset 0, init 0):	RW	Programmable hash lookup table key
 */
typedef uint32_t e10k_fdirhkey_t;
#define e10k_fdirhkey_default 0x0
static inline uint32_t e10k_fdirhkey_key_extract(e10k_fdirhkey_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirhkey_key_extract(e10k_fdirhkey_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdirhkey_t e10k_fdirhkey_key_insert(e10k_fdirhkey_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirhkey_t e10k_fdirhkey_key_insert(e10k_fdirhkey_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdirhkey_t )(_fieldval)) << 0)));
}

static inline int e10k_fdirhkey_prtval(char *_s, size_t _size, e10k_fdirhkey_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirhkey_prtval(char *_s, size_t _size, e10k_fdirhkey_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " key =\t%" PRIx32 "\t(Programmable hash lookup table key)\n", e10k_fdirhkey_key_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirskey_t
 * Description: Implicit type of Flow Director Filters Signature Hash Key  register
 * Fields:
 *   key	(size 32, offset 0, init 0):	RW	rogrammable Signature Key
 */
typedef uint32_t e10k_fdirskey_t;
#define e10k_fdirskey_default 0x0
static inline uint32_t e10k_fdirskey_key_extract(e10k_fdirskey_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirskey_key_extract(e10k_fdirskey_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdirskey_t e10k_fdirskey_key_insert(e10k_fdirskey_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirskey_t e10k_fdirskey_key_insert(e10k_fdirskey_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdirskey_t )(_fieldval)) << 0)));
}

static inline int e10k_fdirskey_prtval(char *_s, size_t _size, e10k_fdirskey_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirskey_prtval(char *_s, size_t _size, e10k_fdirskey_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " key =\t%" PRIx32 "\t(rogrammable Signature Key)\n", e10k_fdirskey_key_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirdip4m_t
 * Description: Implicit type of Flow Director Filters DIPv4 Mask register
 * Fields:
 *   ipm	(size 32, offset 0, init 0):	RW	Mask Destination IPv4 Address
 */
typedef uint32_t e10k_fdirdip4m_t;
#define e10k_fdirdip4m_default 0x0
static inline uint32_t e10k_fdirdip4m_ipm_extract(e10k_fdirdip4m_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirdip4m_ipm_extract(e10k_fdirdip4m_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdirdip4m_t e10k_fdirdip4m_ipm_insert(e10k_fdirdip4m_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirdip4m_t e10k_fdirdip4m_ipm_insert(e10k_fdirdip4m_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdirdip4m_t )(_fieldval)) << 0)));
}

static inline int e10k_fdirdip4m_prtval(char *_s, size_t _size, e10k_fdirdip4m_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirdip4m_prtval(char *_s, size_t _size, e10k_fdirdip4m_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipm =\t%" PRIx32 "\t(Mask Destination IPv4 Address)\n", e10k_fdirdip4m_ipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirsip4m_t
 * Description: Implicit type of Flow Director Filters Source IPv4 Mask register
 * Fields:
 *   ipm	(size 32, offset 0, init 0):	RW	Mask Source IPv4 Address
 */
typedef uint32_t e10k_fdirsip4m_t;
#define e10k_fdirsip4m_default 0x0
static inline uint32_t e10k_fdirsip4m_ipm_extract(e10k_fdirsip4m_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirsip4m_ipm_extract(e10k_fdirsip4m_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdirsip4m_t e10k_fdirsip4m_ipm_insert(e10k_fdirsip4m_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirsip4m_t e10k_fdirsip4m_ipm_insert(e10k_fdirsip4m_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdirsip4m_t )(_fieldval)) << 0)));
}

static inline int e10k_fdirsip4m_prtval(char *_s, size_t _size, e10k_fdirsip4m_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirsip4m_prtval(char *_s, size_t _size, e10k_fdirsip4m_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipm =\t%" PRIx32 "\t(Mask Source IPv4 Address)\n", e10k_fdirsip4m_ipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirtcpm_t
 * Description: Implicit type of Flow Director Filters TCP Mask register
 * Fields:
 *   sportm	(size 16, offset 0, init 0):	RW	Mask TCP Source Port
 *   dportm	(size 16, offset 16, init 0):	RW	Mask TCP Destination Port
 */
typedef uint32_t e10k_fdirtcpm_t;
#define e10k_fdirtcpm_default 0x0
static inline uint16_t e10k_fdirtcpm_sportm_extract(e10k_fdirtcpm_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirtcpm_sportm_extract(e10k_fdirtcpm_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fdirtcpm_t e10k_fdirtcpm_sportm_insert(e10k_fdirtcpm_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirtcpm_t e10k_fdirtcpm_sportm_insert(e10k_fdirtcpm_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fdirtcpm_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_fdirtcpm_dportm_extract(e10k_fdirtcpm_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirtcpm_dportm_extract(e10k_fdirtcpm_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_fdirtcpm_t e10k_fdirtcpm_dportm_insert(e10k_fdirtcpm_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirtcpm_t e10k_fdirtcpm_dportm_insert(e10k_fdirtcpm_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_fdirtcpm_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirtcpm_prtval(char *_s, size_t _size, e10k_fdirtcpm_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirtcpm_prtval(char *_s, size_t _size, e10k_fdirtcpm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sportm =\t%" PRIx16 "\t(Mask TCP Source Port)\n", e10k_fdirtcpm_sportm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dportm =\t%" PRIx16 "\t(Mask TCP Destination Port)\n", e10k_fdirtcpm_dportm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirudpm_t
 * Description: Implicit type of Flow Director Filters UDP Mask register
 * Fields:
 *   sportm	(size 16, offset 0, init 0):	RW	Mask UDP Source Port
 *   dportm	(size 16, offset 16, init 0):	RW	Mask UDP Destination Port
 */
typedef uint32_t e10k_fdirudpm_t;
#define e10k_fdirudpm_default 0x0
static inline uint16_t e10k_fdirudpm_sportm_extract(e10k_fdirudpm_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirudpm_sportm_extract(e10k_fdirudpm_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fdirudpm_t e10k_fdirudpm_sportm_insert(e10k_fdirudpm_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirudpm_t e10k_fdirudpm_sportm_insert(e10k_fdirudpm_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fdirudpm_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_fdirudpm_dportm_extract(e10k_fdirudpm_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirudpm_dportm_extract(e10k_fdirudpm_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_fdirudpm_t e10k_fdirudpm_dportm_insert(e10k_fdirudpm_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirudpm_t e10k_fdirudpm_dportm_insert(e10k_fdirudpm_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_fdirudpm_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirudpm_prtval(char *_s, size_t _size, e10k_fdirudpm_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirudpm_prtval(char *_s, size_t _size, e10k_fdirudpm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sportm =\t%" PRIx16 "\t(Mask UDP Source Port)\n", e10k_fdirudpm_sportm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dportm =\t%" PRIx16 "\t(Mask UDP Destination Port)\n", e10k_fdirudpm_dportm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirip6m_t
 * Description: Implicit type of Flow Director Filters IPv6 Mask register
 * Fields:
 *   sipm	(size 16, offset 0, init 0):	RW	Mask Source IPv6 address
 *   dipm	(size 16, offset 16, init 0):	RW	Mask Destination IPv6 address
 */
typedef uint32_t e10k_fdirip6m_t;
#define e10k_fdirip6m_default 0x0
static inline uint16_t e10k_fdirip6m_sipm_extract(e10k_fdirip6m_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirip6m_sipm_extract(e10k_fdirip6m_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fdirip6m_t e10k_fdirip6m_sipm_insert(e10k_fdirip6m_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirip6m_t e10k_fdirip6m_sipm_insert(e10k_fdirip6m_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fdirip6m_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_fdirip6m_dipm_extract(e10k_fdirip6m_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirip6m_dipm_extract(e10k_fdirip6m_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_fdirip6m_t e10k_fdirip6m_dipm_insert(e10k_fdirip6m_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirip6m_t e10k_fdirip6m_dipm_insert(e10k_fdirip6m_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_fdirip6m_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirip6m_prtval(char *_s, size_t _size, e10k_fdirip6m_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirip6m_prtval(char *_s, size_t _size, e10k_fdirip6m_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sipm =\t%" PRIx16 "\t(Mask Source IPv6 address)\n", e10k_fdirip6m_sipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dipm =\t%" PRIx16 "\t(Mask Destination IPv6 address)\n", e10k_fdirip6m_dipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirm_t
 * Description: Implicit type of Flow Director Filters Other Mask register
 * Fields:
 *   vlanid	(size 1, offset 0, init 0):	RW	Mask VLAN ID tag
 *   vlanp	(size 1, offset 1, init 0):	RW	Mask VLAN Priority tag
 *   pool	(size 1, offset 2, init 0):	RW	Mask Pool
 *   l4p	(size 1, offset 3, init 0):	RW	Mask L4 Protocol
 *   flex	(size 1, offset 4, init 0):	RW	Mask Flexible Tuple
 *   dipv6	(size 1, offset 5, init 0):	RW	Mask Destination IPv6
 *   _anon6	(size 26, offset 6, init 0):	RSVD	_
 */
typedef uint32_t e10k_fdirm_t;
#define e10k_fdirm_default 0x0
static inline uint8_t e10k_fdirm_vlanid_extract(e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_vlanid_extract(e10k_fdirm_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_fdirm_t e10k_fdirm_vlanid_insert(e10k_fdirm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirm_t e10k_fdirm_vlanid_insert(e10k_fdirm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_fdirm_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_fdirm_vlanp_extract(e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_vlanp_extract(e10k_fdirm_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_fdirm_t e10k_fdirm_vlanp_insert(e10k_fdirm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirm_t e10k_fdirm_vlanp_insert(e10k_fdirm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_fdirm_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_fdirm_pool_extract(e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_pool_extract(e10k_fdirm_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_fdirm_t e10k_fdirm_pool_insert(e10k_fdirm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirm_t e10k_fdirm_pool_insert(e10k_fdirm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_fdirm_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_fdirm_l4p_extract(e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_l4p_extract(e10k_fdirm_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_fdirm_t e10k_fdirm_l4p_insert(e10k_fdirm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirm_t e10k_fdirm_l4p_insert(e10k_fdirm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_fdirm_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_fdirm_flex_extract(e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_flex_extract(e10k_fdirm_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_fdirm_t e10k_fdirm_flex_insert(e10k_fdirm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirm_t e10k_fdirm_flex_insert(e10k_fdirm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_fdirm_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_fdirm_dipv6_extract(e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_dipv6_extract(e10k_fdirm_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_fdirm_t e10k_fdirm_dipv6_insert(e10k_fdirm_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirm_t e10k_fdirm_dipv6_insert(e10k_fdirm_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_fdirm_t )(_fieldval)) << 5)));
}

static inline int e10k_fdirm_prtval(char *_s, size_t _size, e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirm_prtval(char *_s, size_t _size, e10k_fdirm_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlanid =\t%" PRIx8 "\t(Mask VLAN ID tag)\n", e10k_fdirm_vlanid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlanp =\t%" PRIx8 "\t(Mask VLAN Priority tag)\n", e10k_fdirm_vlanp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool =\t%" PRIx8 "\t(Mask Pool)\n", e10k_fdirm_pool_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4p =\t%" PRIx8 "\t(Mask L4 Protocol)\n", e10k_fdirm_l4p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex =\t%" PRIx8 "\t(Mask Flexible Tuple)\n", e10k_fdirm_flex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dipv6 =\t%" PRIx8 "\t(Mask Destination IPv6)\n", e10k_fdirm_dipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirfree_t
 * Description: Implicit type of Flow Director Filters Free register
 * Fields:
 *   free	(size 16, offset 0, init 0):	RW	Number of free filters in the flow director Filters logic
 *   coll	(size 15, offset 16, init 0):	RW	Number of filters with collision indication
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_fdirfree_t;
#define e10k_fdirfree_default 0x0
static inline uint16_t e10k_fdirfree_free_extract(e10k_fdirfree_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirfree_free_extract(e10k_fdirfree_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fdirfree_t e10k_fdirfree_free_insert(e10k_fdirfree_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirfree_t e10k_fdirfree_free_insert(e10k_fdirfree_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fdirfree_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_fdirfree_coll_extract(e10k_fdirfree_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirfree_coll_extract(e10k_fdirfree_t _regval)
{
    return((uint16_t )((_regval & 0x7fff0000) >> 16));
}

static inline e10k_fdirfree_t e10k_fdirfree_coll_insert(e10k_fdirfree_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirfree_t e10k_fdirfree_coll_insert(e10k_fdirfree_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x8000ffff) | (0x7fff0000 & (((e10k_fdirfree_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirfree_prtval(char *_s, size_t _size, e10k_fdirfree_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirfree_prtval(char *_s, size_t _size, e10k_fdirfree_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " free =\t%" PRIx16 "\t(Number of free filters in the flow director Filters logic)\n", e10k_fdirfree_free_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " coll =\t%" PRIx16 "\t(Number of filters with collision indication)\n", e10k_fdirfree_coll_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirlen_t
 * Description: Implicit type of Flow Director Filters Length register
 * Fields:
 *   maxlen	(size 6, offset 0, init 0):	RC	Longest linked list of filters in the table
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   bucket_len	(size 6, offset 8, init 0):	RC	The length of the linked list indicated by a query command
 *   _anon14	(size 2, offset 14, init 0):	RSVD	_
 *   maxhash	(size 15, offset 16, init 0):	RC	Hash value of the filter that updated the value of the MAXLEN
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_fdirlen_t;
#define e10k_fdirlen_default 0x0
static inline uint8_t e10k_fdirlen_maxlen_extract(e10k_fdirlen_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirlen_maxlen_extract(e10k_fdirlen_t _regval)
{
    return((uint8_t )((_regval & 0x3f) >> 0));
}

static inline e10k_fdirlen_t e10k_fdirlen_maxlen_insert(e10k_fdirlen_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirlen_t e10k_fdirlen_maxlen_insert(e10k_fdirlen_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffc0) | (0x3f & (((e10k_fdirlen_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_fdirlen_bucket_len_extract(e10k_fdirlen_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirlen_bucket_len_extract(e10k_fdirlen_t _regval)
{
    return((uint8_t )((_regval & 0x3f00) >> 8));
}

static inline e10k_fdirlen_t e10k_fdirlen_bucket_len_insert(e10k_fdirlen_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirlen_t e10k_fdirlen_bucket_len_insert(e10k_fdirlen_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffc0ff) | (0x3f00 & (((e10k_fdirlen_t )(_fieldval)) << 8)));
}

static inline uint16_t e10k_fdirlen_maxhash_extract(e10k_fdirlen_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirlen_maxhash_extract(e10k_fdirlen_t _regval)
{
    return((uint16_t )((_regval & 0x7fff0000) >> 16));
}

static inline e10k_fdirlen_t e10k_fdirlen_maxhash_insert(e10k_fdirlen_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirlen_t e10k_fdirlen_maxhash_insert(e10k_fdirlen_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x8000ffff) | (0x7fff0000 & (((e10k_fdirlen_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirlen_prtval(char *_s, size_t _size, e10k_fdirlen_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirlen_prtval(char *_s, size_t _size, e10k_fdirlen_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxlen =\t%" PRIx8 "\t(Longest linked list of filters in the table)\n", e10k_fdirlen_maxlen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bucket_len =\t%" PRIx8 "\t(The length of the linked list indicated by a query command)\n", e10k_fdirlen_bucket_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxhash =\t%" PRIx16 "\t(Hash value of the filter that updated the value of the MAXLEN)\n", e10k_fdirlen_maxhash_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirustat_t
 * Description: Implicit type of Flow Director Filters Usage Statistics register
 * Fields:
 *   add	(size 16, offset 0, init 0):	RC	Number of added filters
 *   remove	(size 16, offset 16, init 0):	RC	Number of removed filters
 */
typedef uint32_t e10k_fdirustat_t;
#define e10k_fdirustat_default 0x0
static inline uint16_t e10k_fdirustat_add_extract(e10k_fdirustat_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirustat_add_extract(e10k_fdirustat_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fdirustat_t e10k_fdirustat_add_insert(e10k_fdirustat_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirustat_t e10k_fdirustat_add_insert(e10k_fdirustat_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fdirustat_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_fdirustat_remove_extract(e10k_fdirustat_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirustat_remove_extract(e10k_fdirustat_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_fdirustat_t e10k_fdirustat_remove_insert(e10k_fdirustat_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirustat_t e10k_fdirustat_remove_insert(e10k_fdirustat_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_fdirustat_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirustat_prtval(char *_s, size_t _size, e10k_fdirustat_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirustat_prtval(char *_s, size_t _size, e10k_fdirustat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " add =\t%" PRIx16 "\t(Number of added filters)\n", e10k_fdirustat_add_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " remove =\t%" PRIx16 "\t(Number of removed filters)\n", e10k_fdirustat_remove_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirfstat_t
 * Description: Implicit type of Flow Director Filters Failed Usage Statistics register
 * Fields:
 *   fadd	(size 8, offset 0, init 0):	RC	Number of failed added filters
 *   fremove	(size 8, offset 8, init 0):	RC	Number of failed removed filters
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_fdirfstat_t;
#define e10k_fdirfstat_default 0x0
static inline uint8_t e10k_fdirfstat_fadd_extract(e10k_fdirfstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirfstat_fadd_extract(e10k_fdirfstat_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e10k_fdirfstat_t e10k_fdirfstat_fadd_insert(e10k_fdirfstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirfstat_t e10k_fdirfstat_fadd_insert(e10k_fdirfstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_fdirfstat_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_fdirfstat_fremove_extract(e10k_fdirfstat_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirfstat_fremove_extract(e10k_fdirfstat_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e10k_fdirfstat_t e10k_fdirfstat_fremove_insert(e10k_fdirfstat_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirfstat_t e10k_fdirfstat_fremove_insert(e10k_fdirfstat_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e10k_fdirfstat_t )(_fieldval)) << 8)));
}

static inline int e10k_fdirfstat_prtval(char *_s, size_t _size, e10k_fdirfstat_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirfstat_prtval(char *_s, size_t _size, e10k_fdirfstat_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fadd =\t%" PRIx8 "\t(Number of failed added filters)\n", e10k_fdirfstat_fadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fremove =\t%" PRIx8 "\t(Number of failed removed filters)\n", e10k_fdirfstat_fremove_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirmatch_t
 * Description: Implicit type of Flow Director Filters Match Statistics register
 * Fields:
 *   pcnt	(size 32, offset 0, init 0):	RC	Number of packets that matched any flow director filter
 */
typedef uint32_t e10k_fdirmatch_t;
#define e10k_fdirmatch_default 0x0
static inline uint32_t e10k_fdirmatch_pcnt_extract(e10k_fdirmatch_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirmatch_pcnt_extract(e10k_fdirmatch_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdirmatch_t e10k_fdirmatch_pcnt_insert(e10k_fdirmatch_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirmatch_t e10k_fdirmatch_pcnt_insert(e10k_fdirmatch_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdirmatch_t )(_fieldval)) << 0)));
}

static inline int e10k_fdirmatch_prtval(char *_s, size_t _size, e10k_fdirmatch_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirmatch_prtval(char *_s, size_t _size, e10k_fdirmatch_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcnt =\t%" PRIx32 "\t(Number of packets that matched any flow director filter)\n", e10k_fdirmatch_pcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirmiss_t
 * Description: Implicit type of Flow Director Filters Miss Match Statistics register
 * Fields:
 *   pcnt	(size 32, offset 0, init 0):	RC	Number of packets that missed matched any flow director filter
 */
typedef uint32_t e10k_fdirmiss_t;
#define e10k_fdirmiss_default 0x0
static inline uint32_t e10k_fdirmiss_pcnt_extract(e10k_fdirmiss_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirmiss_pcnt_extract(e10k_fdirmiss_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdirmiss_t e10k_fdirmiss_pcnt_insert(e10k_fdirmiss_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirmiss_t e10k_fdirmiss_pcnt_insert(e10k_fdirmiss_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdirmiss_t )(_fieldval)) << 0)));
}

static inline int e10k_fdirmiss_prtval(char *_s, size_t _size, e10k_fdirmiss_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirmiss_prtval(char *_s, size_t _size, e10k_fdirmiss_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcnt =\t%" PRIx32 "\t(Number of packets that missed matched any flow director filter)\n", e10k_fdirmiss_pcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirsipv6_t
 * Description: Implicit type of Flow Director Filters Source IPv6 register array
 * Fields:
 *   ip6sa	(size 32, offset 0, init 0):	NOATTR	Three MS DWords of the source IPv6 address
 */
typedef uint32_t e10k_fdirsipv6_t;
#define e10k_fdirsipv6_default 0x0
static inline uint32_t e10k_fdirsipv6_ip6sa_extract(e10k_fdirsipv6_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirsipv6_ip6sa_extract(e10k_fdirsipv6_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdirsipv6_t e10k_fdirsipv6_ip6sa_insert(e10k_fdirsipv6_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirsipv6_t e10k_fdirsipv6_ip6sa_insert(e10k_fdirsipv6_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdirsipv6_t )(_fieldval)) << 0)));
}

static inline int e10k_fdirsipv6_prtval(char *_s, size_t _size, e10k_fdirsipv6_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirsipv6_prtval(char *_s, size_t _size, e10k_fdirsipv6_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ip6sa =\t%" PRIx32 "\t(Three MS DWords of the source IPv6 address)\n", e10k_fdirsipv6_ip6sa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdiripsa_t
 * Description: Implicit type of Flow Director Filters IP SA register
 * Fields:
 *   ip4sa	(size 32, offset 0, init 0):	RW	Source IPv4 address or LS Dword of the Source IPv6 address
 */
typedef uint32_t e10k_fdiripsa_t;
#define e10k_fdiripsa_default 0x0
static inline uint32_t e10k_fdiripsa_ip4sa_extract(e10k_fdiripsa_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdiripsa_ip4sa_extract(e10k_fdiripsa_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdiripsa_t e10k_fdiripsa_ip4sa_insert(e10k_fdiripsa_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdiripsa_t e10k_fdiripsa_ip4sa_insert(e10k_fdiripsa_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdiripsa_t )(_fieldval)) << 0)));
}

static inline int e10k_fdiripsa_prtval(char *_s, size_t _size, e10k_fdiripsa_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdiripsa_prtval(char *_s, size_t _size, e10k_fdiripsa_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ip4sa =\t%" PRIx32 "\t(Source IPv4 address or LS Dword of the Source IPv6 address)\n", e10k_fdiripsa_ip4sa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdiripda_t
 * Description: Implicit type of Flow Director Filters IP DA register
 * Fields:
 *   ip4da	(size 32, offset 0, init 0):	RW	Destination IPv4 address
 */
typedef uint32_t e10k_fdiripda_t;
#define e10k_fdiripda_default 0x0
static inline uint32_t e10k_fdiripda_ip4da_extract(e10k_fdiripda_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fdiripda_ip4da_extract(e10k_fdiripda_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fdiripda_t e10k_fdiripda_ip4da_insert(e10k_fdiripda_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdiripda_t e10k_fdiripda_ip4da_insert(e10k_fdiripda_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fdiripda_t )(_fieldval)) << 0)));
}

static inline int e10k_fdiripda_prtval(char *_s, size_t _size, e10k_fdiripda_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdiripda_prtval(char *_s, size_t _size, e10k_fdiripda_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ip4da =\t%" PRIx32 "\t(Destination IPv4 address)\n", e10k_fdiripda_ip4da_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirport_t
 * Description: Implicit type of Flow Director Filters Port register
 * Fields:
 *   source	(size 16, offset 0, init 0):	RW	Source Port number
 *   dest	(size 16, offset 16, init 0):	RW	Destination Port number
 */
typedef uint32_t e10k_fdirport_t;
#define e10k_fdirport_default 0x0
static inline uint16_t e10k_fdirport_source_extract(e10k_fdirport_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirport_source_extract(e10k_fdirport_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fdirport_t e10k_fdirport_source_insert(e10k_fdirport_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirport_t e10k_fdirport_source_insert(e10k_fdirport_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fdirport_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_fdirport_dest_extract(e10k_fdirport_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirport_dest_extract(e10k_fdirport_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_fdirport_t e10k_fdirport_dest_insert(e10k_fdirport_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirport_t e10k_fdirport_dest_insert(e10k_fdirport_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_fdirport_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirport_prtval(char *_s, size_t _size, e10k_fdirport_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirport_prtval(char *_s, size_t _size, e10k_fdirport_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " source =\t%" PRIx16 "\t(Source Port number)\n", e10k_fdirport_source_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dest =\t%" PRIx16 "\t(Destination Port number)\n", e10k_fdirport_dest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirvlan_t
 * Description: Implicit type of Flow Director Filters VLAN and FLEX Bytes register
 * Fields:
 *   vlan	(size 16, offset 0, init 0):	RW	Vlan Tag
 *   flex	(size 16, offset 16, init 0):	RW	Flexible tuple data
 */
typedef uint32_t e10k_fdirvlan_t;
#define e10k_fdirvlan_default 0x0
static inline uint16_t e10k_fdirvlan_vlan_extract(e10k_fdirvlan_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirvlan_vlan_extract(e10k_fdirvlan_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_fdirvlan_t e10k_fdirvlan_vlan_insert(e10k_fdirvlan_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirvlan_t e10k_fdirvlan_vlan_insert(e10k_fdirvlan_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_fdirvlan_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_fdirvlan_flex_extract(e10k_fdirvlan_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirvlan_flex_extract(e10k_fdirvlan_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_fdirvlan_t e10k_fdirvlan_flex_insert(e10k_fdirvlan_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirvlan_t e10k_fdirvlan_flex_insert(e10k_fdirvlan_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_fdirvlan_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirvlan_prtval(char *_s, size_t _size, e10k_fdirvlan_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirvlan_prtval(char *_s, size_t _size, e10k_fdirvlan_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan =\t%" PRIx16 "\t(Vlan Tag)\n", e10k_fdirvlan_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex =\t%" PRIx16 "\t(Flexible tuple data)\n", e10k_fdirvlan_flex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdirhash_t
 * Description: Implicit type of Flow Director Filters Hash Signature register
 * Fields:
 *   hash	(size 15, offset 0, init 0):	RW	Bucket hash value that identifies a filter's linked list
 *   buck_valid	(size 1, offset 15, init 0):	RW	Bucket Valid (at least 1 filter in bucket)
 *   sig_swidx	(size 15, offset 16, init 0):	RW	Signature / SW Index
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_fdirhash_t;
#define e10k_fdirhash_default 0x0
static inline uint16_t e10k_fdirhash_hash_extract(e10k_fdirhash_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirhash_hash_extract(e10k_fdirhash_t _regval)
{
    return((uint16_t )((_regval & 0x7fff) >> 0));
}

static inline e10k_fdirhash_t e10k_fdirhash_hash_insert(e10k_fdirhash_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirhash_t e10k_fdirhash_hash_insert(e10k_fdirhash_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff8000) | (0x7fff & (((e10k_fdirhash_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_fdirhash_buck_valid_extract(e10k_fdirhash_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirhash_buck_valid_extract(e10k_fdirhash_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_fdirhash_t e10k_fdirhash_buck_valid_insert(e10k_fdirhash_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirhash_t e10k_fdirhash_buck_valid_insert(e10k_fdirhash_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_fdirhash_t )(_fieldval)) << 15)));
}

static inline uint16_t e10k_fdirhash_sig_swidx_extract(e10k_fdirhash_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirhash_sig_swidx_extract(e10k_fdirhash_t _regval)
{
    return((uint16_t )((_regval & 0x7fff0000) >> 16));
}

static inline e10k_fdirhash_t e10k_fdirhash_sig_swidx_insert(e10k_fdirhash_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdirhash_t e10k_fdirhash_sig_swidx_insert(e10k_fdirhash_t _regval, uint16_t _fieldval)
{
    return((_regval & 0x8000ffff) | (0x7fff0000 & (((e10k_fdirhash_t )(_fieldval)) << 16)));
}

static inline int e10k_fdirhash_prtval(char *_s, size_t _size, e10k_fdirhash_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdirhash_prtval(char *_s, size_t _size, e10k_fdirhash_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hash =\t%" PRIx16 "\t(Bucket hash value that identifies a filter's linked list)\n", e10k_fdirhash_hash_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " buck_valid =\t%" PRIx8 "\t(Bucket Valid (at least 1 filter in bucket))\n", e10k_fdirhash_buck_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sig_swidx =\t%" PRIx16 "\t(Signature / SW Index)\n", e10k_fdirhash_sig_swidx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fdircmd_t
 * Description: Implicit type of Flow Director Filters Command Register register
 * Fields:
 *   cmd	(size 2, offset 0, init 0):	RW	Flow Director Filter Programming Command
 *   flt_valid	(size 1, offset 2, init 0):	RW	Valid filter is found by the query command
 *   flt_update	(size 1, offset 3, init 0):	RW	Filter Update Command
 *   ipv6_dmatch	(size 1, offset 4, init 0):	RW	IP Destination match to IP6AT filter
 *   l4type	(size 2, offset 5, init 0):	RW	l4type
 *   ipv6	(size 1, offset 7, init 0):	RW	IPv6 packet type
 *   clearht	(size 1, offset 8, init 0):	RW	Clear Internal Flow Director Head and Tail Registers
 *   drop	(size 1, offset 9, init 0):	RW	Packet Drop Action
 *   int	(size 1, offset 10, init 0):	RW	Matched packet generates a LLI
 *   last	(size 1, offset 11, init 0):	RW	Last filter indication in the linked list
 *   collision	(size 1, offset 12, init 0):	RW	Collision Indication
 *   _anon13	(size 2, offset 13, init 0):	RSVD	_
 *   queue_en	(size 1, offset 15, init 0):	RW	Enable routing matched packet to Rx-Queue
 *   rx_queue	(size 7, offset 16, init 0):	RW	Rx Queue Index
 *   _anon23	(size 1, offset 23, init 0):	RSVD	_
 *   pool	(size 6, offset 24, init 0):	RW	Pool (only for VT)
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
typedef uint32_t e10k_fdircmd_t;
#define e10k_fdircmd_default 0x0
static inline e10k_fdir_cmd_t e10k_fdircmd_cmd_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline e10k_fdir_cmd_t e10k_fdircmd_cmd_extract(e10k_fdircmd_t _regval)
{
    return((e10k_fdir_cmd_t )((_regval & 0x3) >> 0));
}

static inline e10k_fdircmd_t e10k_fdircmd_cmd_insert(e10k_fdircmd_t _regval, e10k_fdir_cmd_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_cmd_insert(e10k_fdircmd_t _regval, e10k_fdir_cmd_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e10k_fdircmd_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_fdircmd_flt_valid_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_flt_valid_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_fdircmd_t e10k_fdircmd_flt_valid_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_flt_valid_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_fdircmd_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_fdircmd_flt_update_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_flt_update_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_fdircmd_t e10k_fdircmd_flt_update_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_flt_update_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_fdircmd_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_fdircmd_ipv6_dmatch_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_ipv6_dmatch_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_fdircmd_t e10k_fdircmd_ipv6_dmatch_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_ipv6_dmatch_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_fdircmd_t )(_fieldval)) << 4)));
}

static inline e10k_l4_ptype_t e10k_fdircmd_l4type_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline e10k_l4_ptype_t e10k_fdircmd_l4type_extract(e10k_fdircmd_t _regval)
{
    return((e10k_l4_ptype_t )((_regval & 0x60) >> 5));
}

static inline e10k_fdircmd_t e10k_fdircmd_l4type_insert(e10k_fdircmd_t _regval, e10k_l4_ptype_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_l4type_insert(e10k_fdircmd_t _regval, e10k_l4_ptype_t _fieldval)
{
    return((_regval & 0xffffff9f) | (0x60 & (((e10k_fdircmd_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_fdircmd_ipv6_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_ipv6_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_fdircmd_t e10k_fdircmd_ipv6_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_ipv6_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_fdircmd_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_fdircmd_clearht_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_clearht_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_fdircmd_t e10k_fdircmd_clearht_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_clearht_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_fdircmd_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_fdircmd_drop_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_drop_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_fdircmd_t e10k_fdircmd_drop_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_drop_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_fdircmd_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_fdircmd_int_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_int_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_fdircmd_t e10k_fdircmd_int_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_int_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_fdircmd_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_fdircmd_last_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_last_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_fdircmd_t e10k_fdircmd_last_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_last_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_fdircmd_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_fdircmd_collision_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_collision_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_fdircmd_t e10k_fdircmd_collision_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_collision_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_fdircmd_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_fdircmd_queue_en_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_queue_en_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_fdircmd_t e10k_fdircmd_queue_en_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_queue_en_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_fdircmd_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_fdircmd_rx_queue_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_rx_queue_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x7f0000) >> 16));
}

static inline e10k_fdircmd_t e10k_fdircmd_rx_queue_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_rx_queue_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff80ffff) | (0x7f0000 & (((e10k_fdircmd_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_fdircmd_pool_extract(e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_pool_extract(e10k_fdircmd_t _regval)
{
    return((uint8_t )((_regval & 0x3f000000) >> 24));
}

static inline e10k_fdircmd_t e10k_fdircmd_pool_insert(e10k_fdircmd_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_pool_insert(e10k_fdircmd_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xc0ffffff) | (0x3f000000 & (((e10k_fdircmd_t )(_fieldval)) << 24)));
}

static inline int e10k_fdircmd_prtval(char *_s, size_t _size, e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline int e10k_fdircmd_prtval(char *_s, size_t _size, e10k_fdircmd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdir_cmd_prtval(_s + _r, _avail, e10k_fdircmd_cmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Flow Director Filter Programming Command)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flt_valid =\t%" PRIx8 "\t(Valid filter is found by the query command)\n", e10k_fdircmd_flt_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flt_update =\t%" PRIx8 "\t(Filter Update Command)\n", e10k_fdircmd_flt_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6_dmatch =\t%" PRIx8 "\t(IP Destination match to IP6AT filter)\n", e10k_fdircmd_ipv6_dmatch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_l4_ptype_prtval(_s + _r, _avail, e10k_fdircmd_l4type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(l4type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(IPv6 packet type)\n", e10k_fdircmd_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clearht =\t%" PRIx8 "\t(Clear Internal Flow Director Head and Tail Registers)\n", e10k_fdircmd_clearht_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop =\t%" PRIx8 "\t(Packet Drop Action)\n", e10k_fdircmd_drop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int =\t%" PRIx8 "\t(Matched packet generates a LLI)\n", e10k_fdircmd_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " last =\t%" PRIx8 "\t(Last filter indication in the linked list)\n", e10k_fdircmd_last_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " collision =\t%" PRIx8 "\t(Collision Indication)\n", e10k_fdircmd_collision_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_en =\t%" PRIx8 "\t(Enable routing matched packet to Rx-Queue)\n", e10k_fdircmd_queue_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_queue =\t%" PRIx8 "\t(Rx Queue Index)\n", e10k_fdircmd_rx_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool =\t%" PRIx8 "\t(Pool (only for VT))\n", e10k_fdircmd_pool_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcs1gcfig_t
 * Description: Implicit type of PCS_1G Global Config Register 1 register
 * Fields:
 *   _anon0	(size 30, offset 0, init 0):	RSVD	_
 *   pcs_isolate	(size 1, offset 30, init 0):	RW	Isolates the 1 GbE PCS logic from the MAC's data path
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcs1gcfig_t;
#define e10k_pcs1gcfig_default 0x0
static inline uint8_t e10k_pcs1gcfig_pcs_isolate_extract(e10k_pcs1gcfig_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gcfig_pcs_isolate_extract(e10k_pcs1gcfig_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_pcs1gcfig_t e10k_pcs1gcfig_pcs_isolate_insert(e10k_pcs1gcfig_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gcfig_t e10k_pcs1gcfig_pcs_isolate_insert(e10k_pcs1gcfig_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_pcs1gcfig_t )(_fieldval)) << 30)));
}

static inline int e10k_pcs1gcfig_prtval(char *_s, size_t _size, e10k_pcs1gcfig_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcs1gcfig_prtval(char *_s, size_t _size, e10k_pcs1gcfig_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcs_isolate =\t%" PRIx8 "\t(Isolates the 1 GbE PCS logic from the MAC's data path)\n", e10k_pcs1gcfig_pcs_isolate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcs1glctl_t
 * Description: Implicit type of PCG_1G link Control Register register
 * Fields:
 *   flv	(size 1, offset 0, init 0):	RW	Forced Link 1 GbE Value
 *   _anon1	(size 4, offset 1, init 0):	RSVD	_
 *   force1glnk	(size 1, offset 5, init 0):	RW	Force 1 GbE Link
 *   lnk_latchl	(size 1, offset 6, init 0):	RW	Link Latch Low Enable
 *   _anon7	(size 11, offset 7, init 0):	RSVD	_
 *   an_1gto	(size 1, offset 18, init 0):	RW	Auto Negotiation 1 GbE Timeout Enable
 *   _anon19	(size 6, offset 19, init 0):	RSVD	_
 *   lnk_okfixen	(size 1, offset 25, init 0):	RW	Link OK Fix En
 *   _anon26	(size 6, offset 26, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcs1glctl_t;
#define e10k_pcs1glctl_default 0x0
static inline uint8_t e10k_pcs1glctl_flv_extract(e10k_pcs1glctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_flv_extract(e10k_pcs1glctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_pcs1glctl_t e10k_pcs1glctl_flv_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glctl_t e10k_pcs1glctl_flv_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_pcs1glctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_pcs1glctl_force1glnk_extract(e10k_pcs1glctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_force1glnk_extract(e10k_pcs1glctl_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_pcs1glctl_t e10k_pcs1glctl_force1glnk_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glctl_t e10k_pcs1glctl_force1glnk_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_pcs1glctl_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_pcs1glctl_lnk_latchl_extract(e10k_pcs1glctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_lnk_latchl_extract(e10k_pcs1glctl_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_pcs1glctl_t e10k_pcs1glctl_lnk_latchl_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glctl_t e10k_pcs1glctl_lnk_latchl_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_pcs1glctl_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_pcs1glctl_an_1gto_extract(e10k_pcs1glctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_an_1gto_extract(e10k_pcs1glctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_pcs1glctl_t e10k_pcs1glctl_an_1gto_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glctl_t e10k_pcs1glctl_an_1gto_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_pcs1glctl_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_pcs1glctl_lnk_okfixen_extract(e10k_pcs1glctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_lnk_okfixen_extract(e10k_pcs1glctl_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_pcs1glctl_t e10k_pcs1glctl_lnk_okfixen_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glctl_t e10k_pcs1glctl_lnk_okfixen_insert(e10k_pcs1glctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_pcs1glctl_t )(_fieldval)) << 25)));
}

static inline int e10k_pcs1glctl_prtval(char *_s, size_t _size, e10k_pcs1glctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcs1glctl_prtval(char *_s, size_t _size, e10k_pcs1glctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flv =\t%" PRIx8 "\t(Forced Link 1 GbE Value)\n", e10k_pcs1glctl_flv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " force1glnk =\t%" PRIx8 "\t(Force 1 GbE Link)\n", e10k_pcs1glctl_force1glnk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_latchl =\t%" PRIx8 "\t(Link Latch Low Enable)\n", e10k_pcs1glctl_lnk_latchl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_1gto =\t%" PRIx8 "\t(Auto Negotiation 1 GbE Timeout Enable)\n", e10k_pcs1glctl_an_1gto_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_okfixen =\t%" PRIx8 "\t(Link OK Fix En)\n", e10k_pcs1glctl_lnk_okfixen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcs1glsta_t
 * Description: Implicit type of PCS_1G Link Status Register register
 * Fields:
 *   _anon0	(size 4, offset 0, init 0):	RSVD	_
 *   syncok_1g	(size 1, offset 4, init 0):	RO	Sync OK 1 GbE
 *   _anon5	(size 11, offset 5, init 0):	RSVD	_
 *   an_1gcompl	(size 1, offset 16, init 0):	RO	Auto Negotiation1 GbE Complete
 *   an_pagercv	(size 1, offset 17, init 0):	RO	Auto-Negotiation Page Received
 *   an_1gto	(size 1, offset 18, init 0):	RO	Auto Negotiation1 GbE Timed Out
 *   an_remflt	(size 1, offset 19, init 0):	RO	Auto Negotiation Remote Fault
 *   an_error	(size 1, offset 20, init 0):	RW	Auto Negotiation Error
 *   _anon21	(size 11, offset 21, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcs1glsta_t;
#define e10k_pcs1glsta_default 0x0
static inline uint8_t e10k_pcs1glsta_syncok_1g_extract(e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_syncok_1g_extract(e10k_pcs1glsta_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_pcs1glsta_t e10k_pcs1glsta_syncok_1g_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glsta_t e10k_pcs1glsta_syncok_1g_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_pcs1glsta_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_pcs1glsta_an_1gcompl_extract(e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_1gcompl_extract(e10k_pcs1glsta_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_1gcompl_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_1gcompl_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_pcs1glsta_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_pcs1glsta_an_pagercv_extract(e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_pagercv_extract(e10k_pcs1glsta_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_pagercv_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_pagercv_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_pcs1glsta_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_pcs1glsta_an_1gto_extract(e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_1gto_extract(e10k_pcs1glsta_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_1gto_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_1gto_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_pcs1glsta_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_pcs1glsta_an_remflt_extract(e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_remflt_extract(e10k_pcs1glsta_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_remflt_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_remflt_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_pcs1glsta_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_pcs1glsta_an_error_extract(e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_error_extract(e10k_pcs1glsta_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_error_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1glsta_t e10k_pcs1glsta_an_error_insert(e10k_pcs1glsta_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_pcs1glsta_t )(_fieldval)) << 20)));
}

static inline int e10k_pcs1glsta_prtval(char *_s, size_t _size, e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcs1glsta_prtval(char *_s, size_t _size, e10k_pcs1glsta_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " syncok_1g =\t%" PRIx8 "\t(Sync OK 1 GbE)\n", e10k_pcs1glsta_syncok_1g_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_1gcompl =\t%" PRIx8 "\t(Auto Negotiation1 GbE Complete)\n", e10k_pcs1glsta_an_1gcompl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_pagercv =\t%" PRIx8 "\t(Auto-Negotiation Page Received)\n", e10k_pcs1glsta_an_pagercv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_1gto =\t%" PRIx8 "\t(Auto Negotiation1 GbE Timed Out)\n", e10k_pcs1glsta_an_1gto_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_remflt =\t%" PRIx8 "\t(Auto Negotiation Remote Fault)\n", e10k_pcs1glsta_an_remflt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_error =\t%" PRIx8 "\t(Auto Negotiation Error)\n", e10k_pcs1glsta_an_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcs1gana_t
 * Description: Implicit type of PCS_1 Gb/s Auto Negotiation Advanced Register register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   fdc	(size 1, offset 5, init 0):	RW	FD: Full-Duplex
 *   _anon6	(size 1, offset 6, init 0):	RSVD	_
 *   asm	(size 2, offset 7, init 0):	RW	Local PAUSE Capabilities
 *   _anon9	(size 3, offset 9, init 0):	RSVD	_
 *   rflt	(size 2, offset 12, init 0):	RW	Remote Fault
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   nextp	(size 1, offset 15, init 0):	RW	NEXTP: Next Page Capable
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcs1gana_t;
#define e10k_pcs1gana_default 0x0
static inline uint8_t e10k_pcs1gana_fdc_extract(e10k_pcs1gana_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gana_fdc_extract(e10k_pcs1gana_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_pcs1gana_t e10k_pcs1gana_fdc_insert(e10k_pcs1gana_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gana_t e10k_pcs1gana_fdc_insert(e10k_pcs1gana_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_pcs1gana_t )(_fieldval)) << 5)));
}

static inline e10k_pause_cap_t e10k_pcs1gana_asm_extract(e10k_pcs1gana_t _regval) __attribute__ ((always_inline));
static inline e10k_pause_cap_t e10k_pcs1gana_asm_extract(e10k_pcs1gana_t _regval)
{
    return((e10k_pause_cap_t )((_regval & 0x180) >> 7));
}

static inline e10k_pcs1gana_t e10k_pcs1gana_asm_insert(e10k_pcs1gana_t _regval, e10k_pause_cap_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gana_t e10k_pcs1gana_asm_insert(e10k_pcs1gana_t _regval, e10k_pause_cap_t _fieldval)
{
    return((_regval & 0xfffffe7f) | (0x180 & (((e10k_pcs1gana_t )(_fieldval)) << 7)));
}

static inline e10k_remote_fault_t e10k_pcs1gana_rflt_extract(e10k_pcs1gana_t _regval) __attribute__ ((always_inline));
static inline e10k_remote_fault_t e10k_pcs1gana_rflt_extract(e10k_pcs1gana_t _regval)
{
    return((e10k_remote_fault_t )((_regval & 0x3000) >> 12));
}

static inline e10k_pcs1gana_t e10k_pcs1gana_rflt_insert(e10k_pcs1gana_t _regval, e10k_remote_fault_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gana_t e10k_pcs1gana_rflt_insert(e10k_pcs1gana_t _regval, e10k_remote_fault_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((e10k_pcs1gana_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_pcs1gana_nextp_extract(e10k_pcs1gana_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gana_nextp_extract(e10k_pcs1gana_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_pcs1gana_t e10k_pcs1gana_nextp_insert(e10k_pcs1gana_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gana_t e10k_pcs1gana_nextp_insert(e10k_pcs1gana_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_pcs1gana_t )(_fieldval)) << 15)));
}

static inline int e10k_pcs1gana_prtval(char *_s, size_t _size, e10k_pcs1gana_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcs1gana_prtval(char *_s, size_t _size, e10k_pcs1gana_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fdc =\t%" PRIx8 "\t(FD: Full-Duplex)\n", e10k_pcs1gana_fdc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pause_cap_prtval(_s + _r, _avail, e10k_pcs1gana_asm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Local PAUSE Capabilities)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rflt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_remote_fault_prtval(_s + _r, _avail, e10k_pcs1gana_rflt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Remote Fault)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nextp =\t%" PRIx8 "\t(NEXTP: Next Page Capable)\n", e10k_pcs1gana_nextp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcs1ganlp_t
 * Description: Implicit type of PCS_1GAN LP Ability Register register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   lpfd	(size 1, offset 5, init 0):	RO	LP Full-Duplex (SerDes)
 *   lphd	(size 1, offset 6, init 0):	RO	LP Half-Duplex (SerDes)
 *   lpasm	(size 2, offset 7, init 0):	RO	LP PAUSE capability
 *   _anon9	(size 3, offset 9, init 0):	RSVD	_
 *   prf	(size 2, offset 12, init 0):	RO	LP Remote Fault
 *   ack	(size 1, offset 14, init 0):	RO	LP acknowledged page reception
 *   lpnextp	(size 1, offset 15, init 0):	RO	LP Next Page Capable
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcs1ganlp_t;
#define e10k_pcs1ganlp_default 0x0
static inline uint8_t e10k_pcs1ganlp_lpfd_extract(e10k_pcs1ganlp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlp_lpfd_extract(e10k_pcs1ganlp_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_lpfd_insert(e10k_pcs1ganlp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_lpfd_insert(e10k_pcs1ganlp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_pcs1ganlp_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_pcs1ganlp_lphd_extract(e10k_pcs1ganlp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlp_lphd_extract(e10k_pcs1ganlp_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_lphd_insert(e10k_pcs1ganlp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_lphd_insert(e10k_pcs1ganlp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_pcs1ganlp_t )(_fieldval)) << 6)));
}

static inline e10k_pause_cap_t e10k_pcs1ganlp_lpasm_extract(e10k_pcs1ganlp_t _regval) __attribute__ ((always_inline));
static inline e10k_pause_cap_t e10k_pcs1ganlp_lpasm_extract(e10k_pcs1ganlp_t _regval)
{
    return((e10k_pause_cap_t )((_regval & 0x180) >> 7));
}

static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_lpasm_insert(e10k_pcs1ganlp_t _regval, e10k_pause_cap_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_lpasm_insert(e10k_pcs1ganlp_t _regval, e10k_pause_cap_t _fieldval)
{
    return((_regval & 0xfffffe7f) | (0x180 & (((e10k_pcs1ganlp_t )(_fieldval)) << 7)));
}

static inline e10k_remote_fault_t e10k_pcs1ganlp_prf_extract(e10k_pcs1ganlp_t _regval) __attribute__ ((always_inline));
static inline e10k_remote_fault_t e10k_pcs1ganlp_prf_extract(e10k_pcs1ganlp_t _regval)
{
    return((e10k_remote_fault_t )((_regval & 0x3000) >> 12));
}

static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_prf_insert(e10k_pcs1ganlp_t _regval, e10k_remote_fault_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_prf_insert(e10k_pcs1ganlp_t _regval, e10k_remote_fault_t _fieldval)
{
    return((_regval & 0xffffcfff) | (0x3000 & (((e10k_pcs1ganlp_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_pcs1ganlp_ack_extract(e10k_pcs1ganlp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlp_ack_extract(e10k_pcs1ganlp_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_ack_insert(e10k_pcs1ganlp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_ack_insert(e10k_pcs1ganlp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_pcs1ganlp_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_pcs1ganlp_lpnextp_extract(e10k_pcs1ganlp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlp_lpnextp_extract(e10k_pcs1ganlp_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_lpnextp_insert(e10k_pcs1ganlp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_lpnextp_insert(e10k_pcs1ganlp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_pcs1ganlp_t )(_fieldval)) << 15)));
}

static inline int e10k_pcs1ganlp_prtval(char *_s, size_t _size, e10k_pcs1ganlp_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcs1ganlp_prtval(char *_s, size_t _size, e10k_pcs1ganlp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpfd =\t%" PRIx8 "\t(LP Full-Duplex (SerDes))\n", e10k_pcs1ganlp_lpfd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lphd =\t%" PRIx8 "\t(LP Half-Duplex (SerDes))\n", e10k_pcs1ganlp_lphd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpasm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pause_cap_prtval(_s + _r, _avail, e10k_pcs1ganlp_lpasm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LP PAUSE capability)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prf =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_remote_fault_prtval(_s + _r, _avail, e10k_pcs1ganlp_prf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LP Remote Fault)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(LP acknowledged page reception)\n", e10k_pcs1ganlp_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpnextp =\t%" PRIx8 "\t(LP Next Page Capable)\n", e10k_pcs1ganlp_lpnextp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcs1gannp_t
 * Description: Implicit type of PCS_1G Auto Negotiation Next Page Transmit Register register
 * Fields:
 *   code	(size 11, offset 0, init 0):	RW	Message/Unformatted Code Field
 *   toggle	(size 1, offset 11, init 0):	RW	Toggle
 *   ack2	(size 1, offset 12, init 0):	RW	Acknowledge2
 *   pgtype	(size 1, offset 13, init 0):	RW	Message/ Unformatted Page
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   nxtpg	(size 1, offset 15, init 0):	RW	Next Page
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcs1gannp_t;
#define e10k_pcs1gannp_default 0x0
static inline uint16_t e10k_pcs1gannp_code_extract(e10k_pcs1gannp_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_pcs1gannp_code_extract(e10k_pcs1gannp_t _regval)
{
    return((uint16_t )((_regval & 0x7ff) >> 0));
}

static inline e10k_pcs1gannp_t e10k_pcs1gannp_code_insert(e10k_pcs1gannp_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gannp_t e10k_pcs1gannp_code_insert(e10k_pcs1gannp_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff800) | (0x7ff & (((e10k_pcs1gannp_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_pcs1gannp_toggle_extract(e10k_pcs1gannp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gannp_toggle_extract(e10k_pcs1gannp_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_pcs1gannp_t e10k_pcs1gannp_toggle_insert(e10k_pcs1gannp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gannp_t e10k_pcs1gannp_toggle_insert(e10k_pcs1gannp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_pcs1gannp_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_pcs1gannp_ack2_extract(e10k_pcs1gannp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gannp_ack2_extract(e10k_pcs1gannp_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_pcs1gannp_t e10k_pcs1gannp_ack2_insert(e10k_pcs1gannp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gannp_t e10k_pcs1gannp_ack2_insert(e10k_pcs1gannp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_pcs1gannp_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_pcs1gannp_pgtype_extract(e10k_pcs1gannp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gannp_pgtype_extract(e10k_pcs1gannp_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_pcs1gannp_t e10k_pcs1gannp_pgtype_insert(e10k_pcs1gannp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gannp_t e10k_pcs1gannp_pgtype_insert(e10k_pcs1gannp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_pcs1gannp_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_pcs1gannp_nxtpg_extract(e10k_pcs1gannp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gannp_nxtpg_extract(e10k_pcs1gannp_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_pcs1gannp_t e10k_pcs1gannp_nxtpg_insert(e10k_pcs1gannp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1gannp_t e10k_pcs1gannp_nxtpg_insert(e10k_pcs1gannp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_pcs1gannp_t )(_fieldval)) << 15)));
}

static inline int e10k_pcs1gannp_prtval(char *_s, size_t _size, e10k_pcs1gannp_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcs1gannp_prtval(char *_s, size_t _size, e10k_pcs1gannp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code =\t%" PRIx16 "\t(Message/Unformatted Code Field)\n", e10k_pcs1gannp_code_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " toggle =\t%" PRIx8 "\t(Toggle)\n", e10k_pcs1gannp_toggle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack2 =\t%" PRIx8 "\t(Acknowledge2)\n", e10k_pcs1gannp_ack2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pgtype =\t%" PRIx8 "\t(Message/ Unformatted Page)\n", e10k_pcs1gannp_pgtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nxtpg =\t%" PRIx8 "\t(Next Page)\n", e10k_pcs1gannp_nxtpg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcs1ganlpnp_t
 * Description: Implicit type of PCS_1G Auto Negotiation LP's Next Page Register register
 * Fields:
 *   code	(size 11, offset 0, init 0):	RO	Message/Unformatted Code Field
 *   toggle	(size 1, offset 11, init 0):	RO	Toggle
 *   ack2	(size 1, offset 12, init 0):	RO	Acknowledge2
 *   msgpg	(size 1, offset 13, init 0):	RO	Message Page
 *   ack	(size 1, offset 14, init 0):	RO	LP has acknowledge next page reception
 *   nxtpg	(size 1, offset 15, init 0):	RO	Next Page
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcs1ganlpnp_t;
#define e10k_pcs1ganlpnp_default 0x0
static inline uint16_t e10k_pcs1ganlpnp_code_extract(e10k_pcs1ganlpnp_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_pcs1ganlpnp_code_extract(e10k_pcs1ganlpnp_t _regval)
{
    return((uint16_t )((_regval & 0x7ff) >> 0));
}

static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_code_insert(e10k_pcs1ganlpnp_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_code_insert(e10k_pcs1ganlpnp_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff800) | (0x7ff & (((e10k_pcs1ganlpnp_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_pcs1ganlpnp_toggle_extract(e10k_pcs1ganlpnp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_toggle_extract(e10k_pcs1ganlpnp_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_toggle_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_toggle_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_pcs1ganlpnp_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_pcs1ganlpnp_ack2_extract(e10k_pcs1ganlpnp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_ack2_extract(e10k_pcs1ganlpnp_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_ack2_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_ack2_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_pcs1ganlpnp_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_pcs1ganlpnp_msgpg_extract(e10k_pcs1ganlpnp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_msgpg_extract(e10k_pcs1ganlpnp_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_msgpg_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_msgpg_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_pcs1ganlpnp_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_pcs1ganlpnp_ack_extract(e10k_pcs1ganlpnp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_ack_extract(e10k_pcs1ganlpnp_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_ack_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_ack_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_pcs1ganlpnp_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_pcs1ganlpnp_nxtpg_extract(e10k_pcs1ganlpnp_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_nxtpg_extract(e10k_pcs1ganlpnp_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_nxtpg_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_nxtpg_insert(e10k_pcs1ganlpnp_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_pcs1ganlpnp_t )(_fieldval)) << 15)));
}

static inline int e10k_pcs1ganlpnp_prtval(char *_s, size_t _size, e10k_pcs1ganlpnp_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcs1ganlpnp_prtval(char *_s, size_t _size, e10k_pcs1ganlpnp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code =\t%" PRIx16 "\t(Message/Unformatted Code Field)\n", e10k_pcs1ganlpnp_code_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " toggle =\t%" PRIx8 "\t(Toggle)\n", e10k_pcs1ganlpnp_toggle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack2 =\t%" PRIx8 "\t(Acknowledge2)\n", e10k_pcs1ganlpnp_ack2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msgpg =\t%" PRIx8 "\t(Message Page)\n", e10k_pcs1ganlpnp_msgpg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(LP has acknowledge next page reception)\n", e10k_pcs1ganlpnp_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nxtpg =\t%" PRIx8 "\t(Next Page)\n", e10k_pcs1ganlpnp_nxtpg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_hlreg0_t
 * Description: Implicit type of MAC Core Control 0 Register register
 * Fields:
 *   txcrcen	(size 1, offset 0, init 0):	RW	Tx CRC Enable
 *   rxcrcstrp	(size 1, offset 1, init 0):	RW	Rx CRC Strip
 *   jumboen	(size 1, offset 2, init 0):	RW	Jumbo Frame Enable
 *   _anon3	(size 7, offset 3, init 0):	MBZ	_
 *   txpaden	(size 1, offset 10, init 0):	RW	Tx Pad Frame Enable
 *   _anon11	(size 4, offset 11, init 0):	RSVD	_
 *   lpbk	(size 1, offset 15, init 0):	RW	Loopback enabled
 *   mdcspd	(size 1, offset 16, init 0):	RW	MDC SPEED
 *   contmdc	(size 1, offset 17, init 0):	RW	Continuous MDC
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   prepend	(size 4, offset 20, init 0):	RW	Prepend Value
 *   _anon24	(size 3, offset 24, init 0):	RSVD	_
 *   rxlenerrr	(size 1, offset 27, init 0):	RW	Rx Length Error Reporting
 *   rxpadstrp	(size 1, offset 28, init 0):	RW	Rx Padding Strip Enable
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
typedef uint32_t e10k_hlreg0_t;
#define e10k_hlreg0_default 0x0
static inline uint8_t e10k_hlreg0_txcrcen_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_txcrcen_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_hlreg0_t e10k_hlreg0_txcrcen_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_txcrcen_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_hlreg0_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_hlreg0_rxcrcstrp_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_rxcrcstrp_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_hlreg0_t e10k_hlreg0_rxcrcstrp_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_rxcrcstrp_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_hlreg0_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_hlreg0_jumboen_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_jumboen_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_hlreg0_t e10k_hlreg0_jumboen_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_jumboen_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_hlreg0_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_hlreg0_txpaden_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_txpaden_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_hlreg0_t e10k_hlreg0_txpaden_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_txpaden_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_hlreg0_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_hlreg0_lpbk_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_lpbk_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_hlreg0_t e10k_hlreg0_lpbk_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_lpbk_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_hlreg0_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_hlreg0_mdcspd_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_mdcspd_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_hlreg0_t e10k_hlreg0_mdcspd_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_mdcspd_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_hlreg0_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_hlreg0_contmdc_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_contmdc_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_hlreg0_t e10k_hlreg0_contmdc_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_contmdc_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_hlreg0_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_hlreg0_prepend_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_prepend_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0xf00000) >> 20));
}

static inline e10k_hlreg0_t e10k_hlreg0_prepend_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_prepend_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff0fffff) | (0xf00000 & (((e10k_hlreg0_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_hlreg0_rxlenerrr_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_rxlenerrr_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_hlreg0_t e10k_hlreg0_rxlenerrr_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_rxlenerrr_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_hlreg0_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_hlreg0_rxpadstrp_extract(e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_rxpadstrp_extract(e10k_hlreg0_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_hlreg0_t e10k_hlreg0_rxpadstrp_insert(e10k_hlreg0_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_rxpadstrp_insert(e10k_hlreg0_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_hlreg0_t )(_fieldval)) << 28)));
}

static inline int e10k_hlreg0_prtval(char *_s, size_t _size, e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline int e10k_hlreg0_prtval(char *_s, size_t _size, e10k_hlreg0_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcrcen =\t%" PRIx8 "\t(Tx CRC Enable)\n", e10k_hlreg0_txcrcen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcrcstrp =\t%" PRIx8 "\t(Rx CRC Strip)\n", e10k_hlreg0_rxcrcstrp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jumboen =\t%" PRIx8 "\t(Jumbo Frame Enable)\n", e10k_hlreg0_jumboen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txpaden =\t%" PRIx8 "\t(Tx Pad Frame Enable)\n", e10k_hlreg0_txpaden_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpbk =\t%" PRIx8 "\t(Loopback enabled)\n", e10k_hlreg0_lpbk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdcspd =\t%" PRIx8 "\t(MDC SPEED)\n", e10k_hlreg0_mdcspd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " contmdc =\t%" PRIx8 "\t(Continuous MDC)\n", e10k_hlreg0_contmdc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prepend =\t%" PRIx8 "\t(Prepend Value)\n", e10k_hlreg0_prepend_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxlenerrr =\t%" PRIx8 "\t(Rx Length Error Reporting)\n", e10k_hlreg0_rxlenerrr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxpadstrp =\t%" PRIx8 "\t(Rx Padding Strip Enable)\n", e10k_hlreg0_rxpadstrp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_hlreg1_t
 * Description: Implicit type of MAC Core Status 1 Register register
 * Fields:
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rxerrsym	(size 1, offset 5, init 0):	RC	Error symbol received
 *   rxillsym	(size 1, offset 6, init 0):	RC	Illegal symbol received
 *   rxidleerr	(size 1, offset 7, init 0):	RC	Idle error received
 *   rxlclflt	(size 1, offset 8, init 0):	RC	Local fault is or was active
 *   rxrmtflt	(size 1, offset 9, init 0):	RC	Remote fault is or was active
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
typedef uint32_t e10k_hlreg1_t;
#define e10k_hlreg1_default 0x0
static inline uint8_t e10k_hlreg1_rxerrsym_extract(e10k_hlreg1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxerrsym_extract(e10k_hlreg1_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_hlreg1_t e10k_hlreg1_rxerrsym_insert(e10k_hlreg1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg1_t e10k_hlreg1_rxerrsym_insert(e10k_hlreg1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_hlreg1_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_hlreg1_rxillsym_extract(e10k_hlreg1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxillsym_extract(e10k_hlreg1_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_hlreg1_t e10k_hlreg1_rxillsym_insert(e10k_hlreg1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg1_t e10k_hlreg1_rxillsym_insert(e10k_hlreg1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_hlreg1_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_hlreg1_rxidleerr_extract(e10k_hlreg1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxidleerr_extract(e10k_hlreg1_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_hlreg1_t e10k_hlreg1_rxidleerr_insert(e10k_hlreg1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg1_t e10k_hlreg1_rxidleerr_insert(e10k_hlreg1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_hlreg1_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_hlreg1_rxlclflt_extract(e10k_hlreg1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxlclflt_extract(e10k_hlreg1_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_hlreg1_t e10k_hlreg1_rxlclflt_insert(e10k_hlreg1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg1_t e10k_hlreg1_rxlclflt_insert(e10k_hlreg1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_hlreg1_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_hlreg1_rxrmtflt_extract(e10k_hlreg1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxrmtflt_extract(e10k_hlreg1_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_hlreg1_t e10k_hlreg1_rxrmtflt_insert(e10k_hlreg1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_hlreg1_t e10k_hlreg1_rxrmtflt_insert(e10k_hlreg1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_hlreg1_t )(_fieldval)) << 9)));
}

static inline int e10k_hlreg1_prtval(char *_s, size_t _size, e10k_hlreg1_t _regval) __attribute__ ((always_inline));
static inline int e10k_hlreg1_prtval(char *_s, size_t _size, e10k_hlreg1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxerrsym =\t%" PRIx8 "\t(Error symbol received)\n", e10k_hlreg1_rxerrsym_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxillsym =\t%" PRIx8 "\t(Illegal symbol received)\n", e10k_hlreg1_rxillsym_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxidleerr =\t%" PRIx8 "\t(Idle error received)\n", e10k_hlreg1_rxidleerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxlclflt =\t%" PRIx8 "\t(Local fault is or was active)\n", e10k_hlreg1_rxlclflt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxrmtflt =\t%" PRIx8 "\t(Remote fault is or was active)\n", e10k_hlreg1_rxrmtflt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pap_t
 * Description: Implicit type of Pause and Pace Register register
 * Fields:
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   pace	(size 4, offset 16, init 0):	RW	Pace
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t e10k_pap_t;
#define e10k_pap_default 0x0
static inline e10k_pace_t e10k_pap_pace_extract(e10k_pap_t _regval) __attribute__ ((always_inline));
static inline e10k_pace_t e10k_pap_pace_extract(e10k_pap_t _regval)
{
    return((e10k_pace_t )((_regval & 0xf0000) >> 16));
}

static inline e10k_pap_t e10k_pap_pace_insert(e10k_pap_t _regval, e10k_pace_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pap_t e10k_pap_pace_insert(e10k_pap_t _regval, e10k_pace_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((e10k_pap_t )(_fieldval)) << 16)));
}

static inline int e10k_pap_prtval(char *_s, size_t _size, e10k_pap_t _regval) __attribute__ ((always_inline));
static inline int e10k_pap_prtval(char *_s, size_t _size, e10k_pap_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pace =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pace_prtval(_s + _r, _avail, e10k_pap_pace_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pace)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_msca_t
 * Description: Implicit type of MDI Single Command and Address register
 * Fields:
 *   mdiadd	(size 16, offset 0, init 0):	RW	MDI Address
 *   devadd	(size 5, offset 16, init 0):	RW	DeviceType/Register Address
 *   phyadd	(size 5, offset 21, init 0):	RW	PHY Address
 *   opcode	(size 2, offset 26, init 0):	RW	OP Code
 *   stcode	(size 2, offset 28, init 0):	RW	ST Code
 *   mdicmd	(size 1, offset 30, init 0):	RW	MDI Command
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_msca_t;
#define e10k_msca_default 0x0
static inline uint16_t e10k_msca_mdiadd_extract(e10k_msca_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_msca_mdiadd_extract(e10k_msca_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_msca_t e10k_msca_mdiadd_insert(e10k_msca_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_msca_t e10k_msca_mdiadd_insert(e10k_msca_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_msca_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_msca_devadd_extract(e10k_msca_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_msca_devadd_extract(e10k_msca_t _regval)
{
    return((uint8_t )((_regval & 0x1f0000) >> 16));
}

static inline e10k_msca_t e10k_msca_devadd_insert(e10k_msca_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_msca_t e10k_msca_devadd_insert(e10k_msca_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffe0ffff) | (0x1f0000 & (((e10k_msca_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_msca_phyadd_extract(e10k_msca_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_msca_phyadd_extract(e10k_msca_t _regval)
{
    return((uint8_t )((_regval & 0x3e00000) >> 21));
}

static inline e10k_msca_t e10k_msca_phyadd_insert(e10k_msca_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_msca_t e10k_msca_phyadd_insert(e10k_msca_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfc1fffff) | (0x3e00000 & (((e10k_msca_t )(_fieldval)) << 21)));
}

static inline e10k_mdi_opcode_t e10k_msca_opcode_extract(e10k_msca_t _regval) __attribute__ ((always_inline));
static inline e10k_mdi_opcode_t e10k_msca_opcode_extract(e10k_msca_t _regval)
{
    return((e10k_mdi_opcode_t )((_regval & 0xc000000) >> 26));
}

static inline e10k_msca_t e10k_msca_opcode_insert(e10k_msca_t _regval, e10k_mdi_opcode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_msca_t e10k_msca_opcode_insert(e10k_msca_t _regval, e10k_mdi_opcode_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((e10k_msca_t )(_fieldval)) << 26)));
}

static inline e10k_mdi_stcode_t e10k_msca_stcode_extract(e10k_msca_t _regval) __attribute__ ((always_inline));
static inline e10k_mdi_stcode_t e10k_msca_stcode_extract(e10k_msca_t _regval)
{
    return((e10k_mdi_stcode_t )((_regval & 0x30000000) >> 28));
}

static inline e10k_msca_t e10k_msca_stcode_insert(e10k_msca_t _regval, e10k_mdi_stcode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_msca_t e10k_msca_stcode_insert(e10k_msca_t _regval, e10k_mdi_stcode_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((e10k_msca_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_msca_mdicmd_extract(e10k_msca_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_msca_mdicmd_extract(e10k_msca_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_msca_t e10k_msca_mdicmd_insert(e10k_msca_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_msca_t e10k_msca_mdicmd_insert(e10k_msca_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_msca_t )(_fieldval)) << 30)));
}

static inline int e10k_msca_prtval(char *_s, size_t _size, e10k_msca_t _regval) __attribute__ ((always_inline));
static inline int e10k_msca_prtval(char *_s, size_t _size, e10k_msca_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdiadd =\t%" PRIx16 "\t(MDI Address)\n", e10k_msca_mdiadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " devadd =\t%" PRIx8 "\t(DeviceType/Register Address)\n", e10k_msca_devadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phyadd =\t%" PRIx8 "\t(PHY Address)\n", e10k_msca_phyadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " opcode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mdi_opcode_prtval(_s + _r, _avail, e10k_msca_opcode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(OP Code)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stcode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mdi_stcode_prtval(_s + _r, _avail, e10k_msca_stcode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(ST Code)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdicmd =\t%" PRIx8 "\t(MDI Command)\n", e10k_msca_mdicmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_msrwd_t
 * Description: Implicit type of MDI Single Read and Write Data register
 * Fields:
 *   mdiwrdata	(size 16, offset 0, init 0):	RW	MDI Write Data
 *   mdirddata	(size 16, offset 16, init 0):	RW	MDI Read Data
 */
typedef uint32_t e10k_msrwd_t;
#define e10k_msrwd_default 0x0
static inline uint16_t e10k_msrwd_mdiwrdata_extract(e10k_msrwd_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_msrwd_mdiwrdata_extract(e10k_msrwd_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_msrwd_t e10k_msrwd_mdiwrdata_insert(e10k_msrwd_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_msrwd_t e10k_msrwd_mdiwrdata_insert(e10k_msrwd_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_msrwd_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_msrwd_mdirddata_extract(e10k_msrwd_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_msrwd_mdirddata_extract(e10k_msrwd_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_msrwd_t e10k_msrwd_mdirddata_insert(e10k_msrwd_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_msrwd_t e10k_msrwd_mdirddata_insert(e10k_msrwd_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_msrwd_t )(_fieldval)) << 16)));
}

static inline int e10k_msrwd_prtval(char *_s, size_t _size, e10k_msrwd_t _regval) __attribute__ ((always_inline));
static inline int e10k_msrwd_prtval(char *_s, size_t _size, e10k_msrwd_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdiwrdata =\t%" PRIx16 "\t(MDI Write Data)\n", e10k_msrwd_mdiwrdata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdirddata =\t%" PRIx16 "\t(MDI Read Data)\n", e10k_msrwd_mdirddata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_maxfrs_t
 * Description: Implicit type of Max Frame Size register
 * Fields:
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   mfs	(size 16, offset 16, init 0):	RW	Maximum frame size in bytes units
 */
typedef uint32_t e10k_maxfrs_t;
#define e10k_maxfrs_default 0x0
static inline uint16_t e10k_maxfrs_mfs_extract(e10k_maxfrs_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_maxfrs_mfs_extract(e10k_maxfrs_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_maxfrs_t e10k_maxfrs_mfs_insert(e10k_maxfrs_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_maxfrs_t e10k_maxfrs_mfs_insert(e10k_maxfrs_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_maxfrs_t )(_fieldval)) << 16)));
}

static inline int e10k_maxfrs_prtval(char *_s, size_t _size, e10k_maxfrs_t _regval) __attribute__ ((always_inline));
static inline int e10k_maxfrs_prtval(char *_s, size_t _size, e10k_maxfrs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mfs =\t%" PRIx16 "\t(Maximum frame size in bytes units)\n", e10k_maxfrs_mfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcss1_t
 * Description: Implicit type of XGXS Status 1 register
 * Fields:
 *   _anon0	(size 2, offset 0, init 0):	RSVD	_
 *   pcsrcvlnkup	(size 1, offset 2, init 0):	RO	PCS receive link up
 *   _anon3	(size 4, offset 3, init 0):	RSVD	_
 *   local_fault	(size 1, offset 7, init 0):	RO	LF detected on transmit or receive path
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcss1_t;
#define e10k_pcss1_default 0x0
static inline uint8_t e10k_pcss1_pcsrcvlnkup_extract(e10k_pcss1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss1_pcsrcvlnkup_extract(e10k_pcss1_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_pcss1_t e10k_pcss1_pcsrcvlnkup_insert(e10k_pcss1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcss1_t e10k_pcss1_pcsrcvlnkup_insert(e10k_pcss1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_pcss1_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_pcss1_local_fault_extract(e10k_pcss1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss1_local_fault_extract(e10k_pcss1_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_pcss1_t e10k_pcss1_local_fault_insert(e10k_pcss1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcss1_t e10k_pcss1_local_fault_insert(e10k_pcss1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_pcss1_t )(_fieldval)) << 7)));
}

static inline int e10k_pcss1_prtval(char *_s, size_t _size, e10k_pcss1_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcss1_prtval(char *_s, size_t _size, e10k_pcss1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcsrcvlnkup =\t%" PRIx8 "\t(PCS receive link up)\n", e10k_pcss1_pcsrcvlnkup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " local_fault =\t%" PRIx8 "\t(LF detected on transmit or receive path)\n", e10k_pcss1_local_fault_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pcss2_t
 * Description: Implicit type of XGXS Status 2 register
 * Fields:
 *   c10gbase_r	(size 1, offset 0, init 0):	RO	PCS is able to support 10GBASE-R port type
 *   c10gbase_x	(size 1, offset 1, init 0):	RO	PCS is able to support 10GBASE-X port type
 *   c10gbase_w	(size 1, offset 2, init 0):	RO	PCS is able to support 10GBASE-W port type
 *   _anon3	(size 7, offset 3, init 0):	RSVD	_
 *   rx_lfault	(size 1, offset 10, init 0):	RO	Local fault condition on the receive path
 *   tx_lfault	(size 1, offset 11, init 0):	RO	Local fault condition on the transmit path
 *   _anon12	(size 2, offset 12, init 0):	RSVD	_
 *   dev_present	(size 2, offset 14, init 0):	RO	Device present
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_pcss2_t;
#define e10k_pcss2_default 0x0
static inline uint8_t e10k_pcss2_c10gbase_r_extract(e10k_pcss2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_c10gbase_r_extract(e10k_pcss2_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_pcss2_t e10k_pcss2_c10gbase_r_insert(e10k_pcss2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcss2_t e10k_pcss2_c10gbase_r_insert(e10k_pcss2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_pcss2_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_pcss2_c10gbase_x_extract(e10k_pcss2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_c10gbase_x_extract(e10k_pcss2_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_pcss2_t e10k_pcss2_c10gbase_x_insert(e10k_pcss2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcss2_t e10k_pcss2_c10gbase_x_insert(e10k_pcss2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_pcss2_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_pcss2_c10gbase_w_extract(e10k_pcss2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_c10gbase_w_extract(e10k_pcss2_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_pcss2_t e10k_pcss2_c10gbase_w_insert(e10k_pcss2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcss2_t e10k_pcss2_c10gbase_w_insert(e10k_pcss2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_pcss2_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_pcss2_rx_lfault_extract(e10k_pcss2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_rx_lfault_extract(e10k_pcss2_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_pcss2_t e10k_pcss2_rx_lfault_insert(e10k_pcss2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcss2_t e10k_pcss2_rx_lfault_insert(e10k_pcss2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_pcss2_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_pcss2_tx_lfault_extract(e10k_pcss2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_tx_lfault_extract(e10k_pcss2_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_pcss2_t e10k_pcss2_tx_lfault_insert(e10k_pcss2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcss2_t e10k_pcss2_tx_lfault_insert(e10k_pcss2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_pcss2_t )(_fieldval)) << 11)));
}

static inline e10k_dev_present_t e10k_pcss2_dev_present_extract(e10k_pcss2_t _regval) __attribute__ ((always_inline));
static inline e10k_dev_present_t e10k_pcss2_dev_present_extract(e10k_pcss2_t _regval)
{
    return((e10k_dev_present_t )((_regval & 0xc000) >> 14));
}

static inline e10k_pcss2_t e10k_pcss2_dev_present_insert(e10k_pcss2_t _regval, e10k_dev_present_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pcss2_t e10k_pcss2_dev_present_insert(e10k_pcss2_t _regval, e10k_dev_present_t _fieldval)
{
    return((_regval & 0xffff3fff) | (0xc000 & (((e10k_pcss2_t )(_fieldval)) << 14)));
}

static inline int e10k_pcss2_prtval(char *_s, size_t _size, e10k_pcss2_t _regval) __attribute__ ((always_inline));
static inline int e10k_pcss2_prtval(char *_s, size_t _size, e10k_pcss2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c10gbase_r =\t%" PRIx8 "\t(PCS is able to support 10GBASE-R port type)\n", e10k_pcss2_c10gbase_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c10gbase_x =\t%" PRIx8 "\t(PCS is able to support 10GBASE-X port type)\n", e10k_pcss2_c10gbase_x_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c10gbase_w =\t%" PRIx8 "\t(PCS is able to support 10GBASE-W port type)\n", e10k_pcss2_c10gbase_w_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_lfault =\t%" PRIx8 "\t(Local fault condition on the receive path)\n", e10k_pcss2_rx_lfault_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_lfault =\t%" PRIx8 "\t(Local fault condition on the transmit path)\n", e10k_pcss2_tx_lfault_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dev_present =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dev_present_prtval(_s + _r, _avail, e10k_pcss2_dev_present_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Device present)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_xpcss_t
 * Description: Implicit type of 10GBASE-X PCS Status register
 * Fields:
 *   lane0_sync	(size 1, offset 0, init 0):	RO	Lane 0 is synchronized
 *   lane1_sync	(size 1, offset 1, init 0):	RO	Lane 1 is synchronized
 *   lane2_sync	(size 1, offset 2, init 0):	RO	Lane 2 is synchronized
 *   lane3_sync	(size 1, offset 3, init 0):	RO	Lane 3 is synchronized
 *   _anon4	(size 8, offset 4, init 0):	RSVD	_
 *   align_stat	(size 1, offset 12, init 0):	RO	10GBASE-X PCS receive lanes aligned
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   deskew_err	(size 1, offset 16, init 0):	RO	De-skew error was detected
 *   algcolcnt4	(size 1, offset 17, init 0):	RO	Align column count has reached four
 *   lane0_invc	(size 1, offset 18, init 0):	RO	Invalid code was detected for that lane
 *   lane1_invc	(size 1, offset 19, init 0):	RO	Invalid code was detected for that lane
 *   lane2_invc	(size 1, offset 20, init 0):	RO	Invalid code was detected for that lane
 *   lane3_invc	(size 1, offset 21, init 0):	RO	Invalid code was detected for that lane
 *   lane0_ccnt4	(size 1, offset 22, init 0):	RO	Comma count for that lane has reached four
 *   lane1_ccnt4	(size 1, offset 23, init 0):	RO	Comma count for that lane has reached four
 *   lane2_ccnt4	(size 1, offset 24, init 0):	RO	Comma count for that lane has reached four
 *   lane3_ccnt4	(size 1, offset 25, init 0):	RO	Comma count for that lane has reached four
 *   lane0_sigd	(size 1, offset 26, init 0):	RO	Signal is detected
 *   lane1_sigd	(size 1, offset 27, init 0):	RO	Signal is detected
 *   lane2_sigd	(size 1, offset 28, init 0):	RO	Signal is detected
 *   lane3_sigd	(size 1, offset 29, init 0):	RO	Signal is detected
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
typedef uint32_t e10k_xpcss_t;
#define e10k_xpcss_default 0x0
static inline uint8_t e10k_xpcss_lane0_sync_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane0_sync_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_xpcss_t e10k_xpcss_lane0_sync_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane0_sync_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_xpcss_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_xpcss_lane1_sync_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane1_sync_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_xpcss_t e10k_xpcss_lane1_sync_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane1_sync_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_xpcss_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_xpcss_lane2_sync_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane2_sync_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_xpcss_t e10k_xpcss_lane2_sync_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane2_sync_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_xpcss_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_xpcss_lane3_sync_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane3_sync_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_xpcss_t e10k_xpcss_lane3_sync_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane3_sync_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_xpcss_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_xpcss_align_stat_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_align_stat_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_xpcss_t e10k_xpcss_align_stat_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_align_stat_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_xpcss_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_xpcss_deskew_err_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_deskew_err_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_xpcss_t e10k_xpcss_deskew_err_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_deskew_err_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_xpcss_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_xpcss_algcolcnt4_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_algcolcnt4_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_xpcss_t e10k_xpcss_algcolcnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_algcolcnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_xpcss_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_xpcss_lane0_invc_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane0_invc_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_xpcss_t e10k_xpcss_lane0_invc_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane0_invc_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_xpcss_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_xpcss_lane1_invc_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane1_invc_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_xpcss_t e10k_xpcss_lane1_invc_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane1_invc_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_xpcss_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_xpcss_lane2_invc_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane2_invc_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_xpcss_t e10k_xpcss_lane2_invc_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane2_invc_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_xpcss_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_xpcss_lane3_invc_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane3_invc_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_xpcss_t e10k_xpcss_lane3_invc_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane3_invc_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_xpcss_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_xpcss_lane0_ccnt4_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane0_ccnt4_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_xpcss_t e10k_xpcss_lane0_ccnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane0_ccnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_xpcss_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_xpcss_lane1_ccnt4_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane1_ccnt4_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_xpcss_t e10k_xpcss_lane1_ccnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane1_ccnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_xpcss_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_xpcss_lane2_ccnt4_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane2_ccnt4_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_xpcss_t e10k_xpcss_lane2_ccnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane2_ccnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_xpcss_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_xpcss_lane3_ccnt4_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane3_ccnt4_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_xpcss_t e10k_xpcss_lane3_ccnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane3_ccnt4_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_xpcss_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_xpcss_lane0_sigd_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane0_sigd_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_xpcss_t e10k_xpcss_lane0_sigd_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane0_sigd_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_xpcss_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_xpcss_lane1_sigd_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane1_sigd_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_xpcss_t e10k_xpcss_lane1_sigd_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane1_sigd_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_xpcss_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_xpcss_lane2_sigd_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane2_sigd_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_xpcss_t e10k_xpcss_lane2_sigd_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane2_sigd_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_xpcss_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_xpcss_lane3_sigd_extract(e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane3_sigd_extract(e10k_xpcss_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_xpcss_t e10k_xpcss_lane3_sigd_insert(e10k_xpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_lane3_sigd_insert(e10k_xpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_xpcss_t )(_fieldval)) << 29)));
}

static inline int e10k_xpcss_prtval(char *_s, size_t _size, e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline int e10k_xpcss_prtval(char *_s, size_t _size, e10k_xpcss_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane0_sync =\t%" PRIx8 "\t(Lane 0 is synchronized)\n", e10k_xpcss_lane0_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane1_sync =\t%" PRIx8 "\t(Lane 1 is synchronized)\n", e10k_xpcss_lane1_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane2_sync =\t%" PRIx8 "\t(Lane 2 is synchronized)\n", e10k_xpcss_lane2_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane3_sync =\t%" PRIx8 "\t(Lane 3 is synchronized)\n", e10k_xpcss_lane3_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " align_stat =\t%" PRIx8 "\t(10GBASE-X PCS receive lanes aligned)\n", e10k_xpcss_align_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deskew_err =\t%" PRIx8 "\t(De-skew error was detected)\n", e10k_xpcss_deskew_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " algcolcnt4 =\t%" PRIx8 "\t(Align column count has reached four)\n", e10k_xpcss_algcolcnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane0_invc =\t%" PRIx8 "\t(Invalid code was detected for that lane)\n", e10k_xpcss_lane0_invc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane1_invc =\t%" PRIx8 "\t(Invalid code was detected for that lane)\n", e10k_xpcss_lane1_invc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane2_invc =\t%" PRIx8 "\t(Invalid code was detected for that lane)\n", e10k_xpcss_lane2_invc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane3_invc =\t%" PRIx8 "\t(Invalid code was detected for that lane)\n", e10k_xpcss_lane3_invc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane0_ccnt4 =\t%" PRIx8 "\t(Comma count for that lane has reached four)\n", e10k_xpcss_lane0_ccnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane1_ccnt4 =\t%" PRIx8 "\t(Comma count for that lane has reached four)\n", e10k_xpcss_lane1_ccnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane2_ccnt4 =\t%" PRIx8 "\t(Comma count for that lane has reached four)\n", e10k_xpcss_lane2_ccnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane3_ccnt4 =\t%" PRIx8 "\t(Comma count for that lane has reached four)\n", e10k_xpcss_lane3_ccnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane0_sigd =\t%" PRIx8 "\t(Signal is detected)\n", e10k_xpcss_lane0_sigd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane1_sigd =\t%" PRIx8 "\t(Signal is detected)\n", e10k_xpcss_lane1_sigd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane2_sigd =\t%" PRIx8 "\t(Signal is detected)\n", e10k_xpcss_lane2_sigd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane3_sigd =\t%" PRIx8 "\t(Signal is detected)\n", e10k_xpcss_lane3_sigd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_serdesc_t
 * Description: Implicit type of SerDes Interface Control Register register
 * Fields:
 *   txl0_pol	(size 1, offset 0, init 0):	RW	Changes bits polarity of MAC Tx lane 0
 *   txl1_pol	(size 1, offset 1, init 0):	RW	Changes bits polarity of MAC Tx lane 1
 *   txl2_pol	(size 1, offset 2, init 0):	RW	Changes bits polarity of MAC Tx lane 2
 *   txl3_pol	(size 1, offset 3, init 0):	RW	Changes bits polarity of MAC Tx lane 3
 *   rxl0_pol	(size 1, offset 4, init 0):	RW	Changes bits polarity of MAC Rx lane 0
 *   rxl1_pol	(size 1, offset 5, init 0):	RW	Changes bits polarity of MAC Rx lane 1
 *   rxl2_pol	(size 1, offset 6, init 0):	RW	Changes bits polarity of MAC Rx lane 2
 *   rxl3_pol	(size 1, offset 7, init 0):	RW	Changes bits polarity of MAC Rx lane 3
 *   txl0_swiz	(size 1, offset 8, init 0):	RW	Swizzles bits of MAC Tx lane 0
 *   txl1_swiz	(size 1, offset 9, init 0):	RW	Swizzles bits of MAC Tx lane 1
 *   txl2_swiz	(size 1, offset 10, init 0):	RW	Swizzles bits of MAC Tx lane 2
 *   txl3_swiz	(size 1, offset 11, init 0):	RW	Swizzles bits of MAC Tx lane 3
 *   rxl0_swiz	(size 1, offset 12, init 0):	RW	Swizzles bits of MAC Rx lane 0
 *   rxl1_swiz	(size 1, offset 13, init 0):	RW	Swizzles bits of MAC Rx lane 1
 *   rxl2_swiz	(size 1, offset 14, init 0):	RW	Swizzles bits of MAC Rx lane 2
 *   rxl3_swiz	(size 1, offset 15, init 0):	RW	Swizzles bits of MAC Rx lane 3
 *   txl3_swap	(size 2, offset 16, init 0):	RW	Determines Core destination Tx lane for MAC Tx lane 3
 *   txl2_swap	(size 2, offset 18, init 0):	RW	Determines Core destination Tx lane for MAC Tx lane 2
 *   txl1_swap	(size 2, offset 20, init 0):	RW	Determines Core destination Tx lane for MAC Tx lane 1
 *   txl0_swap	(size 2, offset 22, init 0):	RW	Determines Core destination Tx lane for MAC Tx lane 0
 *   rxl3_swap	(size 2, offset 24, init 0):	RW	Determines which Core lane is mapped to MAC Rx lane 3
 *   rxl2_swap	(size 2, offset 26, init 0):	RW	Determines which Core lane is mapped to MAC Rx lane 2
 *   rxl1_swap	(size 2, offset 28, init 0):	RW	Determines which Core lane is mapped to MAC Rx lane 1
 *   rxl0_swap	(size 2, offset 30, init 0):	RW	Determines which Core lane is mapped to MAC Rx lane 0
 */
typedef uint32_t e10k_serdesc_t;
#define e10k_serdesc_default 0x0
static inline uint8_t e10k_serdesc_txl0_pol_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl0_pol_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_serdesc_t e10k_serdesc_txl0_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl0_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_serdesc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_serdesc_txl1_pol_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl1_pol_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_serdesc_t e10k_serdesc_txl1_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl1_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_serdesc_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_serdesc_txl2_pol_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl2_pol_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_serdesc_t e10k_serdesc_txl2_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl2_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_serdesc_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_serdesc_txl3_pol_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl3_pol_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_serdesc_t e10k_serdesc_txl3_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl3_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_serdesc_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_serdesc_rxl0_pol_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl0_pol_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_serdesc_t e10k_serdesc_rxl0_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl0_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_serdesc_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_serdesc_rxl1_pol_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl1_pol_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_serdesc_t e10k_serdesc_rxl1_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl1_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_serdesc_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_serdesc_rxl2_pol_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl2_pol_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_serdesc_t e10k_serdesc_rxl2_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl2_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_serdesc_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_serdesc_rxl3_pol_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl3_pol_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_serdesc_t e10k_serdesc_rxl3_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl3_pol_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_serdesc_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_serdesc_txl0_swiz_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl0_swiz_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x100) >> 8));
}

static inline e10k_serdesc_t e10k_serdesc_txl0_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl0_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffeff) | (0x100 & (((e10k_serdesc_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_serdesc_txl1_swiz_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl1_swiz_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x200) >> 9));
}

static inline e10k_serdesc_t e10k_serdesc_txl1_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl1_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_serdesc_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_serdesc_txl2_swiz_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl2_swiz_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_serdesc_t e10k_serdesc_txl2_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl2_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_serdesc_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_serdesc_txl3_swiz_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl3_swiz_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_serdesc_t e10k_serdesc_txl3_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl3_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_serdesc_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_serdesc_rxl0_swiz_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl0_swiz_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_serdesc_t e10k_serdesc_rxl0_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl0_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_serdesc_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_serdesc_rxl1_swiz_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl1_swiz_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_serdesc_t e10k_serdesc_rxl1_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl1_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_serdesc_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_serdesc_rxl2_swiz_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl2_swiz_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_serdesc_t e10k_serdesc_rxl2_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl2_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_serdesc_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_serdesc_rxl3_swiz_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl3_swiz_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_serdesc_t e10k_serdesc_rxl3_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl3_swiz_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_serdesc_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_serdesc_txl3_swap_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl3_swap_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x30000) >> 16));
}

static inline e10k_serdesc_t e10k_serdesc_txl3_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl3_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((e10k_serdesc_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_serdesc_txl2_swap_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl2_swap_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0xc0000) >> 18));
}

static inline e10k_serdesc_t e10k_serdesc_txl2_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl2_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((e10k_serdesc_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_serdesc_txl1_swap_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl1_swap_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x300000) >> 20));
}

static inline e10k_serdesc_t e10k_serdesc_txl1_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl1_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffcfffff) | (0x300000 & (((e10k_serdesc_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_serdesc_txl0_swap_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl0_swap_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0xc00000) >> 22));
}

static inline e10k_serdesc_t e10k_serdesc_txl0_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_txl0_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff3fffff) | (0xc00000 & (((e10k_serdesc_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_serdesc_rxl3_swap_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl3_swap_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x3000000) >> 24));
}

static inline e10k_serdesc_t e10k_serdesc_rxl3_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl3_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfcffffff) | (0x3000000 & (((e10k_serdesc_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_serdesc_rxl2_swap_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl2_swap_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0xc000000) >> 26));
}

static inline e10k_serdesc_t e10k_serdesc_rxl2_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl2_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((e10k_serdesc_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_serdesc_rxl1_swap_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl1_swap_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0x30000000) >> 28));
}

static inline e10k_serdesc_t e10k_serdesc_rxl1_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl1_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((e10k_serdesc_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_serdesc_rxl0_swap_extract(e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl0_swap_extract(e10k_serdesc_t _regval)
{
    return((uint8_t )((_regval & 0xc0000000) >> 30));
}

static inline e10k_serdesc_t e10k_serdesc_rxl0_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rxl0_swap_insert(e10k_serdesc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x3fffffff) | (0xc0000000 & (((e10k_serdesc_t )(_fieldval)) << 30)));
}

static inline int e10k_serdesc_prtval(char *_s, size_t _size, e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline int e10k_serdesc_prtval(char *_s, size_t _size, e10k_serdesc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl0_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Tx lane 0)\n", e10k_serdesc_txl0_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl1_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Tx lane 1)\n", e10k_serdesc_txl1_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl2_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Tx lane 2)\n", e10k_serdesc_txl2_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl3_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Tx lane 3)\n", e10k_serdesc_txl3_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl0_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Rx lane 0)\n", e10k_serdesc_rxl0_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl1_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Rx lane 1)\n", e10k_serdesc_rxl1_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl2_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Rx lane 2)\n", e10k_serdesc_rxl2_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl3_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Rx lane 3)\n", e10k_serdesc_rxl3_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl0_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Tx lane 0)\n", e10k_serdesc_txl0_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl1_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Tx lane 1)\n", e10k_serdesc_txl1_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl2_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Tx lane 2)\n", e10k_serdesc_txl2_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl3_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Tx lane 3)\n", e10k_serdesc_txl3_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl0_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Rx lane 0)\n", e10k_serdesc_rxl0_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl1_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Rx lane 1)\n", e10k_serdesc_rxl1_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl2_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Rx lane 2)\n", e10k_serdesc_rxl2_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl3_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Rx lane 3)\n", e10k_serdesc_rxl3_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl3_swap =\t%" PRIx8 "\t(Determines Core destination Tx lane for MAC Tx lane 3)\n", e10k_serdesc_txl3_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl2_swap =\t%" PRIx8 "\t(Determines Core destination Tx lane for MAC Tx lane 2)\n", e10k_serdesc_txl2_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl1_swap =\t%" PRIx8 "\t(Determines Core destination Tx lane for MAC Tx lane 1)\n", e10k_serdesc_txl1_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl0_swap =\t%" PRIx8 "\t(Determines Core destination Tx lane for MAC Tx lane 0)\n", e10k_serdesc_txl0_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl3_swap =\t%" PRIx8 "\t(Determines which Core lane is mapped to MAC Rx lane 3)\n", e10k_serdesc_rxl3_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl2_swap =\t%" PRIx8 "\t(Determines which Core lane is mapped to MAC Rx lane 2)\n", e10k_serdesc_rxl2_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl1_swap =\t%" PRIx8 "\t(Determines which Core lane is mapped to MAC Rx lane 1)\n", e10k_serdesc_rxl1_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl0_swap =\t%" PRIx8 "\t(Determines which Core lane is mapped to MAC Rx lane 0)\n", e10k_serdesc_rxl0_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_macs_t
 * Description: Implicit type of FIFO Status/CNTL Report Register register
 * Fields:
 *   xgssf_dis	(size 1, offset 0, init 0):	RW	Use shift-fsm control, disable fix
 *   xgtxe_dis	(size 1, offset 1, init 0):	RW	Disable tx_end on link-down
 *   xgsdsf_dis	(size 1, offset 2, init 0):	RW	Disable align on invalid fix
 *   noncem_dis	(size 1, offset 3, init 0):	RW	Disable nonce match
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   cfgflt_len	(size 8, offset 16, init 0):	RW	Config fault length
 *   cfgfifothr	(size 4, offset 24, init 0):	RW	Config FIFO threshold
 *   txfifo_ur	(size 1, offset 28, init 0):	RW	FIFO under run in xgmii_mux_tx_fifo
 *   txfifo_or	(size 1, offset 29, init 0):	RW	FIFO overrun in xgmii_mux_tx_fifo
 *   rxfifo_ur	(size 1, offset 30, init 0):	RW	FIFO under run in xgmii_mux_rx_fifo
 *   rxfifo_or	(size 1, offset 31, init 0):	RW	FIFO overrun in xgmii_mux_rx_fifo
 */
typedef uint32_t e10k_macs_t;
#define e10k_macs_default 0x0
static inline uint8_t e10k_macs_xgssf_dis_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_xgssf_dis_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_macs_t e10k_macs_xgssf_dis_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_xgssf_dis_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_macs_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_macs_xgtxe_dis_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_xgtxe_dis_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_macs_t e10k_macs_xgtxe_dis_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_xgtxe_dis_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_macs_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_macs_xgsdsf_dis_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_xgsdsf_dis_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_macs_t e10k_macs_xgsdsf_dis_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_xgsdsf_dis_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_macs_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_macs_noncem_dis_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_noncem_dis_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_macs_t e10k_macs_noncem_dis_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_noncem_dis_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_macs_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_macs_cfgflt_len_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_cfgflt_len_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0xff0000) >> 16));
}

static inline e10k_macs_t e10k_macs_cfgflt_len_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_cfgflt_len_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff00ffff) | (0xff0000 & (((e10k_macs_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_macs_cfgfifothr_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_cfgfifothr_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0xf000000) >> 24));
}

static inline e10k_macs_t e10k_macs_cfgfifothr_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_cfgfifothr_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((e10k_macs_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_macs_txfifo_ur_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_txfifo_ur_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_macs_t e10k_macs_txfifo_ur_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_txfifo_ur_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_macs_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_macs_txfifo_or_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_txfifo_or_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_macs_t e10k_macs_txfifo_or_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_txfifo_or_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_macs_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_macs_rxfifo_ur_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_rxfifo_ur_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_macs_t e10k_macs_rxfifo_ur_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_rxfifo_ur_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_macs_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_macs_rxfifo_or_extract(e10k_macs_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_rxfifo_or_extract(e10k_macs_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_macs_t e10k_macs_rxfifo_or_insert(e10k_macs_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_rxfifo_or_insert(e10k_macs_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_macs_t )(_fieldval)) << 31)));
}

static inline int e10k_macs_prtval(char *_s, size_t _size, e10k_macs_t _regval) __attribute__ ((always_inline));
static inline int e10k_macs_prtval(char *_s, size_t _size, e10k_macs_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xgssf_dis =\t%" PRIx8 "\t(Use shift-fsm control, disable fix)\n", e10k_macs_xgssf_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xgtxe_dis =\t%" PRIx8 "\t(Disable tx_end on link-down)\n", e10k_macs_xgtxe_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xgsdsf_dis =\t%" PRIx8 "\t(Disable align on invalid fix)\n", e10k_macs_xgsdsf_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " noncem_dis =\t%" PRIx8 "\t(Disable nonce match)\n", e10k_macs_noncem_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfgflt_len =\t%" PRIx8 "\t(Config fault length)\n", e10k_macs_cfgflt_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfgfifothr =\t%" PRIx8 "\t(Config FIFO threshold)\n", e10k_macs_cfgfifothr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfifo_ur =\t%" PRIx8 "\t(FIFO under run in xgmii_mux_tx_fifo)\n", e10k_macs_txfifo_ur_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfifo_or =\t%" PRIx8 "\t(FIFO overrun in xgmii_mux_tx_fifo)\n", e10k_macs_txfifo_or_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_ur =\t%" PRIx8 "\t(FIFO under run in xgmii_mux_rx_fifo)\n", e10k_macs_rxfifo_ur_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_or =\t%" PRIx8 "\t(FIFO overrun in xgmii_mux_rx_fifo)\n", e10k_macs_rxfifo_or_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_autoc_t
 * Description: Implicit type of Auto Negotiation Control Register register
 * Fields:
 *   flu	(size 1, offset 0, init 0):	RW	Force Link Up
 *   anack2	(size 1, offset 1, init 0):	RW	Auto-Negotiation Ack2 field
 *   ansf	(size 5, offset 2, init 0):	RW	Auto-Negotiation Selector Field
 *   pmad_10gbe	(size 2, offset 7, init 0):	RW	10 GbE PMA/PMD over four differential pairs
 *   pmad_1gbe	(size 1, offset 9, init 0):	RW	PMA/PMD used for 1 GbE
 *   d10gmp	(size 1, offset 10, init 0):	RW	Disables 10 GbE (KX4) on Dx (Dr/D3) without main-power
 *   ratd	(size 1, offset 11, init 0):	RW	Restarts auto-negotiation on transition to Dx
 *   restart_an	(size 1, offset 12, init 0):	RW	Applies new link settings and restarts relative auto-negotiation
 *   lms	(size 3, offset 13, init 0):	RW	Link Mode Select
 *   kr_sup	(size 1, offset 16, init 0):	RW	KR supported
 *   fecr	(size 1, offset 17, init 0):	RW	FEC requested from link partner
 *   feca	(size 1, offset 18, init 0):	RW	FEC supported
 *   anrxat	(size 4, offset 19, init 0):	RW	Backplane Auto-Negotiation Rx Align Threshold
 *   anrxdm	(size 1, offset 23, init 0):	RW	Auto-Negotiation Rx Drift Mode
 *   anrxlm	(size 1, offset 24, init 0):	RW	Auto-Negotiation Rx Loose Mode
 *   anpdt	(size 2, offset 25, init 0):	RW	Auto-Negotiation Parallel Detect Timer
 *   rf	(size 1, offset 27, init 0):	RW	Loaded to the RF of the auto-negotiation word
 *   pb	(size 2, offset 28, init 0):	RW	Loaded to bits D11-D10 of the Link code word
 *   kx_sup	(size 1, offset 30, init 0):	RW	KX supported
 *   kx4sup	(size 1, offset 31, init 0):	RW	KX4 supported
 */
typedef uint32_t e10k_autoc_t;
#define e10k_autoc_default 0x0
static inline uint8_t e10k_autoc_flu_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_flu_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_autoc_t e10k_autoc_flu_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_flu_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_autoc_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_autoc_anack2_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_anack2_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_autoc_t e10k_autoc_anack2_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_anack2_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_autoc_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_autoc_ansf_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_ansf_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x7c) >> 2));
}

static inline e10k_autoc_t e10k_autoc_ansf_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_ansf_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff83) | (0x7c & (((e10k_autoc_t )(_fieldval)) << 2)));
}

static inline e10k_pmad_10gbe_t e10k_autoc_pmad_10gbe_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline e10k_pmad_10gbe_t e10k_autoc_pmad_10gbe_extract(e10k_autoc_t _regval)
{
    return((e10k_pmad_10gbe_t )((_regval & 0x180) >> 7));
}

static inline e10k_autoc_t e10k_autoc_pmad_10gbe_insert(e10k_autoc_t _regval, e10k_pmad_10gbe_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_pmad_10gbe_insert(e10k_autoc_t _regval, e10k_pmad_10gbe_t _fieldval)
{
    return((_regval & 0xfffffe7f) | (0x180 & (((e10k_autoc_t )(_fieldval)) << 7)));
}

static inline e10k_pmad_1gbe_t e10k_autoc_pmad_1gbe_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline e10k_pmad_1gbe_t e10k_autoc_pmad_1gbe_extract(e10k_autoc_t _regval)
{
    return((e10k_pmad_1gbe_t )((_regval & 0x200) >> 9));
}

static inline e10k_autoc_t e10k_autoc_pmad_1gbe_insert(e10k_autoc_t _regval, e10k_pmad_1gbe_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_pmad_1gbe_insert(e10k_autoc_t _regval, e10k_pmad_1gbe_t _fieldval)
{
    return((_regval & 0xfffffdff) | (0x200 & (((e10k_autoc_t )(_fieldval)) << 9)));
}

static inline uint8_t e10k_autoc_d10gmp_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_d10gmp_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x400) >> 10));
}

static inline e10k_autoc_t e10k_autoc_d10gmp_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_d10gmp_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffbff) | (0x400 & (((e10k_autoc_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_autoc_ratd_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_ratd_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_autoc_t e10k_autoc_ratd_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_ratd_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_autoc_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_autoc_restart_an_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_restart_an_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_autoc_t e10k_autoc_restart_an_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_restart_an_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_autoc_t )(_fieldval)) << 12)));
}

static inline e10k_link_mode_t e10k_autoc_lms_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline e10k_link_mode_t e10k_autoc_lms_extract(e10k_autoc_t _regval)
{
    return((e10k_link_mode_t )((_regval & 0xe000) >> 13));
}

static inline e10k_autoc_t e10k_autoc_lms_insert(e10k_autoc_t _regval, e10k_link_mode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_lms_insert(e10k_autoc_t _regval, e10k_link_mode_t _fieldval)
{
    return((_regval & 0xffff1fff) | (0xe000 & (((e10k_autoc_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_autoc_kr_sup_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_kr_sup_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_autoc_t e10k_autoc_kr_sup_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_kr_sup_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_autoc_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_autoc_fecr_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_fecr_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_autoc_t e10k_autoc_fecr_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_fecr_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_autoc_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_autoc_feca_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_feca_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_autoc_t e10k_autoc_feca_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_feca_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_autoc_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_autoc_anrxat_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_anrxat_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x780000) >> 19));
}

static inline e10k_autoc_t e10k_autoc_anrxat_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_anrxat_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff87ffff) | (0x780000 & (((e10k_autoc_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_autoc_anrxdm_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_anrxdm_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_autoc_t e10k_autoc_anrxdm_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_anrxdm_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_autoc_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_autoc_anrxlm_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_anrxlm_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_autoc_t e10k_autoc_anrxlm_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_anrxlm_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_autoc_t )(_fieldval)) << 24)));
}

static inline e10k_aneg_pdt_t e10k_autoc_anpdt_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline e10k_aneg_pdt_t e10k_autoc_anpdt_extract(e10k_autoc_t _regval)
{
    return((e10k_aneg_pdt_t )((_regval & 0x6000000) >> 25));
}

static inline e10k_autoc_t e10k_autoc_anpdt_insert(e10k_autoc_t _regval, e10k_aneg_pdt_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_anpdt_insert(e10k_autoc_t _regval, e10k_aneg_pdt_t _fieldval)
{
    return((_regval & 0xf9ffffff) | (0x6000000 & (((e10k_autoc_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_autoc_rf_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_rf_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_autoc_t e10k_autoc_rf_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_rf_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_autoc_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_autoc_pb_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_pb_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x30000000) >> 28));
}

static inline e10k_autoc_t e10k_autoc_pb_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_pb_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((e10k_autoc_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_autoc_kx_sup_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_kx_sup_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_autoc_t e10k_autoc_kx_sup_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_kx_sup_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_autoc_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_autoc_kx4sup_extract(e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_kx4sup_extract(e10k_autoc_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_autoc_t e10k_autoc_kx4sup_insert(e10k_autoc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_kx4sup_insert(e10k_autoc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_autoc_t )(_fieldval)) << 31)));
}

static inline int e10k_autoc_prtval(char *_s, size_t _size, e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline int e10k_autoc_prtval(char *_s, size_t _size, e10k_autoc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flu =\t%" PRIx8 "\t(Force Link Up)\n", e10k_autoc_flu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anack2 =\t%" PRIx8 "\t(Auto-Negotiation Ack2 field)\n", e10k_autoc_anack2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ansf =\t%" PRIx8 "\t(Auto-Negotiation Selector Field)\n", e10k_autoc_ansf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmad_10gbe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pmad_10gbe_prtval(_s + _r, _avail, e10k_autoc_pmad_10gbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(10 GbE PMA/PMD over four differential pairs)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmad_1gbe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pmad_1gbe_prtval(_s + _r, _avail, e10k_autoc_pmad_1gbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PMA/PMD used for 1 GbE)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " d10gmp =\t%" PRIx8 "\t(Disables 10 GbE (KX4) on Dx (Dr/D3) without main-power)\n", e10k_autoc_d10gmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ratd =\t%" PRIx8 "\t(Restarts auto-negotiation on transition to Dx)\n", e10k_autoc_ratd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " restart_an =\t%" PRIx8 "\t(Applies new link settings and restarts relative auto-negotiation)\n", e10k_autoc_restart_an_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lms =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_link_mode_prtval(_s + _r, _avail, e10k_autoc_lms_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Link Mode Select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kr_sup =\t%" PRIx8 "\t(KR supported)\n", e10k_autoc_kr_sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecr =\t%" PRIx8 "\t(FEC requested from link partner)\n", e10k_autoc_fecr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " feca =\t%" PRIx8 "\t(FEC supported)\n", e10k_autoc_feca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anrxat =\t%" PRIx8 "\t(Backplane Auto-Negotiation Rx Align Threshold)\n", e10k_autoc_anrxat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anrxdm =\t%" PRIx8 "\t(Auto-Negotiation Rx Drift Mode)\n", e10k_autoc_anrxdm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anrxlm =\t%" PRIx8 "\t(Auto-Negotiation Rx Loose Mode)\n", e10k_autoc_anrxlm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anpdt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_aneg_pdt_prtval(_s + _r, _avail, e10k_autoc_anpdt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Auto-Negotiation Parallel Detect Timer)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rf =\t%" PRIx8 "\t(Loaded to the RF of the auto-negotiation word)\n", e10k_autoc_rf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pb =\t%" PRIx8 "\t(Loaded to bits D11-D10 of the Link code word)\n", e10k_autoc_pb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kx_sup =\t%" PRIx8 "\t(KX supported)\n", e10k_autoc_kx_sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kx4sup =\t%" PRIx8 "\t(KX4 supported)\n", e10k_autoc_kx4sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_links_t
 * Description: Implicit type of Link Status Register register
 * Fields:
 *   kxsig_det	(size 1, offset 0, init 0):	RO	A signal is present
 *   fecsig_det	(size 1, offset 1, init 0):	RO	FEC reports signal detected
 *   fecblk_lck	(size 1, offset 2, init 0):	RO	FEC reached block lock
 *   krhberr	(size 1, offset 3, init 0):	RO	10GbE serial KR_PCS high error rate
 *   krpcsbl	(size 1, offset 4, init 0):	RO	10 GbE serial PCS block lock
 *   kxr_annprcv	(size 1, offset 5, init 0):	RO	KX/KX4/KR AN Next Page Received
 *   kxr_anprcv	(size 1, offset 6, init 0):	RO	KX/KX4/KR Backplane Auto Negotiation Page Received
 *   lnk_stat	(size 1, offset 7, init 0):	RO	Link Up and there was no link down from last time read
 *   kx4sig_det	(size 4, offset 8, init 0):	RO	Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane)
 *   krsig_det	(size 1, offset 12, init 0):	RO	Signal Detect of 10 GbE serial (KR or SFI)
 *   l10g_syncst	(size 4, offset 13, init 0):	RO	10G Parallel lane sync status (1bit per lane)
 *   l10g_algst	(size 1, offset 17, init 0):	RO	10 GbE align_status
 *   l1g_syncst	(size 1, offset 18, init 0):	RO	1G sync_status
 *   kxr_anrxid	(size 1, offset 19, init 0):	RO	KX/KX4/KR Backplane Auto Negotiation Rx Idle
 *   l1g_anen	(size 1, offset 20, init 0):	RO	PCS_1 GbE auto-negotiation is enabled
 *   l1g_lnken	(size 1, offset 21, init 0):	RO	1 GbE PCS enabled for 1 GbE and SGMII operation
 *   l10g_lnken	(size 1, offset 22, init 0):	RO	XGXS Enabled for 10 GbE operation
 *   fec_en	(size 1, offset 23, init 0):	RO	Status of forwarderrorcorrection in 10 GbE serial link
 *   l10g_seren	(size 1, offset 24, init 0):	RO	Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation
 *   sgmii_en	(size 1, offset 25, init 0):	RO	Status of SGMII operation
 *   mlink_mode	(size 2, offset 26, init 0):	RO	MAC link mode status
 *   lnk_speed	(size 2, offset 28, init 0):	RO	MAC link speed status
 *   lnk_up	(size 1, offset 30, init 0):	RO	Link is up
 *   kxr_ancomp	(size 1, offset 31, init 0):	RO	KX/KX4/KR backplane auto-negotiation has completed successfully
 */
typedef uint32_t e10k_links_t;
#define e10k_links_default 0x0
static inline uint8_t e10k_links_kxsig_det_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxsig_det_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_links_t e10k_links_kxsig_det_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_kxsig_det_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_links_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_links_fecsig_det_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_fecsig_det_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_links_t e10k_links_fecsig_det_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_fecsig_det_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_links_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_links_fecblk_lck_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_fecblk_lck_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_links_t e10k_links_fecblk_lck_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_fecblk_lck_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_links_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_links_krhberr_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_krhberr_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_links_t e10k_links_krhberr_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_krhberr_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_links_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_links_krpcsbl_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_krpcsbl_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x10) >> 4));
}

static inline e10k_links_t e10k_links_krpcsbl_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_krpcsbl_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffef) | (0x10 & (((e10k_links_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_links_kxr_annprcv_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxr_annprcv_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x20) >> 5));
}

static inline e10k_links_t e10k_links_kxr_annprcv_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_kxr_annprcv_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffdf) | (0x20 & (((e10k_links_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_links_kxr_anprcv_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxr_anprcv_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_links_t e10k_links_kxr_anprcv_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_kxr_anprcv_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_links_t )(_fieldval)) << 6)));
}

static inline uint8_t e10k_links_lnk_stat_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_lnk_stat_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x80) >> 7));
}

static inline e10k_links_t e10k_links_lnk_stat_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_lnk_stat_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff7f) | (0x80 & (((e10k_links_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_links_kx4sig_det_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kx4sig_det_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0xf00) >> 8));
}

static inline e10k_links_t e10k_links_kx4sig_det_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_kx4sig_det_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((e10k_links_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_links_krsig_det_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_krsig_det_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_links_t e10k_links_krsig_det_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_krsig_det_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_links_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_links_l10g_syncst_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l10g_syncst_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x1e000) >> 13));
}

static inline e10k_links_t e10k_links_l10g_syncst_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_l10g_syncst_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe1fff) | (0x1e000 & (((e10k_links_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_links_l10g_algst_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l10g_algst_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_links_t e10k_links_l10g_algst_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_l10g_algst_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_links_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_links_l1g_syncst_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l1g_syncst_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_links_t e10k_links_l1g_syncst_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_l1g_syncst_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_links_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_links_kxr_anrxid_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxr_anrxid_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_links_t e10k_links_kxr_anrxid_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_kxr_anrxid_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_links_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_links_l1g_anen_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l1g_anen_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_links_t e10k_links_l1g_anen_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_l1g_anen_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_links_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_links_l1g_lnken_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l1g_lnken_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_links_t e10k_links_l1g_lnken_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_l1g_lnken_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_links_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_links_l10g_lnken_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l10g_lnken_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_links_t e10k_links_l10g_lnken_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_l10g_lnken_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_links_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_links_fec_en_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_fec_en_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_links_t e10k_links_fec_en_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_fec_en_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_links_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_links_l10g_seren_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l10g_seren_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_links_t e10k_links_l10g_seren_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_l10g_seren_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_links_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_links_sgmii_en_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_sgmii_en_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_links_t e10k_links_sgmii_en_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_sgmii_en_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_links_t )(_fieldval)) << 25)));
}

static inline e10k_mac_lnkmode_t e10k_links_mlink_mode_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline e10k_mac_lnkmode_t e10k_links_mlink_mode_extract(e10k_links_t _regval)
{
    return((e10k_mac_lnkmode_t )((_regval & 0xc000000) >> 26));
}

static inline e10k_links_t e10k_links_mlink_mode_insert(e10k_links_t _regval, e10k_mac_lnkmode_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_mlink_mode_insert(e10k_links_t _regval, e10k_mac_lnkmode_t _fieldval)
{
    return((_regval & 0xf3ffffff) | (0xc000000 & (((e10k_links_t )(_fieldval)) << 26)));
}

static inline e10k_link_speed_t e10k_links_lnk_speed_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline e10k_link_speed_t e10k_links_lnk_speed_extract(e10k_links_t _regval)
{
    return((e10k_link_speed_t )((_regval & 0x30000000) >> 28));
}

static inline e10k_links_t e10k_links_lnk_speed_insert(e10k_links_t _regval, e10k_link_speed_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_lnk_speed_insert(e10k_links_t _regval, e10k_link_speed_t _fieldval)
{
    return((_regval & 0xcfffffff) | (0x30000000 & (((e10k_links_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_links_lnk_up_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_lnk_up_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_links_t e10k_links_lnk_up_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_lnk_up_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_links_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_links_kxr_ancomp_extract(e10k_links_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxr_ancomp_extract(e10k_links_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_links_t e10k_links_kxr_ancomp_insert(e10k_links_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_kxr_ancomp_insert(e10k_links_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_links_t )(_fieldval)) << 31)));
}

static inline int e10k_links_prtval(char *_s, size_t _size, e10k_links_t _regval) __attribute__ ((always_inline));
static inline int e10k_links_prtval(char *_s, size_t _size, e10k_links_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxsig_det =\t%" PRIx8 "\t(A signal is present)\n", e10k_links_kxsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecsig_det =\t%" PRIx8 "\t(FEC reports signal detected)\n", e10k_links_fecsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecblk_lck =\t%" PRIx8 "\t(FEC reached block lock)\n", e10k_links_fecblk_lck_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krhberr =\t%" PRIx8 "\t(10GbE serial KR_PCS high error rate)\n", e10k_links_krhberr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krpcsbl =\t%" PRIx8 "\t(10 GbE serial PCS block lock)\n", e10k_links_krpcsbl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_annprcv =\t%" PRIx8 "\t(KX/KX4/KR AN Next Page Received)\n", e10k_links_kxr_annprcv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_anprcv =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto Negotiation Page Received)\n", e10k_links_kxr_anprcv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_stat =\t%" PRIx8 "\t(Link Up and there was no link down from last time read)\n", e10k_links_lnk_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kx4sig_det =\t%" PRIx8 "\t(Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane))\n", e10k_links_kx4sig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krsig_det =\t%" PRIx8 "\t(Signal Detect of 10 GbE serial (KR or SFI))\n", e10k_links_krsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_syncst =\t%" PRIx8 "\t(10G Parallel lane sync status (1bit per lane))\n", e10k_links_l10g_syncst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_algst =\t%" PRIx8 "\t(10 GbE align_status)\n", e10k_links_l10g_algst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_syncst =\t%" PRIx8 "\t(1G sync_status)\n", e10k_links_l1g_syncst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_anrxid =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto Negotiation Rx Idle)\n", e10k_links_kxr_anrxid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_anen =\t%" PRIx8 "\t(PCS_1 GbE auto-negotiation is enabled)\n", e10k_links_l1g_anen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_lnken =\t%" PRIx8 "\t(1 GbE PCS enabled for 1 GbE and SGMII operation)\n", e10k_links_l1g_lnken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_lnken =\t%" PRIx8 "\t(XGXS Enabled for 10 GbE operation)\n", e10k_links_l10g_lnken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_en =\t%" PRIx8 "\t(Status of forwarderrorcorrection in 10 GbE serial link)\n", e10k_links_fec_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_seren =\t%" PRIx8 "\t(Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation)\n", e10k_links_l10g_seren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sgmii_en =\t%" PRIx8 "\t(Status of SGMII operation)\n", e10k_links_sgmii_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mlink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mac_lnkmode_prtval(_s + _r, _avail, e10k_links_mlink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link mode status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_link_speed_prtval(_s + _r, _avail, e10k_links_lnk_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link speed status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_up =\t%" PRIx8 "\t(Link is up)\n", e10k_links_lnk_up_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_ancomp =\t%" PRIx8 "\t(KX/KX4/KR backplane auto-negotiation has completed successfully)\n", e10k_links_kxr_ancomp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_links2_t
 * Description: Implicit type of Link Status Register 2 register
 * Fields:
 *   mac_rxlm	(size 2, offset 0, init 0):	RO	MAC link mode in the Core Rx path
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   mac_txlm	(size 2, offset 3, init 0):	RO	MAC link mode in the Core Tx path
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   lnkp_an	(size 1, offset 6, init 0):	RO	Link partner is KX/KX4/KR backplane auto-negotiation capable
 *   _anon7	(size 25, offset 7, init 0):	RSVD	_
 */
typedef uint32_t e10k_links2_t;
#define e10k_links2_default 0x0
static inline e10k_mac_rxtxlm_t e10k_links2_mac_rxlm_extract(e10k_links2_t _regval) __attribute__ ((always_inline));
static inline e10k_mac_rxtxlm_t e10k_links2_mac_rxlm_extract(e10k_links2_t _regval)
{
    return((e10k_mac_rxtxlm_t )((_regval & 0x3) >> 0));
}

static inline e10k_links2_t e10k_links2_mac_rxlm_insert(e10k_links2_t _regval, e10k_mac_rxtxlm_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links2_t e10k_links2_mac_rxlm_insert(e10k_links2_t _regval, e10k_mac_rxtxlm_t _fieldval)
{
    return((_regval & 0xfffffffc) | (0x3 & (((e10k_links2_t )(_fieldval)) << 0)));
}

static inline e10k_mac_rxtxlm_t e10k_links2_mac_txlm_extract(e10k_links2_t _regval) __attribute__ ((always_inline));
static inline e10k_mac_rxtxlm_t e10k_links2_mac_txlm_extract(e10k_links2_t _regval)
{
    return((e10k_mac_rxtxlm_t )((_regval & 0x18) >> 3));
}

static inline e10k_links2_t e10k_links2_mac_txlm_insert(e10k_links2_t _regval, e10k_mac_rxtxlm_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links2_t e10k_links2_mac_txlm_insert(e10k_links2_t _regval, e10k_mac_rxtxlm_t _fieldval)
{
    return((_regval & 0xffffffe7) | (0x18 & (((e10k_links2_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_links2_lnkp_an_extract(e10k_links2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_links2_lnkp_an_extract(e10k_links2_t _regval)
{
    return((uint8_t )((_regval & 0x40) >> 6));
}

static inline e10k_links2_t e10k_links2_lnkp_an_insert(e10k_links2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_links2_t e10k_links2_lnkp_an_insert(e10k_links2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffbf) | (0x40 & (((e10k_links2_t )(_fieldval)) << 6)));
}

static inline int e10k_links2_prtval(char *_s, size_t _size, e10k_links2_t _regval) __attribute__ ((always_inline));
static inline int e10k_links2_prtval(char *_s, size_t _size, e10k_links2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mac_rxlm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mac_rxtxlm_prtval(_s + _r, _avail, e10k_links2_mac_rxlm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link mode in the Core Rx path)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mac_txlm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mac_rxtxlm_prtval(_s + _r, _avail, e10k_links2_mac_txlm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link mode in the Core Tx path)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnkp_an =\t%" PRIx8 "\t(Link partner is KX/KX4/KR backplane auto-negotiation capable)\n", e10k_links2_lnkp_an_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_autoc2_t
 * Description: Implicit type of Auto Negotiation Control 2 Register register
 * Fields:
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   pmad_10ser	(size 2, offset 16, init 0):	RW	PMAPMD used for 10 GbE serial link operation
 *   ddpt	(size 1, offset 18, init 0):	RW	Disable DME Pages Transmit
 *   _anon19	(size 11, offset 19, init 0):	RSVD	_
 *   pdd	(size 1, offset 30, init 0):	RW	Disable the parallel detect part in the KX/KX4/KR bp aneg
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_autoc2_t;
#define e10k_autoc2_default 0x0
static inline e10k_pmapd_10gbes_t e10k_autoc2_pmad_10ser_extract(e10k_autoc2_t _regval) __attribute__ ((always_inline));
static inline e10k_pmapd_10gbes_t e10k_autoc2_pmad_10ser_extract(e10k_autoc2_t _regval)
{
    return((e10k_pmapd_10gbes_t )((_regval & 0x30000) >> 16));
}

static inline e10k_autoc2_t e10k_autoc2_pmad_10ser_insert(e10k_autoc2_t _regval, e10k_pmapd_10gbes_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc2_t e10k_autoc2_pmad_10ser_insert(e10k_autoc2_t _regval, e10k_pmapd_10gbes_t _fieldval)
{
    return((_regval & 0xfffcffff) | (0x30000 & (((e10k_autoc2_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_autoc2_ddpt_extract(e10k_autoc2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc2_ddpt_extract(e10k_autoc2_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_autoc2_t e10k_autoc2_ddpt_insert(e10k_autoc2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc2_t e10k_autoc2_ddpt_insert(e10k_autoc2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_autoc2_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_autoc2_pdd_extract(e10k_autoc2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc2_pdd_extract(e10k_autoc2_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_autoc2_t e10k_autoc2_pdd_insert(e10k_autoc2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_autoc2_t e10k_autoc2_pdd_insert(e10k_autoc2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_autoc2_t )(_fieldval)) << 30)));
}

static inline int e10k_autoc2_prtval(char *_s, size_t _size, e10k_autoc2_t _regval) __attribute__ ((always_inline));
static inline int e10k_autoc2_prtval(char *_s, size_t _size, e10k_autoc2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmad_10ser =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pmapd_10gbes_prtval(_s + _r, _avail, e10k_autoc2_pmad_10ser_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PMAPMD used for 10 GbE serial link operation)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ddpt =\t%" PRIx8 "\t(Disable DME Pages Transmit)\n", e10k_autoc2_ddpt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pdd =\t%" PRIx8 "\t(Disable the parallel detect part in the KX/KX4/KR bp aneg)\n", e10k_autoc2_pdd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_anlp1_t
 * Description: Implicit type of Auto Negotiation Link Partner Link Control Word 1 Register register
 * Fields:
 *   lpan_sel	(size 5, offset 0, init 0):	RO	LP AN adv Selector field
 *   lpan_echn	(size 5, offset 5, init 0):	RO	LP AN adv Echoed Nonce field
 *   lpan_pause	(size 2, offset 10, init 0):	RO	LP AN adv Pause
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   lpan_rf	(size 1, offset 13, init 0):	RO	LP AN adv RF
 *   lpan_ack	(size 1, offset 14, init 0):	RO	LP AN adv Acknowledge
 *   lpan_np	(size 1, offset 15, init 0):	RO	LP AN adv NP
 *   anas	(size 4, offset 16, init 0):	RO	KX/KX4/KR Backplane Auto-Negotiation Arbitration State
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
typedef uint32_t e10k_anlp1_t;
#define e10k_anlp1_default 0x0
static inline uint8_t e10k_anlp1_lpan_sel_extract(e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_sel_extract(e10k_anlp1_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline e10k_anlp1_t e10k_anlp1_lpan_sel_insert(e10k_anlp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_lpan_sel_insert(e10k_anlp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((e10k_anlp1_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_anlp1_lpan_echn_extract(e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_echn_extract(e10k_anlp1_t _regval)
{
    return((uint8_t )((_regval & 0x3e0) >> 5));
}

static inline e10k_anlp1_t e10k_anlp1_lpan_echn_insert(e10k_anlp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_lpan_echn_insert(e10k_anlp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffc1f) | (0x3e0 & (((e10k_anlp1_t )(_fieldval)) << 5)));
}

static inline uint8_t e10k_anlp1_lpan_pause_extract(e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_pause_extract(e10k_anlp1_t _regval)
{
    return((uint8_t )((_regval & 0xc00) >> 10));
}

static inline e10k_anlp1_t e10k_anlp1_lpan_pause_insert(e10k_anlp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_lpan_pause_insert(e10k_anlp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff3ff) | (0xc00 & (((e10k_anlp1_t )(_fieldval)) << 10)));
}

static inline uint8_t e10k_anlp1_lpan_rf_extract(e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_rf_extract(e10k_anlp1_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_anlp1_t e10k_anlp1_lpan_rf_insert(e10k_anlp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_lpan_rf_insert(e10k_anlp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_anlp1_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_anlp1_lpan_ack_extract(e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_ack_extract(e10k_anlp1_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_anlp1_t e10k_anlp1_lpan_ack_insert(e10k_anlp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_lpan_ack_insert(e10k_anlp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_anlp1_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_anlp1_lpan_np_extract(e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_np_extract(e10k_anlp1_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_anlp1_t e10k_anlp1_lpan_np_insert(e10k_anlp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_lpan_np_insert(e10k_anlp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_anlp1_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_anlp1_anas_extract(e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_anas_extract(e10k_anlp1_t _regval)
{
    return((uint8_t )((_regval & 0xf0000) >> 16));
}

static inline e10k_anlp1_t e10k_anlp1_anas_insert(e10k_anlp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_anas_insert(e10k_anlp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((e10k_anlp1_t )(_fieldval)) << 16)));
}

static inline int e10k_anlp1_prtval(char *_s, size_t _size, e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline int e10k_anlp1_prtval(char *_s, size_t _size, e10k_anlp1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_sel =\t%" PRIx8 "\t(LP AN adv Selector field)\n", e10k_anlp1_lpan_sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_echn =\t%" PRIx8 "\t(LP AN adv Echoed Nonce field)\n", e10k_anlp1_lpan_echn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_pause =\t%" PRIx8 "\t(LP AN adv Pause)\n", e10k_anlp1_lpan_pause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_rf =\t%" PRIx8 "\t(LP AN adv RF)\n", e10k_anlp1_lpan_rf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_ack =\t%" PRIx8 "\t(LP AN adv Acknowledge)\n", e10k_anlp1_lpan_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_np =\t%" PRIx8 "\t(LP AN adv NP)\n", e10k_anlp1_lpan_np_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anas =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto-Negotiation Arbitration State)\n", e10k_anlp1_anas_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_anlp2_t
 * Description: Implicit type of Auto Negotiation Link Partner Link Control Word 2 Register register
 * Fields:
 *   lpan_nf	(size 5, offset 0, init 0):	RO	LP AN adv page fields T[4:0]
 *   lpan_afl	(size 11, offset 5, init 0):	RO	LP AN adv page fields A[10:0]
 *   lpan_afh	(size 16, offset 16, init 0):	RO	LP AN adv page fields A[26:11]
 */
typedef uint32_t e10k_anlp2_t;
#define e10k_anlp2_default 0x0
static inline uint8_t e10k_anlp2_lpan_nf_extract(e10k_anlp2_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp2_lpan_nf_extract(e10k_anlp2_t _regval)
{
    return((uint8_t )((_regval & 0x1f) >> 0));
}

static inline e10k_anlp2_t e10k_anlp2_lpan_nf_insert(e10k_anlp2_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp2_t e10k_anlp2_lpan_nf_insert(e10k_anlp2_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffffe0) | (0x1f & (((e10k_anlp2_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_anlp2_lpan_afl_extract(e10k_anlp2_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_anlp2_lpan_afl_extract(e10k_anlp2_t _regval)
{
    return((uint16_t )((_regval & 0xffe0) >> 5));
}

static inline e10k_anlp2_t e10k_anlp2_lpan_afl_insert(e10k_anlp2_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp2_t e10k_anlp2_lpan_afl_insert(e10k_anlp2_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff001f) | (0xffe0 & (((e10k_anlp2_t )(_fieldval)) << 5)));
}

static inline uint16_t e10k_anlp2_lpan_afh_extract(e10k_anlp2_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_anlp2_lpan_afh_extract(e10k_anlp2_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_anlp2_t e10k_anlp2_lpan_afh_insert(e10k_anlp2_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlp2_t e10k_anlp2_lpan_afh_insert(e10k_anlp2_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_anlp2_t )(_fieldval)) << 16)));
}

static inline int e10k_anlp2_prtval(char *_s, size_t _size, e10k_anlp2_t _regval) __attribute__ ((always_inline));
static inline int e10k_anlp2_prtval(char *_s, size_t _size, e10k_anlp2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_nf =\t%" PRIx8 "\t(LP AN adv page fields T[4:0])\n", e10k_anlp2_lpan_nf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_afl =\t%" PRIx16 "\t(LP AN adv page fields A[10:0])\n", e10k_anlp2_lpan_afl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_afh =\t%" PRIx16 "\t(LP AN adv page fields A[26:11])\n", e10k_anlp2_lpan_afh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mmngc_t
 * Description: Implicit type of MAC Manageability Control Register register
 * Fields:
 *   mng_veto	(size 1, offset 0, init 0):	RO	MNG_VETO
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
typedef uint32_t e10k_mmngc_t;
#define e10k_mmngc_default 0x0
static inline uint8_t e10k_mmngc_mng_veto_extract(e10k_mmngc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mmngc_mng_veto_extract(e10k_mmngc_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_mmngc_t e10k_mmngc_mng_veto_insert(e10k_mmngc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mmngc_t e10k_mmngc_mng_veto_insert(e10k_mmngc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_mmngc_t )(_fieldval)) << 0)));
}

static inline int e10k_mmngc_prtval(char *_s, size_t _size, e10k_mmngc_t _regval) __attribute__ ((always_inline));
static inline int e10k_mmngc_prtval(char *_s, size_t _size, e10k_mmngc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mng_veto =\t%" PRIx8 "\t(MNG_VETO)\n", e10k_mmngc_mng_veto_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_anlpnp1_t
 * Description: Implicit type of Auto Negotiation Link Partner Next Page 1 Register register
 * Fields:
 *   msg	(size 11, offset 0, init 0):	RO	LP AN adv np Message/Unformatted Code
 *   toggle	(size 1, offset 11, init 0):	RO	LP AN adv np Toggle
 *   ack2	(size 1, offset 12, init 0):	RO	LP AN adv np Acknowledge2
 *   mp	(size 1, offset 13, init 0):	RO	LP AN adv np MP
 *   ack	(size 1, offset 14, init 0):	RO	LP AN adv np Acknowledge
 *   np	(size 1, offset 15, init 0):	RO	LP AN adv np NP
 *   ufmtc	(size 16, offset 16, init 0):	RO	LP AN adv np Unformatted Code
 */
typedef uint32_t e10k_anlpnp1_t;
#define e10k_anlpnp1_default 0x0
static inline uint16_t e10k_anlpnp1_msg_extract(e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_anlpnp1_msg_extract(e10k_anlpnp1_t _regval)
{
    return((uint16_t )((_regval & 0x7ff) >> 0));
}

static inline e10k_anlpnp1_t e10k_anlpnp1_msg_insert(e10k_anlpnp1_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_msg_insert(e10k_anlpnp1_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff800) | (0x7ff & (((e10k_anlpnp1_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_anlpnp1_toggle_extract(e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_toggle_extract(e10k_anlpnp1_t _regval)
{
    return((uint8_t )((_regval & 0x800) >> 11));
}

static inline e10k_anlpnp1_t e10k_anlpnp1_toggle_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_toggle_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff7ff) | (0x800 & (((e10k_anlpnp1_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_anlpnp1_ack2_extract(e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_ack2_extract(e10k_anlpnp1_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_anlpnp1_t e10k_anlpnp1_ack2_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_ack2_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_anlpnp1_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_anlpnp1_mp_extract(e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_mp_extract(e10k_anlpnp1_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_anlpnp1_t e10k_anlpnp1_mp_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_mp_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_anlpnp1_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_anlpnp1_ack_extract(e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_ack_extract(e10k_anlpnp1_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_anlpnp1_t e10k_anlpnp1_ack_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_ack_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_anlpnp1_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_anlpnp1_np_extract(e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_np_extract(e10k_anlpnp1_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_anlpnp1_t e10k_anlpnp1_np_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_np_insert(e10k_anlpnp1_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_anlpnp1_t )(_fieldval)) << 15)));
}

static inline uint16_t e10k_anlpnp1_ufmtc_extract(e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_anlpnp1_ufmtc_extract(e10k_anlpnp1_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_anlpnp1_t e10k_anlpnp1_ufmtc_insert(e10k_anlpnp1_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_ufmtc_insert(e10k_anlpnp1_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_anlpnp1_t )(_fieldval)) << 16)));
}

static inline int e10k_anlpnp1_prtval(char *_s, size_t _size, e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline int e10k_anlpnp1_prtval(char *_s, size_t _size, e10k_anlpnp1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msg =\t%" PRIx16 "\t(LP AN adv np Message/Unformatted Code)\n", e10k_anlpnp1_msg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " toggle =\t%" PRIx8 "\t(LP AN adv np Toggle)\n", e10k_anlpnp1_toggle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack2 =\t%" PRIx8 "\t(LP AN adv np Acknowledge2)\n", e10k_anlpnp1_ack2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mp =\t%" PRIx8 "\t(LP AN adv np MP)\n", e10k_anlpnp1_mp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(LP AN adv np Acknowledge)\n", e10k_anlpnp1_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " np =\t%" PRIx8 "\t(LP AN adv np NP)\n", e10k_anlpnp1_np_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ufmtc =\t%" PRIx16 "\t(LP AN adv np Unformatted Code)\n", e10k_anlpnp1_ufmtc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_anlpnp2_t
 * Description: Implicit type of Auto Negotiation Link Partner Next Page 2 Register register
 * Fields:
 *   lpan_nph	(size 16, offset 0, init 0):	RO	LP AN Next Page Fields D[47:32]. [15:0] = Unformatted Code
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
typedef uint32_t e10k_anlpnp2_t;
#define e10k_anlpnp2_default 0x0
static inline uint16_t e10k_anlpnp2_lpan_nph_extract(e10k_anlpnp2_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_anlpnp2_lpan_nph_extract(e10k_anlpnp2_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_anlpnp2_t e10k_anlpnp2_lpan_nph_insert(e10k_anlpnp2_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_anlpnp2_t e10k_anlpnp2_lpan_nph_insert(e10k_anlpnp2_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_anlpnp2_t )(_fieldval)) << 0)));
}

static inline int e10k_anlpnp2_prtval(char *_s, size_t _size, e10k_anlpnp2_t _regval) __attribute__ ((always_inline));
static inline int e10k_anlpnp2_prtval(char *_s, size_t _size, e10k_anlpnp2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_nph =\t%" PRIx16 "\t(LP AN Next Page Fields D[47:32]. [15:0] = Unformatted Code)\n", e10k_anlpnp2_lpan_nph_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_krpcsfc_t
 * Description: Implicit type of KR PCS and FEC Control Register register
 * Fields:
 *   _anon0	(size 11, offset 0, init 0):	MBZ	_
 *   _anon11	(size 5, offset 11, init 0):	RSVD	_
 *   fec_enerr	(size 1, offset 16, init 0):	RW	FEC Enable Error Indication to KR-PCS
 *   _anon17	(size 1, offset 17, init 0):	RSVD	_
 *   fec_ncnt	(size 2, offset 18, init 0):	RW	Good Parity Block Count
 *   fec_mcnt	(size 2, offset 20, init 0):	RW	Bad Parity Block Count
 *   fec_lmode	(size 1, offset 22, init 0):	RW	Enables FEC Loose Mode
 *   fec_rxswp	(size 1, offset 23, init 0):	RW	FEC Rx Bit Order Swap
 *   fec_txswp	(size 1, offset 24, init 0):	RW	FEC Tx Bit Order Swap
 *   _anon25	(size 1, offset 25, init 0):	RSVD	_
 *   slipass	(size 1, offset 26, init 0):	RW	Loss of Sync (frame_align) Idle Pass-Through Select
 *   ssync	(size 1, offset 27, init 0):	RW	Rx Block Lock Override
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t e10k_krpcsfc_t;
#define e10k_krpcsfc_default 0x0
static inline uint8_t e10k_krpcsfc_fec_enerr_extract(e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_fec_enerr_extract(e10k_krpcsfc_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_fec_enerr_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_fec_enerr_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_krpcsfc_t )(_fieldval)) << 16)));
}

static inline e10k_fec_ncnt_t e10k_krpcsfc_fec_ncnt_extract(e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline e10k_fec_ncnt_t e10k_krpcsfc_fec_ncnt_extract(e10k_krpcsfc_t _regval)
{
    return((e10k_fec_ncnt_t )((_regval & 0xc0000) >> 18));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_fec_ncnt_insert(e10k_krpcsfc_t _regval, e10k_fec_ncnt_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_fec_ncnt_insert(e10k_krpcsfc_t _regval, e10k_fec_ncnt_t _fieldval)
{
    return((_regval & 0xfff3ffff) | (0xc0000 & (((e10k_krpcsfc_t )(_fieldval)) << 18)));
}

static inline e10k_fec_mcnt_t e10k_krpcsfc_fec_mcnt_extract(e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline e10k_fec_mcnt_t e10k_krpcsfc_fec_mcnt_extract(e10k_krpcsfc_t _regval)
{
    return((e10k_fec_mcnt_t )((_regval & 0x300000) >> 20));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_fec_mcnt_insert(e10k_krpcsfc_t _regval, e10k_fec_mcnt_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_fec_mcnt_insert(e10k_krpcsfc_t _regval, e10k_fec_mcnt_t _fieldval)
{
    return((_regval & 0xffcfffff) | (0x300000 & (((e10k_krpcsfc_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_krpcsfc_fec_lmode_extract(e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_fec_lmode_extract(e10k_krpcsfc_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_fec_lmode_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_fec_lmode_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_krpcsfc_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_krpcsfc_fec_rxswp_extract(e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_fec_rxswp_extract(e10k_krpcsfc_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_fec_rxswp_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_fec_rxswp_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_krpcsfc_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_krpcsfc_fec_txswp_extract(e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_fec_txswp_extract(e10k_krpcsfc_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_fec_txswp_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_fec_txswp_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_krpcsfc_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_krpcsfc_slipass_extract(e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_slipass_extract(e10k_krpcsfc_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_slipass_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_slipass_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_krpcsfc_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_krpcsfc_ssync_extract(e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_ssync_extract(e10k_krpcsfc_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_ssync_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_ssync_insert(e10k_krpcsfc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_krpcsfc_t )(_fieldval)) << 27)));
}

static inline int e10k_krpcsfc_prtval(char *_s, size_t _size, e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline int e10k_krpcsfc_prtval(char *_s, size_t _size, e10k_krpcsfc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_enerr =\t%" PRIx8 "\t(FEC Enable Error Indication to KR-PCS)\n", e10k_krpcsfc_fec_enerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_ncnt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fec_ncnt_prtval(_s + _r, _avail, e10k_krpcsfc_fec_ncnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Good Parity Block Count)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_mcnt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fec_mcnt_prtval(_s + _r, _avail, e10k_krpcsfc_fec_mcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Bad Parity Block Count)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_lmode =\t%" PRIx8 "\t(Enables FEC Loose Mode)\n", e10k_krpcsfc_fec_lmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_rxswp =\t%" PRIx8 "\t(FEC Rx Bit Order Swap)\n", e10k_krpcsfc_fec_rxswp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_txswp =\t%" PRIx8 "\t(FEC Tx Bit Order Swap)\n", e10k_krpcsfc_fec_txswp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " slipass =\t%" PRIx8 "\t(Loss of Sync (frame_align) Idle Pass-Through Select)\n", e10k_krpcsfc_slipass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ssync =\t%" PRIx8 "\t(Rx Block Lock Override)\n", e10k_krpcsfc_ssync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_krpcss_t
 * Description: Implicit type of KR PCS Status Register register
 * Fields:
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   errcnt_blk	(size 8, offset 3, init 0):	RC	Rx Decoder Error Counter
 *   berbad_cnt	(size 6, offset 11, init 0):	RC	BER Bad Counter
 *   rxfifo_elh	(size 1, offset 17, init 0):	RC	Elastic Buffer Error
 *   rxlf_det	(size 1, offset 18, init 0):	RC	RX_LF Detect
 *   rxfrm_alerr	(size 1, offset 19, init 0):	RC	Frame Align Error
 *   blklck	(size 1, offset 20, init 0):	RO	Rx Block Lock Status bit
 *   hber_sts	(size 1, offset 21, init 0):	RC	Rx High Bit Error Rate Status bit
 *   rxfl_det2	(size 1, offset 22, init 0):	RC	RX_LF Detect
 *   lnk_sts	(size 1, offset 23, init 0):	RO	Rx Link Status
 *   rx_ufl	(size 1, offset 24, init 0):	RC	Rx Underflow Status
 *   rx_ofl	(size 1, offset 25, init 0):	RC	Rx Overflow Status
 *   rx_fifoerr	(size 1, offset 26, init 0):	RO	Rx Elastic Buffer Error
 *   rx_dataval	(size 1, offset 27, init 0):	RO	Data Valid Status
 *   tx_ufl	(size 1, offset 28, init 0):	RC	Tx Underflow Status
 *   tx_ofl	(size 1, offset 29, init 0):	RC	Tx Overflow Status
 *   tx_fifoerr	(size 1, offset 30, init 0):	RO	Unlatched FIFO Error Status
 *   tx_dataval	(size 1, offset 31, init 0):	RO	Data Valid Status
 */
typedef uint32_t e10k_krpcss_t;
#define e10k_krpcss_default 0x0
static inline uint8_t e10k_krpcss_errcnt_blk_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_errcnt_blk_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x7f8) >> 3));
}

static inline e10k_krpcss_t e10k_krpcss_errcnt_blk_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_errcnt_blk_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff807) | (0x7f8 & (((e10k_krpcss_t )(_fieldval)) << 3)));
}

static inline uint8_t e10k_krpcss_berbad_cnt_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_berbad_cnt_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x1f800) >> 11));
}

static inline e10k_krpcss_t e10k_krpcss_berbad_cnt_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_berbad_cnt_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffe07ff) | (0x1f800 & (((e10k_krpcss_t )(_fieldval)) << 11)));
}

static inline uint8_t e10k_krpcss_rxfifo_elh_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rxfifo_elh_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_krpcss_t e10k_krpcss_rxfifo_elh_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rxfifo_elh_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_krpcss_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_krpcss_rxlf_det_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rxlf_det_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x40000) >> 18));
}

static inline e10k_krpcss_t e10k_krpcss_rxlf_det_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rxlf_det_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffbffff) | (0x40000 & (((e10k_krpcss_t )(_fieldval)) << 18)));
}

static inline uint8_t e10k_krpcss_rxfrm_alerr_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rxfrm_alerr_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_krpcss_t e10k_krpcss_rxfrm_alerr_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rxfrm_alerr_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_krpcss_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_krpcss_blklck_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_blklck_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_krpcss_t e10k_krpcss_blklck_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_blklck_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_krpcss_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_krpcss_hber_sts_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_hber_sts_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_krpcss_t e10k_krpcss_hber_sts_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_hber_sts_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_krpcss_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_krpcss_rxfl_det2_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rxfl_det2_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_krpcss_t e10k_krpcss_rxfl_det2_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rxfl_det2_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_krpcss_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_krpcss_lnk_sts_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_lnk_sts_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_krpcss_t e10k_krpcss_lnk_sts_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_lnk_sts_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_krpcss_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_krpcss_rx_ufl_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rx_ufl_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_krpcss_t e10k_krpcss_rx_ufl_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rx_ufl_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_krpcss_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_krpcss_rx_ofl_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rx_ofl_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_krpcss_t e10k_krpcss_rx_ofl_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rx_ofl_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_krpcss_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_krpcss_rx_fifoerr_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rx_fifoerr_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_krpcss_t e10k_krpcss_rx_fifoerr_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rx_fifoerr_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_krpcss_t )(_fieldval)) << 26)));
}

static inline uint8_t e10k_krpcss_rx_dataval_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rx_dataval_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x8000000) >> 27));
}

static inline e10k_krpcss_t e10k_krpcss_rx_dataval_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rx_dataval_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf7ffffff) | (0x8000000 & (((e10k_krpcss_t )(_fieldval)) << 27)));
}

static inline uint8_t e10k_krpcss_tx_ufl_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_tx_ufl_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x10000000) >> 28));
}

static inline e10k_krpcss_t e10k_krpcss_tx_ufl_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_tx_ufl_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xefffffff) | (0x10000000 & (((e10k_krpcss_t )(_fieldval)) << 28)));
}

static inline uint8_t e10k_krpcss_tx_ofl_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_tx_ofl_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_krpcss_t e10k_krpcss_tx_ofl_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_tx_ofl_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_krpcss_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_krpcss_tx_fifoerr_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_tx_fifoerr_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_krpcss_t e10k_krpcss_tx_fifoerr_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_tx_fifoerr_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_krpcss_t )(_fieldval)) << 30)));
}

static inline uint8_t e10k_krpcss_tx_dataval_extract(e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_tx_dataval_extract(e10k_krpcss_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_krpcss_t e10k_krpcss_tx_dataval_insert(e10k_krpcss_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_tx_dataval_insert(e10k_krpcss_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_krpcss_t )(_fieldval)) << 31)));
}

static inline int e10k_krpcss_prtval(char *_s, size_t _size, e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline int e10k_krpcss_prtval(char *_s, size_t _size, e10k_krpcss_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " errcnt_blk =\t%" PRIx8 "\t(Rx Decoder Error Counter)\n", e10k_krpcss_errcnt_blk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " berbad_cnt =\t%" PRIx8 "\t(BER Bad Counter)\n", e10k_krpcss_berbad_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_elh =\t%" PRIx8 "\t(Elastic Buffer Error)\n", e10k_krpcss_rxfifo_elh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxlf_det =\t%" PRIx8 "\t(RX_LF Detect)\n", e10k_krpcss_rxlf_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfrm_alerr =\t%" PRIx8 "\t(Frame Align Error)\n", e10k_krpcss_rxfrm_alerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " blklck =\t%" PRIx8 "\t(Rx Block Lock Status bit)\n", e10k_krpcss_blklck_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hber_sts =\t%" PRIx8 "\t(Rx High Bit Error Rate Status bit)\n", e10k_krpcss_hber_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfl_det2 =\t%" PRIx8 "\t(RX_LF Detect)\n", e10k_krpcss_rxfl_det2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_sts =\t%" PRIx8 "\t(Rx Link Status)\n", e10k_krpcss_lnk_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_ufl =\t%" PRIx8 "\t(Rx Underflow Status)\n", e10k_krpcss_rx_ufl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_ofl =\t%" PRIx8 "\t(Rx Overflow Status)\n", e10k_krpcss_rx_ofl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifoerr =\t%" PRIx8 "\t(Rx Elastic Buffer Error)\n", e10k_krpcss_rx_fifoerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_dataval =\t%" PRIx8 "\t(Data Valid Status)\n", e10k_krpcss_rx_dataval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_ufl =\t%" PRIx8 "\t(Tx Underflow Status)\n", e10k_krpcss_tx_ufl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_ofl =\t%" PRIx8 "\t(Tx Overflow Status)\n", e10k_krpcss_tx_ofl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifoerr =\t%" PRIx8 "\t(Unlatched FIFO Error Status)\n", e10k_krpcss_tx_fifoerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_dataval =\t%" PRIx8 "\t(Data Valid Status)\n", e10k_krpcss_tx_dataval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fecs1_t
 * Description: Implicit type of FEC Status 1 Register register
 * Fields:
 *   fec_cr	(size 32, offset 0, init 0):	RC	FEC Correctable Error Counter
 */
typedef uint32_t e10k_fecs1_t;
#define e10k_fecs1_default 0x0
static inline uint32_t e10k_fecs1_fec_cr_extract(e10k_fecs1_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fecs1_fec_cr_extract(e10k_fecs1_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fecs1_t e10k_fecs1_fec_cr_insert(e10k_fecs1_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fecs1_t e10k_fecs1_fec_cr_insert(e10k_fecs1_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fecs1_t )(_fieldval)) << 0)));
}

static inline int e10k_fecs1_prtval(char *_s, size_t _size, e10k_fecs1_t _regval) __attribute__ ((always_inline));
static inline int e10k_fecs1_prtval(char *_s, size_t _size, e10k_fecs1_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_cr =\t%" PRIx32 "\t(FEC Correctable Error Counter)\n", e10k_fecs1_fec_cr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_fecs2_t
 * Description: Implicit type of FEC Status 2 Register register
 * Fields:
 *   fec_uncr	(size 32, offset 0, init 0):	RC	FEC Uncorrectable Error Counter
 */
typedef uint32_t e10k_fecs2_t;
#define e10k_fecs2_default 0x0
static inline uint32_t e10k_fecs2_fec_uncr_extract(e10k_fecs2_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_fecs2_fec_uncr_extract(e10k_fecs2_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_fecs2_t e10k_fecs2_fec_uncr_insert(e10k_fecs2_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_fecs2_t e10k_fecs2_fec_uncr_insert(e10k_fecs2_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_fecs2_t )(_fieldval)) << 0)));
}

static inline int e10k_fecs2_prtval(char *_s, size_t _size, e10k_fecs2_t _regval) __attribute__ ((always_inline));
static inline int e10k_fecs2_prtval(char *_s, size_t _size, e10k_fecs2_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_uncr =\t%" PRIx32 "\t(FEC Uncorrectable Error Counter)\n", e10k_fecs2_fec_uncr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_corectl_t
 * Description: Implicit type of Core Analog Configuration Register register
 * Fields:
 *   data	(size 8, offset 0, init 0):	RW	Data to Core Analog Registers
 *   address	(size 8, offset 8, init 0):	RW	Address to Core Analog Registers
 *   latch_addr	(size 1, offset 16, init 0):	RW	Latch address
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
typedef uint32_t e10k_corectl_t;
#define e10k_corectl_default 0x0
static inline uint8_t e10k_corectl_data_extract(e10k_corectl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_corectl_data_extract(e10k_corectl_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e10k_corectl_t e10k_corectl_data_insert(e10k_corectl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_corectl_t e10k_corectl_data_insert(e10k_corectl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_corectl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_corectl_address_extract(e10k_corectl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_corectl_address_extract(e10k_corectl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e10k_corectl_t e10k_corectl_address_insert(e10k_corectl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_corectl_t e10k_corectl_address_insert(e10k_corectl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e10k_corectl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_corectl_latch_addr_extract(e10k_corectl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_corectl_latch_addr_extract(e10k_corectl_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_corectl_t e10k_corectl_latch_addr_insert(e10k_corectl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_corectl_t e10k_corectl_latch_addr_insert(e10k_corectl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_corectl_t )(_fieldval)) << 16)));
}

static inline int e10k_corectl_prtval(char *_s, size_t _size, e10k_corectl_t _regval) __attribute__ ((always_inline));
static inline int e10k_corectl_prtval(char *_s, size_t _size, e10k_corectl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to Core Analog Registers)\n", e10k_corectl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to Core Analog Registers)\n", e10k_corectl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " latch_addr =\t%" PRIx8 "\t(Latch address)\n", e10k_corectl_latch_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_smadarctl_t
 * Description: Implicit type of Core Common Configuration Register register
 * Fields:
 *   data	(size 8, offset 0, init 0):	RW	Data to Core Analog Registers
 *   address	(size 8, offset 8, init 0):	RW	Address to Core Analog Registers
 *   latch_addr	(size 1, offset 16, init 0):	RW	Latch address
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
typedef uint32_t e10k_smadarctl_t;
#define e10k_smadarctl_default 0x0
static inline uint8_t e10k_smadarctl_data_extract(e10k_smadarctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_smadarctl_data_extract(e10k_smadarctl_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e10k_smadarctl_t e10k_smadarctl_data_insert(e10k_smadarctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_smadarctl_t e10k_smadarctl_data_insert(e10k_smadarctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_smadarctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_smadarctl_address_extract(e10k_smadarctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_smadarctl_address_extract(e10k_smadarctl_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e10k_smadarctl_t e10k_smadarctl_address_insert(e10k_smadarctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_smadarctl_t e10k_smadarctl_address_insert(e10k_smadarctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e10k_smadarctl_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_smadarctl_latch_addr_extract(e10k_smadarctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_smadarctl_latch_addr_extract(e10k_smadarctl_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_smadarctl_t e10k_smadarctl_latch_addr_insert(e10k_smadarctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_smadarctl_t e10k_smadarctl_latch_addr_insert(e10k_smadarctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_smadarctl_t )(_fieldval)) << 16)));
}

static inline int e10k_smadarctl_prtval(char *_s, size_t _size, e10k_smadarctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_smadarctl_prtval(char *_s, size_t _size, e10k_smadarctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to Core Analog Registers)\n", e10k_smadarctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to Core Analog Registers)\n", e10k_smadarctl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " latch_addr =\t%" PRIx8 "\t(Latch address)\n", e10k_smadarctl_latch_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mflcn_t
 * Description: Implicit type of MAC Flow Control Register register
 * Fields:
 *   pmcf	(size 1, offset 0, init 0):	RW	Pass MAC Control Frames
 *   dpf	(size 1, offset 1, init 0):	RW	Discard Pause Frame
 *   rpfce	(size 1, offset 2, init 0):	RW	Receive Priority Flow Control Enable
 *   rfce	(size 1, offset 3, init 0):	RW	Receive Flow Control Enable
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
typedef uint32_t e10k_mflcn_t;
#define e10k_mflcn_default 0x0
static inline uint8_t e10k_mflcn_pmcf_extract(e10k_mflcn_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mflcn_pmcf_extract(e10k_mflcn_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_mflcn_t e10k_mflcn_pmcf_insert(e10k_mflcn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mflcn_t e10k_mflcn_pmcf_insert(e10k_mflcn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_mflcn_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_mflcn_dpf_extract(e10k_mflcn_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mflcn_dpf_extract(e10k_mflcn_t _regval)
{
    return((uint8_t )((_regval & 0x2) >> 1));
}

static inline e10k_mflcn_t e10k_mflcn_dpf_insert(e10k_mflcn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mflcn_t e10k_mflcn_dpf_insert(e10k_mflcn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffd) | (0x2 & (((e10k_mflcn_t )(_fieldval)) << 1)));
}

static inline uint8_t e10k_mflcn_rpfce_extract(e10k_mflcn_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mflcn_rpfce_extract(e10k_mflcn_t _regval)
{
    return((uint8_t )((_regval & 0x4) >> 2));
}

static inline e10k_mflcn_t e10k_mflcn_rpfce_insert(e10k_mflcn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mflcn_t e10k_mflcn_rpfce_insert(e10k_mflcn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffb) | (0x4 & (((e10k_mflcn_t )(_fieldval)) << 2)));
}

static inline uint8_t e10k_mflcn_rfce_extract(e10k_mflcn_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mflcn_rfce_extract(e10k_mflcn_t _regval)
{
    return((uint8_t )((_regval & 0x8) >> 3));
}

static inline e10k_mflcn_t e10k_mflcn_rfce_insert(e10k_mflcn_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mflcn_t e10k_mflcn_rfce_insert(e10k_mflcn_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff7) | (0x8 & (((e10k_mflcn_t )(_fieldval)) << 3)));
}

static inline int e10k_mflcn_prtval(char *_s, size_t _size, e10k_mflcn_t _regval) __attribute__ ((always_inline));
static inline int e10k_mflcn_prtval(char *_s, size_t _size, e10k_mflcn_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmcf =\t%" PRIx8 "\t(Pass MAC Control Frames)\n", e10k_mflcn_pmcf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpf =\t%" PRIx8 "\t(Discard Pause Frame)\n", e10k_mflcn_dpf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rpfce =\t%" PRIx8 "\t(Receive Priority Flow Control Enable)\n", e10k_mflcn_rpfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfce =\t%" PRIx8 "\t(Receive Flow Control Enable)\n", e10k_mflcn_rfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_sgmiic_t
 * Description: Implicit type of SGMII Control Register register
 * Fields:
 *   srxrassmp	(size 4, offset 0, init 0):	RW	Shift Rx Rate-Adapt Single Data Sampling
 *   srxrarsmp	(size 4, offset 4, init 0):	RW	Shift Rx Rate-Adapt Replicated Data Sampling
 *   stxrasmp	(size 4, offset 8, init 0):	RW	Shift Tx Rate-Adapt Sampling
 *   ansflu100	(size 1, offset 12, init 0):	RW	AN SGMII Force Link Up 100 Mb/s
 *   ansbyp	(size 1, offset 13, init 0):	RW	AN SGMII Bypass
 *   anstrig	(size 1, offset 14, init 0):	RW	AN SGMII Trigger
 *   anslnktmr	(size 1, offset 15, init 0):	RW	AN SGMII Link-Timer
 *   _anon16	(size 1, offset 16, init 0):	RSVD	_
 *   anignrrxrf	(size 1, offset 17, init 0):	RW	Auto-Negotiation Ignore Received RF Field
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
typedef uint32_t e10k_sgmiic_t;
#define e10k_sgmiic_default 0x0
static inline uint8_t e10k_sgmiic_srxrassmp_extract(e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_srxrassmp_extract(e10k_sgmiic_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline e10k_sgmiic_t e10k_sgmiic_srxrassmp_insert(e10k_sgmiic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_srxrassmp_insert(e10k_sgmiic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((e10k_sgmiic_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_sgmiic_srxrarsmp_extract(e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_srxrarsmp_extract(e10k_sgmiic_t _regval)
{
    return((uint8_t )((_regval & 0xf0) >> 4));
}

static inline e10k_sgmiic_t e10k_sgmiic_srxrarsmp_insert(e10k_sgmiic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_srxrarsmp_insert(e10k_sgmiic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff0f) | (0xf0 & (((e10k_sgmiic_t )(_fieldval)) << 4)));
}

static inline uint8_t e10k_sgmiic_stxrasmp_extract(e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_stxrasmp_extract(e10k_sgmiic_t _regval)
{
    return((uint8_t )((_regval & 0xf00) >> 8));
}

static inline e10k_sgmiic_t e10k_sgmiic_stxrasmp_insert(e10k_sgmiic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_stxrasmp_insert(e10k_sgmiic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffff0ff) | (0xf00 & (((e10k_sgmiic_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_sgmiic_ansflu100_extract(e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_ansflu100_extract(e10k_sgmiic_t _regval)
{
    return((uint8_t )((_regval & 0x1000) >> 12));
}

static inline e10k_sgmiic_t e10k_sgmiic_ansflu100_insert(e10k_sgmiic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_ansflu100_insert(e10k_sgmiic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffefff) | (0x1000 & (((e10k_sgmiic_t )(_fieldval)) << 12)));
}

static inline uint8_t e10k_sgmiic_ansbyp_extract(e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_ansbyp_extract(e10k_sgmiic_t _regval)
{
    return((uint8_t )((_regval & 0x2000) >> 13));
}

static inline e10k_sgmiic_t e10k_sgmiic_ansbyp_insert(e10k_sgmiic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_ansbyp_insert(e10k_sgmiic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffdfff) | (0x2000 & (((e10k_sgmiic_t )(_fieldval)) << 13)));
}

static inline uint8_t e10k_sgmiic_anstrig_extract(e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_anstrig_extract(e10k_sgmiic_t _regval)
{
    return((uint8_t )((_regval & 0x4000) >> 14));
}

static inline e10k_sgmiic_t e10k_sgmiic_anstrig_insert(e10k_sgmiic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_anstrig_insert(e10k_sgmiic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffbfff) | (0x4000 & (((e10k_sgmiic_t )(_fieldval)) << 14)));
}

static inline uint8_t e10k_sgmiic_anslnktmr_extract(e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_anslnktmr_extract(e10k_sgmiic_t _regval)
{
    return((uint8_t )((_regval & 0x8000) >> 15));
}

static inline e10k_sgmiic_t e10k_sgmiic_anslnktmr_insert(e10k_sgmiic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_anslnktmr_insert(e10k_sgmiic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff7fff) | (0x8000 & (((e10k_sgmiic_t )(_fieldval)) << 15)));
}

static inline uint8_t e10k_sgmiic_anignrrxrf_extract(e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_anignrrxrf_extract(e10k_sgmiic_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_sgmiic_t e10k_sgmiic_anignrrxrf_insert(e10k_sgmiic_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_anignrrxrf_insert(e10k_sgmiic_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_sgmiic_t )(_fieldval)) << 17)));
}

static inline int e10k_sgmiic_prtval(char *_s, size_t _size, e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline int e10k_sgmiic_prtval(char *_s, size_t _size, e10k_sgmiic_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srxrassmp =\t%" PRIx8 "\t(Shift Rx Rate-Adapt Single Data Sampling)\n", e10k_sgmiic_srxrassmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srxrarsmp =\t%" PRIx8 "\t(Shift Rx Rate-Adapt Replicated Data Sampling)\n", e10k_sgmiic_srxrarsmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stxrasmp =\t%" PRIx8 "\t(Shift Tx Rate-Adapt Sampling)\n", e10k_sgmiic_stxrasmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ansflu100 =\t%" PRIx8 "\t(AN SGMII Force Link Up 100 Mb/s)\n", e10k_sgmiic_ansflu100_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ansbyp =\t%" PRIx8 "\t(AN SGMII Bypass)\n", e10k_sgmiic_ansbyp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anstrig =\t%" PRIx8 "\t(AN SGMII Trigger)\n", e10k_sgmiic_anstrig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anslnktmr =\t%" PRIx8 "\t(AN SGMII Link-Timer)\n", e10k_sgmiic_anslnktmr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anignrrxrf =\t%" PRIx8 "\t(Auto-Negotiation Ignore Received RF Field)\n", e10k_sgmiic_anignrrxrf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mavtv_t
 * Description: Implicit type of Management VLAN TAG Value register array
 * Fields:
 *   vid	(size 12, offset 0, init 0):	NOATTR	VLAN ID that should be compared with incoming packet
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
typedef uint32_t e10k_mavtv_t;
#define e10k_mavtv_default 0x0
static inline uint16_t e10k_mavtv_vid_extract(e10k_mavtv_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_mavtv_vid_extract(e10k_mavtv_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e10k_mavtv_t e10k_mavtv_vid_insert(e10k_mavtv_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mavtv_t e10k_mavtv_vid_insert(e10k_mavtv_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e10k_mavtv_t )(_fieldval)) << 0)));
}

static inline int e10k_mavtv_prtval(char *_s, size_t _size, e10k_mavtv_t _regval) __attribute__ ((always_inline));
static inline int e10k_mavtv_prtval(char *_s, size_t _size, e10k_mavtv_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vid =\t%" PRIx16 "\t(VLAN ID that should be compared with incoming packet)\n", e10k_mavtv_vid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mfutp_t
 * Description: Implicit type of Management Flex UDP/TP Ports register array
 * Fields:
 *   mfutp_1	(size 16, offset 0, init 0):	NOATTR	VLAN ID that should be compared with incoming packet
 *   mfutp_2	(size 16, offset 16, init 0):	NOATTR	VLAN ID that should be compared with incoming packet
 */
typedef uint32_t e10k_mfutp_t;
#define e10k_mfutp_default 0x0
static inline uint16_t e10k_mfutp_mfutp_1_extract(e10k_mfutp_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_mfutp_mfutp_1_extract(e10k_mfutp_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_mfutp_t e10k_mfutp_mfutp_1_insert(e10k_mfutp_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mfutp_t e10k_mfutp_mfutp_1_insert(e10k_mfutp_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_mfutp_t )(_fieldval)) << 0)));
}

static inline uint16_t e10k_mfutp_mfutp_2_extract(e10k_mfutp_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_mfutp_mfutp_2_extract(e10k_mfutp_t _regval)
{
    return((uint16_t )((_regval & 0xffff0000) >> 16));
}

static inline e10k_mfutp_t e10k_mfutp_mfutp_2_insert(e10k_mfutp_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mfutp_t e10k_mfutp_mfutp_2_insert(e10k_mfutp_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff) | (0xffff0000 & (((e10k_mfutp_t )(_fieldval)) << 16)));
}

static inline int e10k_mfutp_prtval(char *_s, size_t _size, e10k_mfutp_t _regval) __attribute__ ((always_inline));
static inline int e10k_mfutp_prtval(char *_s, size_t _size, e10k_mfutp_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mfutp_1 =\t%" PRIx16 "\t(VLAN ID that should be compared with incoming packet)\n", e10k_mfutp_mfutp_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mfutp_2 =\t%" PRIx16 "\t(VLAN ID that should be compared with incoming packet)\n", e10k_mfutp_mfutp_2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_metf_t
 * Description: Implicit type of Management Ethernet Type Filter register array
 * Fields:
 *   etype	(size 16, offset 0, init 0):	NOATTR	EtherType value to be compared with incoming packet
 *   _anon16	(size 14, offset 16, init 0):	RSVD	_
 *   polarity	(size 1, offset 30, init 0):	NOATTR	Negative filter
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_metf_t;
#define e10k_metf_default 0x0
static inline uint16_t e10k_metf_etype_extract(e10k_metf_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_metf_etype_extract(e10k_metf_t _regval)
{
    return((uint16_t )((_regval & 0xffff) >> 0));
}

static inline e10k_metf_t e10k_metf_etype_insert(e10k_metf_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_metf_t e10k_metf_etype_insert(e10k_metf_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xffff0000) | (0xffff & (((e10k_metf_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_metf_polarity_extract(e10k_metf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_metf_polarity_extract(e10k_metf_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_metf_t e10k_metf_polarity_insert(e10k_metf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_metf_t e10k_metf_polarity_insert(e10k_metf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_metf_t )(_fieldval)) << 30)));
}

static inline int e10k_metf_prtval(char *_s, size_t _size, e10k_metf_t _regval) __attribute__ ((always_inline));
static inline int e10k_metf_prtval(char *_s, size_t _size, e10k_metf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " etype =\t%" PRIx16 "\t(EtherType value to be compared with incoming packet)\n", e10k_metf_etype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t%" PRIx8 "\t(Negative filter)\n", e10k_metf_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_manc_t
 * Description: Implicit type of Management Control Register register
 * Fields:
 *   _anon0	(size 17, offset 0, init 0):	RSVD	_
 *   rcv_tco_en	(size 1, offset 17, init 0):	RW	Receive TCO Packets Enabled
 *   _anon18	(size 1, offset 18, init 0):	RSVD	_
 *   rcv_all	(size 1, offset 19, init 0):	RW	Receive All Enable
 *   mcst_pl2	(size 1, offset 20, init 0):	RW	Receive All Multicast
 *   en_m2h	(size 1, offset 21, init 0):	RW	Enable manageability packets to host memory
 *   bp_vlan	(size 1, offset 22, init 0):	RW	VLAN filtering is bypassed for MNG packets
 *   en_xsum_flt	(size 1, offset 23, init 0):	RW	When set, this bit enables Xsum filtering to manageability
 *   en_ipv4_flt	(size 1, offset 24, init 0):	RW	Enable IPv4 address Filters
 *   fixed_net_t	(size 1, offset 25, init 0):	RW	Fixed next type
 *   net_type	(size 1, offset 26, init 0):	RW	Pass only VLAN tagged packets
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
typedef uint32_t e10k_manc_t;
#define e10k_manc_default 0x0
static inline uint8_t e10k_manc_rcv_tco_en_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_rcv_tco_en_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_manc_t e10k_manc_rcv_tco_en_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_rcv_tco_en_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_manc_t )(_fieldval)) << 17)));
}

static inline uint8_t e10k_manc_rcv_all_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_rcv_all_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x80000) >> 19));
}

static inline e10k_manc_t e10k_manc_rcv_all_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_rcv_all_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff7ffff) | (0x80000 & (((e10k_manc_t )(_fieldval)) << 19)));
}

static inline uint8_t e10k_manc_mcst_pl2_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_mcst_pl2_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x100000) >> 20));
}

static inline e10k_manc_t e10k_manc_mcst_pl2_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_mcst_pl2_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffefffff) | (0x100000 & (((e10k_manc_t )(_fieldval)) << 20)));
}

static inline uint8_t e10k_manc_en_m2h_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_en_m2h_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x200000) >> 21));
}

static inline e10k_manc_t e10k_manc_en_m2h_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_en_m2h_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffdfffff) | (0x200000 & (((e10k_manc_t )(_fieldval)) << 21)));
}

static inline uint8_t e10k_manc_bp_vlan_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_bp_vlan_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x400000) >> 22));
}

static inline e10k_manc_t e10k_manc_bp_vlan_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_bp_vlan_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffbfffff) | (0x400000 & (((e10k_manc_t )(_fieldval)) << 22)));
}

static inline uint8_t e10k_manc_en_xsum_flt_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_en_xsum_flt_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x800000) >> 23));
}

static inline e10k_manc_t e10k_manc_en_xsum_flt_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_en_xsum_flt_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xff7fffff) | (0x800000 & (((e10k_manc_t )(_fieldval)) << 23)));
}

static inline uint8_t e10k_manc_en_ipv4_flt_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_en_ipv4_flt_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x1000000) >> 24));
}

static inline e10k_manc_t e10k_manc_en_ipv4_flt_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_en_ipv4_flt_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfeffffff) | (0x1000000 & (((e10k_manc_t )(_fieldval)) << 24)));
}

static inline uint8_t e10k_manc_fixed_net_t_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_fixed_net_t_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x2000000) >> 25));
}

static inline e10k_manc_t e10k_manc_fixed_net_t_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_fixed_net_t_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfdffffff) | (0x2000000 & (((e10k_manc_t )(_fieldval)) << 25)));
}

static inline uint8_t e10k_manc_net_type_extract(e10k_manc_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_net_type_extract(e10k_manc_t _regval)
{
    return((uint8_t )((_regval & 0x4000000) >> 26));
}

static inline e10k_manc_t e10k_manc_net_type_insert(e10k_manc_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_net_type_insert(e10k_manc_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfbffffff) | (0x4000000 & (((e10k_manc_t )(_fieldval)) << 26)));
}

static inline int e10k_manc_prtval(char *_s, size_t _size, e10k_manc_t _regval) __attribute__ ((always_inline));
static inline int e10k_manc_prtval(char *_s, size_t _size, e10k_manc_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcv_tco_en =\t%" PRIx8 "\t(Receive TCO Packets Enabled)\n", e10k_manc_rcv_tco_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcv_all =\t%" PRIx8 "\t(Receive All Enable)\n", e10k_manc_rcv_all_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcst_pl2 =\t%" PRIx8 "\t(Receive All Multicast)\n", e10k_manc_mcst_pl2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_m2h =\t%" PRIx8 "\t(Enable manageability packets to host memory)\n", e10k_manc_en_m2h_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp_vlan =\t%" PRIx8 "\t(VLAN filtering is bypassed for MNG packets)\n", e10k_manc_bp_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_xsum_flt =\t%" PRIx8 "\t(When set, this bit enables Xsum filtering to manageability)\n", e10k_manc_en_xsum_flt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_ipv4_flt =\t%" PRIx8 "\t(Enable IPv4 address Filters)\n", e10k_manc_en_ipv4_flt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fixed_net_t =\t%" PRIx8 "\t(Fixed next type)\n", e10k_manc_fixed_net_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " net_type =\t%" PRIx8 "\t(Pass only VLAN tagged packets)\n", e10k_manc_net_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_mfval_t
 * Description: Implicit type of Manageability Filters Valid register
 * Fields:
 *   mac	(size 4, offset 0, init 0):	RW	Indicates if the MAC unicast filters contain valid MAC addresses
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   vlan	(size 8, offset 8, init 0):	RW	VLAN filter registers contain valid VLAN tags
 *   ipv4	(size 4, offset 16, init 0):	RW	IPv4 address filters contain valid addresses
 *   _anon20	(size 4, offset 20, init 0):	RSVD	_
 *   ipv6	(size 4, offset 24, init 0):	RW	IPv6 address filters contain valid addresses
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
typedef uint32_t e10k_mfval_t;
#define e10k_mfval_default 0x0
static inline uint8_t e10k_mfval_mac_extract(e10k_mfval_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mfval_mac_extract(e10k_mfval_t _regval)
{
    return((uint8_t )((_regval & 0xf) >> 0));
}

static inline e10k_mfval_t e10k_mfval_mac_insert(e10k_mfval_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mfval_t e10k_mfval_mac_insert(e10k_mfval_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffff0) | (0xf & (((e10k_mfval_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_mfval_vlan_extract(e10k_mfval_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mfval_vlan_extract(e10k_mfval_t _regval)
{
    return((uint8_t )((_regval & 0xff00) >> 8));
}

static inline e10k_mfval_t e10k_mfval_vlan_insert(e10k_mfval_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mfval_t e10k_mfval_vlan_insert(e10k_mfval_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff00ff) | (0xff00 & (((e10k_mfval_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_mfval_ipv4_extract(e10k_mfval_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mfval_ipv4_extract(e10k_mfval_t _regval)
{
    return((uint8_t )((_regval & 0xf0000) >> 16));
}

static inline e10k_mfval_t e10k_mfval_ipv4_insert(e10k_mfval_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mfval_t e10k_mfval_ipv4_insert(e10k_mfval_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfff0ffff) | (0xf0000 & (((e10k_mfval_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_mfval_ipv6_extract(e10k_mfval_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_mfval_ipv6_extract(e10k_mfval_t _regval)
{
    return((uint8_t )((_regval & 0xf000000) >> 24));
}

static inline e10k_mfval_t e10k_mfval_ipv6_insert(e10k_mfval_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_mfval_t e10k_mfval_ipv6_insert(e10k_mfval_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xf0ffffff) | (0xf000000 & (((e10k_mfval_t )(_fieldval)) << 24)));
}

static inline int e10k_mfval_prtval(char *_s, size_t _size, e10k_mfval_t _regval) __attribute__ ((always_inline));
static inline int e10k_mfval_prtval(char *_s, size_t _size, e10k_mfval_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mac =\t%" PRIx8 "\t(Indicates if the MAC unicast filters contain valid MAC addresses)\n", e10k_mfval_mac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan =\t%" PRIx8 "\t(VLAN filter registers contain valid VLAN tags)\n", e10k_mfval_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv4 =\t%" PRIx8 "\t(IPv4 address filters contain valid addresses)\n", e10k_mfval_ipv4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(IPv6 address filters contain valid addresses)\n", e10k_mfval_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_manc2h_t
 * Description: Implicit type of Management Control To Host Register register
 * Fields:
 *   host_en	(size 8, offset 0, init 0):	RW	Host Enable
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
typedef uint32_t e10k_manc2h_t;
#define e10k_manc2h_default 0x0
static inline uint8_t e10k_manc2h_host_en_extract(e10k_manc2h_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_manc2h_host_en_extract(e10k_manc2h_t _regval)
{
    return((uint8_t )((_regval & 0xff) >> 0));
}

static inline e10k_manc2h_t e10k_manc2h_host_en_insert(e10k_manc2h_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_manc2h_t e10k_manc2h_host_en_insert(e10k_manc2h_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffff00) | (0xff & (((e10k_manc2h_t )(_fieldval)) << 0)));
}

static inline int e10k_manc2h_prtval(char *_s, size_t _size, e10k_manc2h_t _regval) __attribute__ ((always_inline));
static inline int e10k_manc2h_prtval(char *_s, size_t _size, e10k_manc2h_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " host_en =\t%" PRIx8 "\t(Host Enable)\n", e10k_manc2h_host_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pfvtctl_t
 * Description: Implicit type of VT Control Register register
 * Fields:
 *   vt_en	(size 1, offset 0, init 0):	RW	Virtualization Enabled Mode
 *   _anon1	(size 6, offset 1, init 0):	RSVD	_
 *   def_pl	(size 6, offset 7, init 0):	RW	Default pool
 *   _anon13	(size 16, offset 13, init 0):	RSVD	_
 *   dis_def_pl	(size 1, offset 29, init 0):	RW	Disable default pool
 *   rpl_en	(size 1, offset 30, init 0):	RW	Replication enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
typedef uint32_t e10k_pfvtctl_t;
#define e10k_pfvtctl_default 0x0
static inline uint8_t e10k_pfvtctl_vt_en_extract(e10k_pfvtctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvtctl_vt_en_extract(e10k_pfvtctl_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_pfvtctl_t e10k_pfvtctl_vt_en_insert(e10k_pfvtctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfvtctl_t e10k_pfvtctl_vt_en_insert(e10k_pfvtctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_pfvtctl_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_pfvtctl_def_pl_extract(e10k_pfvtctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvtctl_def_pl_extract(e10k_pfvtctl_t _regval)
{
    return((uint8_t )((_regval & 0x1f80) >> 7));
}

static inline e10k_pfvtctl_t e10k_pfvtctl_def_pl_insert(e10k_pfvtctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfvtctl_t e10k_pfvtctl_def_pl_insert(e10k_pfvtctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffffe07f) | (0x1f80 & (((e10k_pfvtctl_t )(_fieldval)) << 7)));
}

static inline uint8_t e10k_pfvtctl_dis_def_pl_extract(e10k_pfvtctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvtctl_dis_def_pl_extract(e10k_pfvtctl_t _regval)
{
    return((uint8_t )((_regval & 0x20000000) >> 29));
}

static inline e10k_pfvtctl_t e10k_pfvtctl_dis_def_pl_insert(e10k_pfvtctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfvtctl_t e10k_pfvtctl_dis_def_pl_insert(e10k_pfvtctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xdfffffff) | (0x20000000 & (((e10k_pfvtctl_t )(_fieldval)) << 29)));
}

static inline uint8_t e10k_pfvtctl_rpl_en_extract(e10k_pfvtctl_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvtctl_rpl_en_extract(e10k_pfvtctl_t _regval)
{
    return((uint8_t )((_regval & 0x40000000) >> 30));
}

static inline e10k_pfvtctl_t e10k_pfvtctl_rpl_en_insert(e10k_pfvtctl_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfvtctl_t e10k_pfvtctl_rpl_en_insert(e10k_pfvtctl_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xbfffffff) | (0x40000000 & (((e10k_pfvtctl_t )(_fieldval)) << 30)));
}

static inline int e10k_pfvtctl_prtval(char *_s, size_t _size, e10k_pfvtctl_t _regval) __attribute__ ((always_inline));
static inline int e10k_pfvtctl_prtval(char *_s, size_t _size, e10k_pfvtctl_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vt_en =\t%" PRIx8 "\t(Virtualization Enabled Mode)\n", e10k_pfvtctl_vt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " def_pl =\t%" PRIx8 "\t(Default pool)\n", e10k_pfvtctl_def_pl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis_def_pl =\t%" PRIx8 "\t(Disable default pool)\n", e10k_pfvtctl_dis_def_pl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rpl_en =\t%" PRIx8 "\t(Replication enable)\n", e10k_pfvtctl_rpl_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pfqde_t
 * Description: Implicit type of PF PF Queue Drop Enable Register register
 * Fields:
 *   qde	(size 1, offset 0, init 0):	RW	Enable drop of packets from Rx Queue queue_idx
 *   _anon1	(size 7, offset 1, init 0):	RSVD	_
 *   queue_idx	(size 7, offset 8, init 0):	RW	Queue index referenced
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   we	(size 1, offset 16, init 0):	RW	Write Enable
 *   re	(size 1, offset 17, init 0):	RW	Read Enable
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
typedef uint32_t e10k_pfqde_t;
#define e10k_pfqde_default 0x0
static inline uint8_t e10k_pfqde_qde_extract(e10k_pfqde_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfqde_qde_extract(e10k_pfqde_t _regval)
{
    return((uint8_t )((_regval & 0x1) >> 0));
}

static inline e10k_pfqde_t e10k_pfqde_qde_insert(e10k_pfqde_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfqde_t e10k_pfqde_qde_insert(e10k_pfqde_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffffffe) | (0x1 & (((e10k_pfqde_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_pfqde_queue_idx_extract(e10k_pfqde_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfqde_queue_idx_extract(e10k_pfqde_t _regval)
{
    return((uint8_t )((_regval & 0x7f00) >> 8));
}

static inline e10k_pfqde_t e10k_pfqde_queue_idx_insert(e10k_pfqde_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfqde_t e10k_pfqde_queue_idx_insert(e10k_pfqde_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xffff80ff) | (0x7f00 & (((e10k_pfqde_t )(_fieldval)) << 8)));
}

static inline uint8_t e10k_pfqde_we_extract(e10k_pfqde_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfqde_we_extract(e10k_pfqde_t _regval)
{
    return((uint8_t )((_regval & 0x10000) >> 16));
}

static inline e10k_pfqde_t e10k_pfqde_we_insert(e10k_pfqde_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfqde_t e10k_pfqde_we_insert(e10k_pfqde_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffeffff) | (0x10000 & (((e10k_pfqde_t )(_fieldval)) << 16)));
}

static inline uint8_t e10k_pfqde_re_extract(e10k_pfqde_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfqde_re_extract(e10k_pfqde_t _regval)
{
    return((uint8_t )((_regval & 0x20000) >> 17));
}

static inline e10k_pfqde_t e10k_pfqde_re_insert(e10k_pfqde_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfqde_t e10k_pfqde_re_insert(e10k_pfqde_t _regval, uint8_t _fieldval)
{
    return((_regval & 0xfffdffff) | (0x20000 & (((e10k_pfqde_t )(_fieldval)) << 17)));
}

static inline int e10k_pfqde_prtval(char *_s, size_t _size, e10k_pfqde_t _regval) __attribute__ ((always_inline));
static inline int e10k_pfqde_prtval(char *_s, size_t _size, e10k_pfqde_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " qde =\t%" PRIx8 "\t(Enable drop of packets from Rx Queue queue_idx)\n", e10k_pfqde_qde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_idx =\t%" PRIx8 "\t(Queue index referenced)\n", e10k_pfqde_queue_idx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " we =\t%" PRIx8 "\t(Write Enable)\n", e10k_pfqde_we_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " re =\t%" PRIx8 "\t(Read Enable)\n", e10k_pfqde_re_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pfvlvf_t
 * Description: Implicit type of PF VM VLAN Pool Filter register array
 * Fields:
 *   vlan_id	(size 12, offset 0, init 0):	NOATTR	VLAN tag for pool VLAN filter n
 *   _anon12	(size 19, offset 12, init 0):	RSVD	_
 *   vi_en	(size 1, offset 31, init 0):	NOATTR	VLAN Id Enable
 */
typedef uint32_t e10k_pfvlvf_t;
#define e10k_pfvlvf_default 0x0
static inline uint16_t e10k_pfvlvf_vlan_id_extract(e10k_pfvlvf_t _regval) __attribute__ ((always_inline));
static inline uint16_t e10k_pfvlvf_vlan_id_extract(e10k_pfvlvf_t _regval)
{
    return((uint16_t )((_regval & 0xfff) >> 0));
}

static inline e10k_pfvlvf_t e10k_pfvlvf_vlan_id_insert(e10k_pfvlvf_t _regval, uint16_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfvlvf_t e10k_pfvlvf_vlan_id_insert(e10k_pfvlvf_t _regval, uint16_t _fieldval)
{
    return((_regval & 0xfffff000) | (0xfff & (((e10k_pfvlvf_t )(_fieldval)) << 0)));
}

static inline uint8_t e10k_pfvlvf_vi_en_extract(e10k_pfvlvf_t _regval) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvlvf_vi_en_extract(e10k_pfvlvf_t _regval)
{
    return((uint8_t )((_regval & 0x80000000) >> 31));
}

static inline e10k_pfvlvf_t e10k_pfvlvf_vi_en_insert(e10k_pfvlvf_t _regval, uint8_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfvlvf_t e10k_pfvlvf_vi_en_insert(e10k_pfvlvf_t _regval, uint8_t _fieldval)
{
    return((_regval & 0x7fffffff) | (0x80000000 & (((e10k_pfvlvf_t )(_fieldval)) << 31)));
}

static inline int e10k_pfvlvf_prtval(char *_s, size_t _size, e10k_pfvlvf_t _regval) __attribute__ ((always_inline));
static inline int e10k_pfvlvf_prtval(char *_s, size_t _size, e10k_pfvlvf_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan_id =\t%" PRIx16 "\t(VLAN tag for pool VLAN filter n)\n", e10k_pfvlvf_vlan_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vi_en =\t%" PRIx8 "\t(VLAN Id Enable)\n", e10k_pfvlvf_vi_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pfvlvfb_t
 * Description: Implicit type of PF VM VLAN Pool Filter Bitmap register array
 * Fields:
 *   pool_ena	(size 32, offset 0, init 0):	NOATTR	Pool Enable Bit Array
 */
typedef uint32_t e10k_pfvlvfb_t;
#define e10k_pfvlvfb_default 0x0
static inline uint32_t e10k_pfvlvfb_pool_ena_extract(e10k_pfvlvfb_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_pfvlvfb_pool_ena_extract(e10k_pfvlvfb_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_pfvlvfb_t e10k_pfvlvfb_pool_ena_insert(e10k_pfvlvfb_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfvlvfb_t e10k_pfvlvfb_pool_ena_insert(e10k_pfvlvfb_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_pfvlvfb_t )(_fieldval)) << 0)));
}

static inline int e10k_pfvlvfb_prtval(char *_s, size_t _size, e10k_pfvlvfb_t _regval) __attribute__ ((always_inline));
static inline int e10k_pfvlvfb_prtval(char *_s, size_t _size, e10k_pfvlvfb_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool_ena =\t%" PRIx32 "\t(Pool Enable Bit Array)\n", e10k_pfvlvfb_pool_ena_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register type: e10k_pfuta_t
 * Description: Implicit type of PF Unicast Table Array register array
 * Fields:
 *   bitvec	(size 32, offset 0, init 0):	NOATTR	Bit Vector
 */
typedef uint32_t e10k_pfuta_t;
#define e10k_pfuta_default 0x0
static inline uint32_t e10k_pfuta_bitvec_extract(e10k_pfuta_t _regval) __attribute__ ((always_inline));
static inline uint32_t e10k_pfuta_bitvec_extract(e10k_pfuta_t _regval)
{
    return((uint32_t )((_regval & 0xffffffff) >> 0));
}

static inline e10k_pfuta_t e10k_pfuta_bitvec_insert(e10k_pfuta_t _regval, uint32_t _fieldval) __attribute__ ((always_inline));
static inline e10k_pfuta_t e10k_pfuta_bitvec_insert(e10k_pfuta_t _regval, uint32_t _fieldval)
{
    return((_regval & 0x0) | (0xffffffff & (((e10k_pfuta_t )(_fieldval)) << 0)));
}

static inline int e10k_pfuta_prtval(char *_s, size_t _size, e10k_pfuta_t _regval) __attribute__ ((always_inline));
static inline int e10k_pfuta_prtval(char *_s, size_t _size, e10k_pfuta_t _regval)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bitvec =\t%" PRIx32 "\t(Bit Vector)\n", e10k_pfuta_bitvec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Device representation structure
 */
struct __DN(t) {
    mackerel_addr_t base;
    e10k_eics_t eics_shadow;
    e10k_eimc_t eimc_shadow;
    e10k_eicsn_t eicsn_shadow[2];
    e10k_eimcn_t eimcn_shadow[2];
};
typedef struct __DN(t) __DN(t);

/*
 * Initial register values (currently 0)
 */
enum e10k_initials {
    e10k_ctrl_initial = 0x0,
    e10k_status_initial = 0x0,
    e10k_ctrl_ext_initial = 0x0,
    e10k_esdp_initial = 0x0,
    e10k_i2cctl_initial = 0x0,
    e10k_ledctl_initial = 0x0,
    e10k_exvet_initial = 0x0,
    e10k_eec_initial = 0x0,
    e10k_eerd_initial = 0x0,
    e10k_fla_initial = 0x0,
    e10k_eemngctl_initial = 0x0,
    e10k_eemngdata_initial = 0x0,
    e10k_flmngctl_initial = 0x0,
    e10k_flmngdata_initial = 0x0,
    e10k_flop_initial = 0x0,
    e10k_grc_initial = 0x0,
    e10k_pfctop_initial = 0x0,
    e10k_fcttv_initial = 0x0,
    e10k_fcrtl_initial = 0x0,
    e10k_fcrth_initial = 0x0,
    e10k_fcrtv_initial = 0x0,
    e10k_tfcs_initial = 0x0,
    e10k_fccfg_initial = 0x0,
    e10k_gcr_initial = 0x0,
    e10k_gscl_1_initial = 0x0,
    e10k_gscl_2_initial = 0x0,
    e10k_gscl5_8_initial = 0x0,
    e10k_gscn_initial = 0x0,
    e10k_factps_initial = 0x0,
    e10k_pciephyadr_initial = 0x0,
    e10k_pciephydat_initial = 0x0,
    e10k_swsm_initial = 0x0,
    e10k_fwsm_initial = 0x0,
    e10k_swfw_sync_initial = 0x0,
    e10k_gcr_ext_initial = 0x0,
    e10k_mrevid_initial = 0x0,
    e10k_picause_initial = 0x0,
    e10k_piena_initial = 0x0,
    e10k_eicr_initial = 0x0,
    e10k_eics_initial = 0x0,
    e10k_eims_initial = 0x0,
    e10k_eimc_initial = 0x0,
    e10k_eiac_initial = 0x0,
    e10k_eiam_initial = 0x0,
    e10k_eicsn_initial = 0x0,
    e10k_eimsn_initial = 0x0,
    e10k_eimcn_initial = 0x0,
    e10k_eiamn_initial = 0x0,
    e10k_eitrsel_initial = 0x0,
    e10k_eitr_l_initial = 0x0,
    e10k_eitr_h_initial = 0x0,
    e10k_l34timir_initial = 0x0,
    e10k_llithresh_initial = 0x0,
    e10k_imirvp_initial = 0x0,
    e10k_ivar_initial = 0x0,
    e10k_ivar_misc_initial = 0x0,
    e10k_gpie_initial = 0x0,
    e10k_pbacl_initial = 0x0,
    e10k_fctrl_initial = 0x0,
    e10k_vlnctrl_initial = 0x0,
    e10k_mcstctrl_initial = 0x0,
    e10k_psrtype_initial = 0x0,
    e10k_rxcsum_initial = 0x0,
    e10k_rfctl_initial = 0x0,
    e10k_mta_initial = 0x0,
    e10k_ral_initial = 0x0,
    e10k_rah_initial = 0x0,
    e10k_mpsar_initial = 0x0,
    e10k_vfta_initial = 0x0,
    e10k_mrqc_initial = 0x0,
    e10k_rqtc_initial = 0x0,
    e10k_rssrk_initial = 0x0,
    e10k_reta_initial = 0x0,
    e10k_saqf_initial = 0x0,
    e10k_daqf_initial = 0x0,
    e10k_sdpqf_initial = 0x0,
    e10k_ftqf_initial = 0x0,
    e10k_synqf_initial = 0x0,
    e10k_etqf_initial = 0x0,
    e10k_etqs_initial = 0x0,
    e10k_rxfeccerr0_initial = 0x0,
    e10k_rdbal_1_initial = 0x0,
    e10k_rdbal_2_initial = 0x0,
    e10k_rdbah_1_initial = 0x0,
    e10k_rdbah_2_initial = 0x0,
    e10k_rdlen_1_initial = 0x0,
    e10k_rdlen_2_initial = 0x0,
    e10k_rdh_1_initial = 0x0,
    e10k_rdh_2_initial = 0x0,
    e10k_rdt_1_initial = 0x0,
    e10k_rdt_2_initial = 0x0,
    e10k_rxdctl_1_initial = 0x0,
    e10k_rxdctl_2_initial = 0x0,
    e10k_srrctl_1_initial = 0x0,
    e10k_srrctl_2_initial = 0x0,
    e10k_rdrxctl_initial = 0x0,
    e10k_rxpbsize_initial = 0x0,
    e10k_rxctrl_initial = 0x0,
    e10k_rxmemwrap_initial = 0x0,
    e10k_rscdbu_initial = 0x0,
    e10k_rscctl_1_initial = 0x0,
    e10k_rscctl_2_initial = 0x0,
    e10k_dtxmxszrq_initial = 0x0,
    e10k_dmatxctl_initial = 0x0,
    e10k_dtxtcpflgl_initial = 0x0,
    e10k_dtxtcpflgh_initial = 0x0,
    e10k_tdbal_initial = 0x0,
    e10k_tdbah_initial = 0x0,
    e10k_tdlen_initial = 0x0,
    e10k_tdh_initial = 0x0,
    e10k_tdt_initial = 0x0,
    e10k_txdctl_initial = 0x0,
    e10k_tdwbal_initial = 0x0,
    e10k_tdwbah_initial = 0x0,
    e10k_txpbsize_initial = 0x0,
    e10k_mngtxmap_initial = 0x0,
    e10k_mtqc_initial = 0x0,
    e10k_txpbthresh_initial = 0x0,
    e10k_rtrpcs_initial = 0x0,
    e10k_rttdcs_initial = 0x0,
    e10k_rttpcs_initial = 0x0,
    e10k_rtrup2tc_initial = 0x0,
    e10k_rttup2tc_initial = 0x0,
    e10k_rtrpt4c_initial = 0x0,
    e10k_rttdt2c_initial = 0x0,
    e10k_rttpt2c_initial = 0x0,
    e10k_rttdqsel_initial = 0x0,
    e10k_rttdt1c_initial = 0x0,
    e10k_rttbcnrc_initial = 0x0,
    e10k_dca_rxctrl_1_initial = 0x0,
    e10k_dca_rxctrl_2_initial = 0x0,
    e10k_dca_txctrl_initial = 0x0,
    e10k_dca_id_initial = 0x0,
    e10k_dca_ctrl_initial = 0x0,
    e10k_secrxctrl_initial = 0x0,
    e10k_secrxstat_initial = 0x0,
    e10k_tcptimer_initial = 0x0,
    e10k_fdirctrl_initial = 0x0,
    e10k_fdirhkey_initial = 0x0,
    e10k_fdirskey_initial = 0x0,
    e10k_fdirdip4m_initial = 0x0,
    e10k_fdirsip4m_initial = 0x0,
    e10k_fdirtcpm_initial = 0x0,
    e10k_fdirudpm_initial = 0x0,
    e10k_fdirip6m_initial = 0x0,
    e10k_fdirm_initial = 0x0,
    e10k_fdirfree_initial = 0x0,
    e10k_fdirlen_initial = 0x0,
    e10k_fdirustat_initial = 0x0,
    e10k_fdirfstat_initial = 0x0,
    e10k_fdirmatch_initial = 0x0,
    e10k_fdirmiss_initial = 0x0,
    e10k_fdirsipv6_initial = 0x0,
    e10k_fdiripsa_initial = 0x0,
    e10k_fdiripda_initial = 0x0,
    e10k_fdirport_initial = 0x0,
    e10k_fdirvlan_initial = 0x0,
    e10k_fdirhash_initial = 0x0,
    e10k_fdircmd_initial = 0x0,
    e10k_pcs1gcfig_initial = 0x0,
    e10k_pcs1glctl_initial = 0x0,
    e10k_pcs1glsta_initial = 0x0,
    e10k_pcs1gana_initial = 0x0,
    e10k_pcs1ganlp_initial = 0x0,
    e10k_pcs1gannp_initial = 0x0,
    e10k_pcs1ganlpnp_initial = 0x0,
    e10k_hlreg0_initial = 0x0,
    e10k_hlreg1_initial = 0x0,
    e10k_pap_initial = 0x0,
    e10k_msca_initial = 0x0,
    e10k_msrwd_initial = 0x0,
    e10k_maxfrs_initial = 0x0,
    e10k_pcss1_initial = 0x0,
    e10k_pcss2_initial = 0x0,
    e10k_xpcss_initial = 0x0,
    e10k_serdesc_initial = 0x0,
    e10k_macs_initial = 0x0,
    e10k_autoc_initial = 0x0,
    e10k_links_initial = 0x0,
    e10k_links2_initial = 0x0,
    e10k_autoc2_initial = 0x0,
    e10k_anlp1_initial = 0x0,
    e10k_anlp2_initial = 0x0,
    e10k_mmngc_initial = 0x0,
    e10k_anlpnp1_initial = 0x0,
    e10k_anlpnp2_initial = 0x0,
    e10k_krpcsfc_initial = 0x0,
    e10k_krpcss_initial = 0x0,
    e10k_fecs1_initial = 0x0,
    e10k_fecs2_initial = 0x0,
    e10k_corectl_initial = 0x0,
    e10k_smadarctl_initial = 0x0,
    e10k_mflcn_initial = 0x0,
    e10k_sgmiic_initial = 0x0,
    e10k_crcerrs_initial = 0x0,
    e10k_illerrc_initial = 0x0,
    e10k_errbc_initial = 0x0,
    e10k_rxmpc_initial = 0x0,
    e10k_mlfc_initial = 0x0,
    e10k_mrfc_initial = 0x0,
    e10k_rlec_initial = 0x0,
    e10k_gprc_initial = 0x0,
    e10k_rxnfgpc_initial = 0x0,
    e10k_rxdgpc_initial = 0x0,
    e10k_gptc_initial = 0x0,
    e10k_txdgpc_initial = 0x0,
    e10k_ruc_initial = 0x0,
    e10k_rfc_initial = 0x0,
    e10k_roc_initial = 0x0,
    e10k_rjc_initial = 0x0,
    e10k_mngprc_initial = 0x0,
    e10k_mngpdc_initial = 0x0,
    e10k_tpr_initial = 0x0,
    e10k_tpt_initial = 0x0,
    e10k_mspdc_initial = 0x0,
    e10k_qprc_initial = 0x0,
    e10k_qprdc_initial = 0x0,
    e10k_fhft_1_initial = 0x0,
    e10k_fhft_2_initial = 0x0,
    e10k_mavtv_initial = 0x0,
    e10k_mfutp_initial = 0x0,
    e10k_metf_initial = 0x0,
    e10k_manc_initial = 0x0,
    e10k_mfval_initial = 0x0,
    e10k_manc2h_initial = 0x0,
    e10k_mdef_initial = 0x0,
    e10k_mdef_ext_initial = 0x0,
    e10k_pfvtctl_initial = 0x0,
    e10k_pfqde_initial = 0x0,
    e10k_pfvlvf_initial = 0x0,
    e10k_pfvlvfb_initial = 0x0,
    e10k_pfuta_initial = 0x0
};

/*
 * Device Initialization function
 */
static inline void e10k_initialize(__DN(t) *_dev, mackerel_addr_t base) __attribute__ ((always_inline));
static inline void e10k_initialize(__DN(t) *_dev, mackerel_addr_t base)
{
    _dev->base = base;
}

/*
 * Register ctrl: Device control
 * Type: e10k.ctrl (Implicit type of Device control register)
 *   _anon0	(size 2, offset 0, init 0):	MBZ	_
 *   pcie_md	(size 1, offset 2, init 0):	RW	PCIe Master Disable
 *   lrst	(size 1, offset 3, init 0):	RW	Link reset
 *   _anon4	(size 22, offset 4, init 0):	RSVD	_
 *   rst	(size 1, offset 26, init 0):	RW	Device reset
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static inline e10k_ctrl_t e10k_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ctrl_t e10k_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline e10k_ctrl_t e10k_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ctrl_t e10k_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x0));
}

static inline void e10k_ctrl_rawwr(__DN(t) *_dev, e10k_ctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_ctrl_rawwr(__DN(t) *_dev, e10k_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline void e10k_ctrl_wr(__DN(t) *_dev, e10k_ctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_ctrl_wr(__DN(t) *_dev, e10k_ctrl_t _regval)
{
    _regval = (_regval & 0x400000c);
    // No MB1 fields present
    _regval = (_regval | (0xfbfffff0 & mackerel_read_addr_32(_dev->base, 0x0)));
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
}

static inline int e10k_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrl (Device control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_md =\t%" PRIx8 "\t(PCIe Master Disable)\n", e10k_ctrl_pcie_md_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lrst =\t%" PRIx8 "\t(Link reset)\n", e10k_ctrl_lrst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rst =\t%" PRIx8 "\t(Device reset)\n", e10k_ctrl_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline uint8_t e10k_ctrl_pcie_md_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_pcie_md_rdf(__DN(t) *_dev)
{
    e10k_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e10k_ctrl_pcie_md_extract(_regval));
}

static inline uint8_t e10k_ctrl_lrst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_lrst_rdf(__DN(t) *_dev)
{
    e10k_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e10k_ctrl_lrst_extract(_regval));
}

static inline uint8_t e10k_ctrl_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_rst_rdf(__DN(t) *_dev)
{
    e10k_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x0);
    return(e10k_ctrl_rst_extract(_regval));
}

static inline void e10k_ctrl_pcie_md_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ctrl_pcie_md_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ctrl_t _regval = 0x4 & (((e10k_ctrl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e10k_ctrl_lrst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ctrl_lrst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ctrl_t _regval = 0x8 & (((e10k_ctrl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff4 & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

static inline void e10k_ctrl_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ctrl_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ctrl_t _regval = 0x4000000 & (((e10k_ctrl_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbfffffc & mackerel_read_addr_32(_dev->base, 0x0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffffc);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x0, _regval);
    // No shadow register to write to
}

/*
 * Register status: Device status
 * Type: e10k.status (Implicit type of Device status register)
 *   _anon0	(size 2, offset 0, init 0):	RSVD	_
 *   lan_id	(size 2, offset 2, init 0):	RO	LAN ID
 *   _anon4	(size 3, offset 4, init 0):	RSVD	_
 *   link_up	(size 1, offset 7, init 0):	RO	Linkup Status Indication
 *   _anon8	(size 2, offset 8, init 0):	RSVD	_
 *   num_vfs	(size 8, offset 10, init 0):	RO	Num VFs
 *   iov_active	(size 1, offset 18, init 0):	RO	IOV Active
 *   pcie_mes	(size 1, offset 19, init 0):	RO	PCIe Master Enable Status
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline e10k_status_t e10k_status_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_status_t e10k_status_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline e10k_status_t e10k_status_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_status_t e10k_status_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8));
}

static inline void e10k_status_rawwr(__DN(t) *_dev, e10k_status_t _regval) __attribute__ ((always_inline));
static inline void e10k_status_rawwr(__DN(t) *_dev, e10k_status_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8, _regval);
}

// Register status is not writeable
static inline int e10k_status_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_status_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register status (Device status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan_id =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_lanid_prtval(_s + _r, _avail, e10k_status_lan_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LAN ID)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " link_up =\t%" PRIx8 "\t(Linkup Status Indication)\n", e10k_status_link_up_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " num_vfs =\t%" PRIx8 "\t(Num VFs)\n", e10k_status_num_vfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " iov_active =\t%" PRIx8 "\t(IOV Active)\n", e10k_status_iov_active_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_mes =\t%" PRIx8 "\t(PCIe Master Enable Status)\n", e10k_status_pcie_mes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline e10k_lanid_t e10k_status_lan_id_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_lanid_t e10k_status_lan_id_rdf(__DN(t) *_dev)
{
    e10k_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_status_lan_id_extract(_regval));
}

static inline uint8_t e10k_status_link_up_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_status_link_up_rdf(__DN(t) *_dev)
{
    e10k_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_status_link_up_extract(_regval));
}

static inline uint8_t e10k_status_num_vfs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_status_num_vfs_rdf(__DN(t) *_dev)
{
    e10k_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_status_num_vfs_extract(_regval));
}

static inline uint8_t e10k_status_iov_active_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_status_iov_active_rdf(__DN(t) *_dev)
{
    e10k_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_status_iov_active_extract(_regval));
}

static inline uint8_t e10k_status_pcie_mes_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_status_pcie_mes_rdf(__DN(t) *_dev)
{
    e10k_status_t _regval = mackerel_read_addr_32(_dev->base, 0x8);
    return(e10k_status_pcie_mes_extract(_regval));
}

/*
 * Register ctrl_ext: Extended Device Control Register
 * Type: e10k.ctrl_ext (Implicit type of Extended Device Control Register register)
 *   _anon0	(size 14, offset 0, init 0):	RSVD	_
 *   pfrstd	(size 1, offset 14, init 0):	RW	PF Reset Done
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   ns_dis	(size 1, offset 16, init 0):	RW	NO Snoop Disable
 *   ro_dis	(size 1, offset 17, init 0):	RW	Relaxed Ordering Disable
 *   _anon18	(size 8, offset 18, init 0):	RSVD	_
 *   ext_vlan	(size 1, offset 26, init 0):	RW	Extended VLAN
 *   _anon27	(size 1, offset 27, init 0):	RSVD	_
 *   drv_load	(size 1, offset 28, init 0):	RW	Driver loaded 
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
static inline e10k_ctrl_ext_t e10k_ctrl_ext_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ctrl_ext_t e10k_ctrl_ext_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline e10k_ctrl_ext_t e10k_ctrl_ext_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ctrl_ext_t e10k_ctrl_ext_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x18));
}

static inline void e10k_ctrl_ext_rawwr(__DN(t) *_dev, e10k_ctrl_ext_t _regval) __attribute__ ((always_inline));
static inline void e10k_ctrl_ext_rawwr(__DN(t) *_dev, e10k_ctrl_ext_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline void e10k_ctrl_ext_wr(__DN(t) *_dev, e10k_ctrl_ext_t _regval) __attribute__ ((always_inline));
static inline void e10k_ctrl_ext_wr(__DN(t) *_dev, e10k_ctrl_ext_t _regval)
{
    _regval = (_regval & 0x14034000);
    // No MB1 fields present
    _regval = (_regval | (0xebfcbfff & mackerel_read_addr_32(_dev->base, 0x18)));
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
}

static inline int e10k_ctrl_ext_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_ctrl_ext_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_ctrl_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ctrl_ext (Extended Device Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pfrstd =\t%" PRIx8 "\t(PF Reset Done)\n", e10k_ctrl_ext_pfrstd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ns_dis =\t%" PRIx8 "\t(NO Snoop Disable)\n", e10k_ctrl_ext_ns_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ro_dis =\t%" PRIx8 "\t(Relaxed Ordering Disable)\n", e10k_ctrl_ext_ro_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ext_vlan =\t%" PRIx8 "\t(Extended VLAN)\n", e10k_ctrl_ext_ext_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drv_load =\t%" PRIx8 "\t(Driver loaded )\n", e10k_ctrl_ext_drv_load_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline uint8_t e10k_ctrl_ext_pfrstd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_pfrstd_rdf(__DN(t) *_dev)
{
    e10k_ctrl_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e10k_ctrl_ext_pfrstd_extract(_regval));
}

static inline uint8_t e10k_ctrl_ext_ns_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_ns_dis_rdf(__DN(t) *_dev)
{
    e10k_ctrl_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e10k_ctrl_ext_ns_dis_extract(_regval));
}

static inline uint8_t e10k_ctrl_ext_ro_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_ro_dis_rdf(__DN(t) *_dev)
{
    e10k_ctrl_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e10k_ctrl_ext_ro_dis_extract(_regval));
}

static inline uint8_t e10k_ctrl_ext_ext_vlan_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_ext_vlan_rdf(__DN(t) *_dev)
{
    e10k_ctrl_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e10k_ctrl_ext_ext_vlan_extract(_regval));
}

static inline uint8_t e10k_ctrl_ext_drv_load_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ctrl_ext_drv_load_rdf(__DN(t) *_dev)
{
    e10k_ctrl_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x18);
    return(e10k_ctrl_ext_drv_load_extract(_regval));
}

static inline void e10k_ctrl_ext_pfrstd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ctrl_ext_pfrstd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ctrl_ext_t _regval = 0x4000 & (((e10k_ctrl_ext_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e10k_ctrl_ext_ns_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ctrl_ext_ns_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ctrl_ext_t _regval = 0x10000 & (((e10k_ctrl_ext_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e10k_ctrl_ext_ro_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ctrl_ext_ro_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ctrl_ext_t _regval = 0x20000 & (((e10k_ctrl_ext_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e10k_ctrl_ext_ext_vlan_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ctrl_ext_ext_vlan_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ctrl_ext_t _regval = 0x4000000 & (((e10k_ctrl_ext_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

static inline void e10k_ctrl_ext_drv_load_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ctrl_ext_drv_load_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ctrl_ext_t _regval = 0x10000000 & (((e10k_ctrl_ext_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0x18)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x18, _regval);
    // No shadow register to write to
}

/*
 * Register esdp: Extended SDP Control
 * Type: e10k.esdp (Implicit type of Extended SDP Control register)
 *   sdp0_data	(size 1, offset 0, init 0):	RW	SDP0 Data Value
 *   sdp1_data	(size 1, offset 1, init 0):	RW	SDP1 Data Value
 *   sdp2_data	(size 1, offset 2, init 0):	RW	SDP2 Data Value
 *   sdp3_data	(size 1, offset 3, init 0):	RW	SDP3 Data Value
 *   sdp4_data	(size 1, offset 4, init 0):	RW	SDP4 Data Value
 *   sdp5_data	(size 1, offset 5, init 0):	RW	SDP5 Data Value
 *   sdp6_data	(size 1, offset 6, init 0):	RW	SDP6 Data Value
 *   sdp7_data	(size 1, offset 7, init 0):	RW	SDP7 Data Value
 *   sdp0_iodir	(size 1, offset 8, init 0):	RW	SDP0 Pin Directionality
 *   sdp1_iodir	(size 1, offset 9, init 0):	RW	SDP1 Pin Directionality
 *   sdp2_iodir	(size 1, offset 10, init 0):	RW	SDP2 Pin Directionality
 *   sdp3_iodir	(size 1, offset 11, init 0):	RW	SDP3 Pin Directionality
 *   sdp4_iodir	(size 1, offset 12, init 0):	RW	SDP4 Pin Directionality
 *   sdp5_iodir	(size 1, offset 13, init 0):	RW	SDP5 Pin Directionality
 *   sdp6_iodir	(size 1, offset 14, init 0):	RW	SDP6 Pin Directionality
 *   sdp7_iodir	(size 1, offset 15, init 0):	RW	SDP7 Pin Directionality
 *   sdp0_native	(size 1, offset 16, init 0):	RW	SDP0 Operating Mode
 *   sdp1_native	(size 1, offset 17, init 0):	RW	SDP1 Operating Mode
 *   sdp2_native	(size 1, offset 18, init 0):	RW	SDP2 Operating Mode
 *   sdp3_native	(size 1, offset 19, init 0):	RW	SDP3 Operating Mode
 *   sdp4_native	(size 1, offset 20, init 0):	RW	SDP4 Operating Mode
 *   sdp5_native	(size 1, offset 21, init 0):	RW	SDP5 Operating Mode
 *   sdp6_native	(size 1, offset 22, init 0):	RW	SDP6 Operating Mode
 *   sdp7_native	(size 1, offset 23, init 0):	RW	SDP7 Operating Mode
 *   _anon24	(size 2, offset 24, init 0):	RSVD	_
 *   sdp2_ts_tt1	(size 1, offset 26, init 0):	RW	SDP2 Native Mode Functionality
 *   sdp3_ts_tt0	(size 1, offset 27, init 0):	RW	SDP3 Native Mode Functionality
 *   sdp4_func	(size 1, offset 28, init 0):	RW	SDP4 Native Mode Functionality
 *   sdp5_func	(size 1, offset 29, init 0):	RW	SDP5 Native Mode Functionality
 *   sdp6_ts_tt1	(size 1, offset 30, init 0):	RW	SDP6 Native Mode Functionality
 *   sdp7_ts_tt0	(size 1, offset 31, init 0):	RW	SDP7 Native Mode Functionality
 */
static inline e10k_esdp_t e10k_esdp_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline e10k_esdp_t e10k_esdp_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_esdp_t e10k_esdp_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x20));
}

static inline void e10k_esdp_rawwr(__DN(t) *_dev, e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline void e10k_esdp_rawwr(__DN(t) *_dev, e10k_esdp_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline void e10k_esdp_wr(__DN(t) *_dev, e10k_esdp_t _regval) __attribute__ ((always_inline));
static inline void e10k_esdp_wr(__DN(t) *_dev, e10k_esdp_t _regval)
{
    _regval = (_regval & 0xfcffffff);
    // No MB1 fields present
    _regval = (_regval | (0x3000000 & mackerel_read_addr_32(_dev->base, 0x20)));
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
}

static inline int e10k_esdp_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_esdp_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register esdp (Extended SDP Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_data =\t%" PRIx8 "\t(SDP0 Data Value)\n", e10k_esdp_sdp0_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_data =\t%" PRIx8 "\t(SDP1 Data Value)\n", e10k_esdp_sdp1_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_data =\t%" PRIx8 "\t(SDP2 Data Value)\n", e10k_esdp_sdp2_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_data =\t%" PRIx8 "\t(SDP3 Data Value)\n", e10k_esdp_sdp3_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp4_data =\t%" PRIx8 "\t(SDP4 Data Value)\n", e10k_esdp_sdp4_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp5_data =\t%" PRIx8 "\t(SDP5 Data Value)\n", e10k_esdp_sdp5_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp6_data =\t%" PRIx8 "\t(SDP6 Data Value)\n", e10k_esdp_sdp6_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp7_data =\t%" PRIx8 "\t(SDP7 Data Value)\n", e10k_esdp_sdp7_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_iodir =\t%" PRIx8 "\t(SDP0 Pin Directionality)\n", e10k_esdp_sdp0_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_iodir =\t%" PRIx8 "\t(SDP1 Pin Directionality)\n", e10k_esdp_sdp1_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_iodir =\t%" PRIx8 "\t(SDP2 Pin Directionality)\n", e10k_esdp_sdp2_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_iodir =\t%" PRIx8 "\t(SDP3 Pin Directionality)\n", e10k_esdp_sdp3_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp4_iodir =\t%" PRIx8 "\t(SDP4 Pin Directionality)\n", e10k_esdp_sdp4_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp5_iodir =\t%" PRIx8 "\t(SDP5 Pin Directionality)\n", e10k_esdp_sdp5_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp6_iodir =\t%" PRIx8 "\t(SDP6 Pin Directionality)\n", e10k_esdp_sdp6_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp7_iodir =\t%" PRIx8 "\t(SDP7 Pin Directionality)\n", e10k_esdp_sdp7_iodir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp0_native =\t%" PRIx8 "\t(SDP0 Operating Mode)\n", e10k_esdp_sdp0_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp1_native =\t%" PRIx8 "\t(SDP1 Operating Mode)\n", e10k_esdp_sdp1_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_native =\t%" PRIx8 "\t(SDP2 Operating Mode)\n", e10k_esdp_sdp2_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_native =\t%" PRIx8 "\t(SDP3 Operating Mode)\n", e10k_esdp_sdp3_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp4_native =\t%" PRIx8 "\t(SDP4 Operating Mode)\n", e10k_esdp_sdp4_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp5_native =\t%" PRIx8 "\t(SDP5 Operating Mode)\n", e10k_esdp_sdp5_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp6_native =\t%" PRIx8 "\t(SDP6 Operating Mode)\n", e10k_esdp_sdp6_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp7_native =\t%" PRIx8 "\t(SDP7 Operating Mode)\n", e10k_esdp_sdp7_native_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp2_ts_tt1 =\t%" PRIx8 "\t(SDP2 Native Mode Functionality)\n", e10k_esdp_sdp2_ts_tt1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp3_ts_tt0 =\t%" PRIx8 "\t(SDP3 Native Mode Functionality)\n", e10k_esdp_sdp3_ts_tt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp4_func =\t%" PRIx8 "\t(SDP4 Native Mode Functionality)\n", e10k_esdp_sdp4_func_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp5_func =\t%" PRIx8 "\t(SDP5 Native Mode Functionality)\n", e10k_esdp_sdp5_func_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp6_ts_tt1 =\t%" PRIx8 "\t(SDP6 Native Mode Functionality)\n", e10k_esdp_sdp6_ts_tt1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdp7_ts_tt0 =\t%" PRIx8 "\t(SDP7 Native Mode Functionality)\n", e10k_esdp_sdp7_ts_tt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_esdp_sdp0_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp0_data_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp0_data_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp1_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp1_data_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp1_data_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp2_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp2_data_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp2_data_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp3_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp3_data_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp3_data_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp4_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp4_data_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp4_data_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp5_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp5_data_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp5_data_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp6_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp6_data_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp6_data_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp7_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp7_data_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp7_data_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp0_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp0_iodir_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp0_iodir_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp1_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp1_iodir_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp1_iodir_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp2_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp2_iodir_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp2_iodir_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp3_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp3_iodir_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp3_iodir_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp4_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp4_iodir_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp4_iodir_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp5_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp5_iodir_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp5_iodir_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp6_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp6_iodir_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp6_iodir_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp7_iodir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp7_iodir_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp7_iodir_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp0_native_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp0_native_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp0_native_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp1_native_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp1_native_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp1_native_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp2_native_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp2_native_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp2_native_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp3_native_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp3_native_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp3_native_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp4_native_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp4_native_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp4_native_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp5_native_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp5_native_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp5_native_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp6_native_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp6_native_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp6_native_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp7_native_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp7_native_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp7_native_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp2_ts_tt1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp2_ts_tt1_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp2_ts_tt1_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp3_ts_tt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp3_ts_tt0_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp3_ts_tt0_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp4_func_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp4_func_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp4_func_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp5_func_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp5_func_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp5_func_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp6_ts_tt1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp6_ts_tt1_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp6_ts_tt1_extract(_regval));
}

static inline uint8_t e10k_esdp_sdp7_ts_tt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_esdp_sdp7_ts_tt0_rdf(__DN(t) *_dev)
{
    e10k_esdp_t _regval = mackerel_read_addr_32(_dev->base, 0x20);
    return(e10k_esdp_sdp7_ts_tt0_extract(_regval));
}

static inline void e10k_esdp_sdp0_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp0_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x1 & (((e10k_esdp_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp1_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp1_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x2 & (((e10k_esdp_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp2_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp2_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x4 & (((e10k_esdp_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp3_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp3_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x8 & (((e10k_esdp_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp4_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp4_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x10 & (((e10k_esdp_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp5_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp5_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x20 & (((e10k_esdp_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp6_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp6_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x40 & (((e10k_esdp_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp7_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp7_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x80 & (((e10k_esdp_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp0_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp0_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x100 & (((e10k_esdp_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp1_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp1_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x200 & (((e10k_esdp_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp2_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp2_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x400 & (((e10k_esdp_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp3_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp3_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x800 & (((e10k_esdp_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp4_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp4_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x1000 & (((e10k_esdp_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp5_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp5_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x2000 & (((e10k_esdp_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp6_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp6_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x4000 & (((e10k_esdp_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp7_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp7_iodir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x8000 & (((e10k_esdp_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp0_native_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp0_native_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x10000 & (((e10k_esdp_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp1_native_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp1_native_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x20000 & (((e10k_esdp_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp2_native_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp2_native_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x40000 & (((e10k_esdp_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffbffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp3_native_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp3_native_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x80000 & (((e10k_esdp_t )(_fieldval)) << 19);
    _regval = (_regval | (0xfff7ffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp4_native_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp4_native_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x100000 & (((e10k_esdp_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffefffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp5_native_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp5_native_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x200000 & (((e10k_esdp_t )(_fieldval)) << 21);
    _regval = (_regval | (0xffdfffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp6_native_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp6_native_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x400000 & (((e10k_esdp_t )(_fieldval)) << 22);
    _regval = (_regval | (0xffbfffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp7_native_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp7_native_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x800000 & (((e10k_esdp_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp2_ts_tt1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp2_ts_tt1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x4000000 & (((e10k_esdp_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp3_ts_tt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp3_ts_tt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x8000000 & (((e10k_esdp_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7ffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp4_func_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp4_func_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x10000000 & (((e10k_esdp_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp5_func_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp5_func_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x20000000 & (((e10k_esdp_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp6_ts_tt1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp6_ts_tt1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x40000000 & (((e10k_esdp_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

static inline void e10k_esdp_sdp7_ts_tt0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_esdp_sdp7_ts_tt0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_esdp_t _regval = 0x80000000 & (((e10k_esdp_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x20, _regval);
    // No shadow register to write to
}

/*
 * Register i2cctl: I2C Control
 * Type: e10k.i2cctl (Implicit type of I2C Control register)
 *   i2c_clkin	(size 1, offset 0, init 0):	RW	I2C_CLK In Value
 *   i2c_clkout	(size 1, offset 1, init 0):	RW	I2C_CLK Out Value
 *   i2c_datain	(size 1, offset 2, init 0):	RW	I2C_DATA In Value
 *   i2c_dataout	(size 1, offset 3, init 0):	RW	I2C_DATA Out Value
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static inline e10k_i2cctl_t e10k_i2cctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_i2cctl_t e10k_i2cctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline e10k_i2cctl_t e10k_i2cctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_i2cctl_t e10k_i2cctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x28));
}

static inline void e10k_i2cctl_rawwr(__DN(t) *_dev, e10k_i2cctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_i2cctl_rawwr(__DN(t) *_dev, e10k_i2cctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline void e10k_i2cctl_wr(__DN(t) *_dev, e10k_i2cctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_i2cctl_wr(__DN(t) *_dev, e10k_i2cctl_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x28)));
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
}

static inline int e10k_i2cctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_i2cctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_i2cctl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register i2cctl (I2C Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i2c_clkin =\t%" PRIx8 "\t(I2C_CLK In Value)\n", e10k_i2cctl_i2c_clkin_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i2c_clkout =\t%" PRIx8 "\t(I2C_CLK Out Value)\n", e10k_i2cctl_i2c_clkout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i2c_datain =\t%" PRIx8 "\t(I2C_DATA In Value)\n", e10k_i2cctl_i2c_datain_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i2c_dataout =\t%" PRIx8 "\t(I2C_DATA Out Value)\n", e10k_i2cctl_i2c_dataout_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t e10k_i2cctl_i2c_clkin_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_i2cctl_i2c_clkin_rdf(__DN(t) *_dev)
{
    e10k_i2cctl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(e10k_i2cctl_i2c_clkin_extract(_regval));
}

static inline uint8_t e10k_i2cctl_i2c_clkout_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_i2cctl_i2c_clkout_rdf(__DN(t) *_dev)
{
    e10k_i2cctl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(e10k_i2cctl_i2c_clkout_extract(_regval));
}

static inline uint8_t e10k_i2cctl_i2c_datain_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_i2cctl_i2c_datain_rdf(__DN(t) *_dev)
{
    e10k_i2cctl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(e10k_i2cctl_i2c_datain_extract(_regval));
}

static inline uint8_t e10k_i2cctl_i2c_dataout_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_i2cctl_i2c_dataout_rdf(__DN(t) *_dev)
{
    e10k_i2cctl_t _regval = mackerel_read_addr_32(_dev->base, 0x28);
    return(e10k_i2cctl_i2c_dataout_extract(_regval));
}

static inline void e10k_i2cctl_i2c_clkin_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_i2cctl_i2c_clkin_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_i2cctl_t _regval = 0x1 & (((e10k_i2cctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void e10k_i2cctl_i2c_clkout_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_i2cctl_i2c_clkout_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_i2cctl_t _regval = 0x2 & (((e10k_i2cctl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void e10k_i2cctl_i2c_datain_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_i2cctl_i2c_datain_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_i2cctl_t _regval = 0x4 & (((e10k_i2cctl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

static inline void e10k_i2cctl_i2c_dataout_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_i2cctl_i2c_dataout_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_i2cctl_t _regval = 0x8 & (((e10k_i2cctl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x28, _regval);
    // No shadow register to write to
}

/*
 * Register ledctl: LED Control
 * Type: e10k.ledctl (Implicit type of LED Control register)
 *   led0_mode	(size 4, offset 0, init 0):	RW	LED0 Mode
 *   _anon4	(size 1, offset 4, init 0):	RSVD	_
 *   glob_blmode	(size 1, offset 5, init 0):	RW	GLOBAL blink mode
 *   led0_ivrt	(size 1, offset 6, init 0):	RW	LED0 Invert
 *   led0_blink	(size 1, offset 7, init 0):	RW	LED0 Blink
 *   led1_mode	(size 4, offset 8, init 0):	RW	LED1 Mode
 *   _anon12	(size 2, offset 12, init 0):	RSVD	_
 *   led1_ivrt	(size 1, offset 14, init 0):	RW	LED1 Invert
 *   led1_blink	(size 1, offset 15, init 0):	RW	LED1 Blink
 *   led2_mode	(size 4, offset 16, init 0):	RW	LED2 Mode
 *   _anon20	(size 2, offset 20, init 0):	RSVD	_
 *   led2_ivrt	(size 1, offset 22, init 0):	RW	LED2 Invert
 *   led2_blink	(size 1, offset 23, init 0):	RW	LED2 Blink
 *   led3_mode	(size 4, offset 24, init 0):	RW	LED3 Mode
 *   _anon28	(size 2, offset 28, init 0):	RSVD	_
 *   led3_ivrt	(size 1, offset 30, init 0):	RW	LED3 Invert
 *   led3_blink	(size 1, offset 31, init 0):	RW	LED3 Blink
 */
static inline e10k_ledctl_t e10k_ledctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x200));
}

static inline e10k_ledctl_t e10k_ledctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ledctl_t e10k_ledctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x200));
}

static inline void e10k_ledctl_rawwr(__DN(t) *_dev, e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_ledctl_rawwr(__DN(t) *_dev, e10k_ledctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
}

static inline void e10k_ledctl_wr(__DN(t) *_dev, e10k_ledctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_ledctl_wr(__DN(t) *_dev, e10k_ledctl_t _regval)
{
    _regval = (_regval & 0xcfcfcfef);
    // No MB1 fields present
    _regval = (_regval | (0x30303010 & mackerel_read_addr_32(_dev->base, 0x200)));
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
}

static inline int e10k_ledctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_ledctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ledctl (LED Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledmode_prtval(_s + _r, _avail, e10k_ledctl_led0_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED0 Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " glob_blmode =\t%" PRIx8 "\t(GLOBAL blink mode)\n", e10k_ledctl_glob_blmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_ivrt =\t%" PRIx8 "\t(LED0 Invert)\n", e10k_ledctl_led0_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led0_blink =\t%" PRIx8 "\t(LED0 Blink)\n", e10k_ledctl_led0_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledmode_prtval(_s + _r, _avail, e10k_ledctl_led1_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED1 Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_ivrt =\t%" PRIx8 "\t(LED1 Invert)\n", e10k_ledctl_led1_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led1_blink =\t%" PRIx8 "\t(LED1 Blink)\n", e10k_ledctl_led1_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledmode_prtval(_s + _r, _avail, e10k_ledctl_led2_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED2 Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_ivrt =\t%" PRIx8 "\t(LED2 Invert)\n", e10k_ledctl_led2_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led2_blink =\t%" PRIx8 "\t(LED2 Blink)\n", e10k_ledctl_led2_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledmode_prtval(_s + _r, _avail, e10k_ledctl_led3_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LED3 Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_ivrt =\t%" PRIx8 "\t(LED3 Invert)\n", e10k_ledctl_led3_ivrt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " led3_blink =\t%" PRIx8 "\t(LED3 Blink)\n", e10k_ledctl_led3_blink_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline e10k_ledmode_t e10k_ledctl_led0_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ledmode_t e10k_ledctl_led0_mode_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led0_mode_extract(_regval));
}

static inline uint8_t e10k_ledctl_glob_blmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_glob_blmode_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_glob_blmode_extract(_regval));
}

static inline uint8_t e10k_ledctl_led0_ivrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led0_ivrt_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led0_ivrt_extract(_regval));
}

static inline uint8_t e10k_ledctl_led0_blink_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led0_blink_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led0_blink_extract(_regval));
}

static inline e10k_ledmode_t e10k_ledctl_led1_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ledmode_t e10k_ledctl_led1_mode_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led1_mode_extract(_regval));
}

static inline uint8_t e10k_ledctl_led1_ivrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led1_ivrt_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led1_ivrt_extract(_regval));
}

static inline uint8_t e10k_ledctl_led1_blink_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led1_blink_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led1_blink_extract(_regval));
}

static inline e10k_ledmode_t e10k_ledctl_led2_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ledmode_t e10k_ledctl_led2_mode_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led2_mode_extract(_regval));
}

static inline uint8_t e10k_ledctl_led2_ivrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led2_ivrt_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led2_ivrt_extract(_regval));
}

static inline uint8_t e10k_ledctl_led2_blink_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led2_blink_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led2_blink_extract(_regval));
}

static inline e10k_ledmode_t e10k_ledctl_led3_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ledmode_t e10k_ledctl_led3_mode_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led3_mode_extract(_regval));
}

static inline uint8_t e10k_ledctl_led3_ivrt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led3_ivrt_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led3_ivrt_extract(_regval));
}

static inline uint8_t e10k_ledctl_led3_blink_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ledctl_led3_blink_rdf(__DN(t) *_dev)
{
    e10k_ledctl_t _regval = mackerel_read_addr_32(_dev->base, 0x200);
    return(e10k_ledctl_led3_blink_extract(_regval));
}

static inline void e10k_ledctl_led0_mode_wrf(__DN(t) *_dev, e10k_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led0_mode_wrf(__DN(t) *_dev, e10k_ledmode_t _fieldval)
{
    e10k_ledctl_t _regval = 0xf & (((e10k_ledctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_glob_blmode_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_glob_blmode_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x20 & (((e10k_ledctl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led0_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led0_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x40 & (((e10k_ledctl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led0_blink_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led0_blink_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x80 & (((e10k_ledctl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led1_mode_wrf(__DN(t) *_dev, e10k_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led1_mode_wrf(__DN(t) *_dev, e10k_ledmode_t _fieldval)
{
    e10k_ledctl_t _regval = 0xf00 & (((e10k_ledctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff0ff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led1_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led1_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x4000 & (((e10k_ledctl_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led1_blink_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led1_blink_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x8000 & (((e10k_ledctl_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led2_mode_wrf(__DN(t) *_dev, e10k_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led2_mode_wrf(__DN(t) *_dev, e10k_ledmode_t _fieldval)
{
    e10k_ledctl_t _regval = 0xf0000 & (((e10k_ledctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led2_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led2_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x400000 & (((e10k_ledctl_t )(_fieldval)) << 22);
    _regval = (_regval | (0xffbfffff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led2_blink_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led2_blink_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x800000 & (((e10k_ledctl_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led3_mode_wrf(__DN(t) *_dev, e10k_ledmode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led3_mode_wrf(__DN(t) *_dev, e10k_ledmode_t _fieldval)
{
    e10k_ledctl_t _regval = 0xf000000 & (((e10k_ledctl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf0ffffff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led3_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led3_ivrt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x40000000 & (((e10k_ledctl_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

static inline void e10k_ledctl_led3_blink_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ledctl_led3_blink_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ledctl_t _regval = 0x80000000 & (((e10k_ledctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x200, _regval);
    // No shadow register to write to
}

/*
 * Register exvet: Extended VLAN Ether Type 
 * Type: e10k.exvet (Implicit type of Extended VLAN Ether Type  register)
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   vet_ext	(size 16, offset 16, init 0):	RW	Outer-VLAN Ether Type
 */
static inline e10k_exvet_t e10k_exvet_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_exvet_t e10k_exvet_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5078));
}

static inline e10k_exvet_t e10k_exvet_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_exvet_t e10k_exvet_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5078));
}

static inline void e10k_exvet_rawwr(__DN(t) *_dev, e10k_exvet_t _regval) __attribute__ ((always_inline));
static inline void e10k_exvet_rawwr(__DN(t) *_dev, e10k_exvet_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5078, _regval);
}

static inline void e10k_exvet_wr(__DN(t) *_dev, e10k_exvet_t _regval) __attribute__ ((always_inline));
static inline void e10k_exvet_wr(__DN(t) *_dev, e10k_exvet_t _regval)
{
    _regval = (_regval & 0xffff0000);
    // No MB1 fields present
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x5078)));
    mackerel_write_addr_32(_dev->base, 0x5078, _regval);
}

static inline int e10k_exvet_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_exvet_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_exvet_t _regval = mackerel_read_addr_32(_dev->base, 0x5078);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register exvet (Extended VLAN Ether Type ): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vet_ext =\t%" PRIx16 "\t(Outer-VLAN Ether Type)\n", e10k_exvet_vet_ext_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_exvet_vet_ext_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_exvet_vet_ext_rdf(__DN(t) *_dev)
{
    e10k_exvet_t _regval = mackerel_read_addr_32(_dev->base, 0x5078);
    return(e10k_exvet_vet_ext_extract(_regval));
}

static inline void e10k_exvet_vet_ext_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_exvet_vet_ext_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_exvet_t _regval = 0xffff0000 & (((e10k_exvet_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x5078)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5078, _regval);
    // No shadow register to write to
}

/*
 * Register eec: EEPROM/Flash Control Register
 * Type: e10k.eec (Implicit type of EEPROM/Flash Control Register register)
 *   ee_sk	(size 1, offset 0, init 0):	RW	Clock input to the EEPROM
 *   ee_cs	(size 1, offset 1, init 0):	RW	Chip select input to the EEPROM
 *   ee_di	(size 1, offset 2, init 0):	RW	Data input to the EEPROM
 *   ee_do	(size 1, offset 3, init 0):	RO	Data output bit from the EEPROM
 *   fwe	(size 2, offset 4, init 0):	RW	Flash Write Enable Control
 *   ee_req	(size 1, offset 6, init 0):	RW	Request EEPROM Access
 *   ee_gnt	(size 1, offset 7, init 0):	RO	Grant EEPROM Access
 *   ee_pres	(size 1, offset 8, init 0):	RO	EEPROM Present
 *   auto_rd	(size 1, offset 9, init 0):	RO	EEPROM Auto-Read Done
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   ee_size	(size 4, offset 11, init 0):	RO	EEPROM Size
 *   pci_anadon	(size 1, offset 15, init 0):	RO	PCIe Analog Done
 *   pci_cordon	(size 1, offset 16, init 0):	RO	PCIe Core Done
 *   pci_gendon	(size 1, offset 17, init 0):	RO	PCIe General Done
 *   pci_fundon	(size 1, offset 18, init 0):	RO	PCIe Function Done
 *   core_done	(size 1, offset 19, init 0):	RO	Core Done
 *   core_csrdon	(size 1, offset 20, init 0):	RO	Core CSR Done
 *   mac_done	(size 1, offset 21, init 0):	RO	MAC Done
 *   _anon22	(size 10, offset 22, init 0):	RSVD	_
 */
static inline e10k_eec_t e10k_eec_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10010));
}

static inline e10k_eec_t e10k_eec_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eec_t e10k_eec_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10010));
}

static inline void e10k_eec_rawwr(__DN(t) *_dev, e10k_eec_t _regval) __attribute__ ((always_inline));
static inline void e10k_eec_rawwr(__DN(t) *_dev, e10k_eec_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10010, _regval);
}

static inline void e10k_eec_wr(__DN(t) *_dev, e10k_eec_t _regval) __attribute__ ((always_inline));
static inline void e10k_eec_wr(__DN(t) *_dev, e10k_eec_t _regval)
{
    _regval = (_regval & 0x3ffbff);
    // No MB1 fields present
    _regval = (_regval | (0xffc00400 & mackerel_read_addr_32(_dev->base, 0x10010)));
    mackerel_write_addr_32(_dev->base, 0x10010, _regval);
}

static inline int e10k_eec_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eec_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eec (EEPROM/Flash Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_sk =\t%" PRIx8 "\t(Clock input to the EEPROM)\n", e10k_eec_ee_sk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_cs =\t%" PRIx8 "\t(Chip select input to the EEPROM)\n", e10k_eec_ee_cs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_di =\t%" PRIx8 "\t(Data input to the EEPROM)\n", e10k_eec_ee_di_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_do =\t%" PRIx8 "\t(Data output bit from the EEPROM)\n", e10k_eec_ee_do_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fwe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fwe_control_prtval(_s + _r, _avail, e10k_eec_fwe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Flash Write Enable Control)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_req =\t%" PRIx8 "\t(Request EEPROM Access)\n", e10k_eec_ee_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_gnt =\t%" PRIx8 "\t(Grant EEPROM Access)\n", e10k_eec_ee_gnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_pres =\t%" PRIx8 "\t(EEPROM Present)\n", e10k_eec_ee_pres_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " auto_rd =\t%" PRIx8 "\t(EEPROM Auto-Read Done)\n", e10k_eec_auto_rd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ee_size =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eeprom_size_prtval(_s + _r, _avail, e10k_eec_ee_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(EEPROM Size)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_anadon =\t%" PRIx8 "\t(PCIe Analog Done)\n", e10k_eec_pci_anadon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_cordon =\t%" PRIx8 "\t(PCIe Core Done)\n", e10k_eec_pci_cordon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_gendon =\t%" PRIx8 "\t(PCIe General Done)\n", e10k_eec_pci_gendon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_fundon =\t%" PRIx8 "\t(PCIe Function Done)\n", e10k_eec_pci_fundon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " core_done =\t%" PRIx8 "\t(Core Done)\n", e10k_eec_core_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " core_csrdon =\t%" PRIx8 "\t(Core CSR Done)\n", e10k_eec_core_csrdon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mac_done =\t%" PRIx8 "\t(MAC Done)\n", e10k_eec_mac_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    return(_r);
}

static inline uint8_t e10k_eec_ee_sk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_sk_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_ee_sk_extract(_regval));
}

static inline uint8_t e10k_eec_ee_cs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_cs_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_ee_cs_extract(_regval));
}

static inline uint8_t e10k_eec_ee_di_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_di_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_ee_di_extract(_regval));
}

static inline uint8_t e10k_eec_ee_do_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_do_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_ee_do_extract(_regval));
}

static inline e10k_fwe_control_t e10k_eec_fwe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fwe_control_t e10k_eec_fwe_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_fwe_extract(_regval));
}

static inline uint8_t e10k_eec_ee_req_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_req_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_ee_req_extract(_regval));
}

static inline uint8_t e10k_eec_ee_gnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_gnt_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_ee_gnt_extract(_regval));
}

static inline uint8_t e10k_eec_ee_pres_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_ee_pres_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_ee_pres_extract(_regval));
}

static inline uint8_t e10k_eec_auto_rd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_auto_rd_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_auto_rd_extract(_regval));
}

static inline e10k_eeprom_size_t e10k_eec_ee_size_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eeprom_size_t e10k_eec_ee_size_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_ee_size_extract(_regval));
}

static inline uint8_t e10k_eec_pci_anadon_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_pci_anadon_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_pci_anadon_extract(_regval));
}

static inline uint8_t e10k_eec_pci_cordon_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_pci_cordon_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_pci_cordon_extract(_regval));
}

static inline uint8_t e10k_eec_pci_gendon_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_pci_gendon_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_pci_gendon_extract(_regval));
}

static inline uint8_t e10k_eec_pci_fundon_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_pci_fundon_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_pci_fundon_extract(_regval));
}

static inline uint8_t e10k_eec_core_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_core_done_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_core_done_extract(_regval));
}

static inline uint8_t e10k_eec_core_csrdon_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_core_csrdon_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_core_csrdon_extract(_regval));
}

static inline uint8_t e10k_eec_mac_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eec_mac_done_rdf(__DN(t) *_dev)
{
    e10k_eec_t _regval = mackerel_read_addr_32(_dev->base, 0x10010);
    return(e10k_eec_mac_done_extract(_regval));
}

static inline void e10k_eec_ee_sk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eec_ee_sk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eec_t _regval = 0x1 & (((e10k_eec_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffc00476 & mackerel_read_addr_32(_dev->base, 0x10010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10010, _regval);
    // No shadow register to write to
}

static inline void e10k_eec_ee_cs_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eec_ee_cs_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eec_t _regval = 0x2 & (((e10k_eec_t )(_fieldval)) << 1);
    _regval = (_regval | (0xffc00475 & mackerel_read_addr_32(_dev->base, 0x10010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10010, _regval);
    // No shadow register to write to
}

static inline void e10k_eec_ee_di_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eec_ee_di_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eec_t _regval = 0x4 & (((e10k_eec_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffc00473 & mackerel_read_addr_32(_dev->base, 0x10010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10010, _regval);
    // No shadow register to write to
}

static inline void e10k_eec_fwe_wrf(__DN(t) *_dev, e10k_fwe_control_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eec_fwe_wrf(__DN(t) *_dev, e10k_fwe_control_t _fieldval)
{
    e10k_eec_t _regval = 0x30 & (((e10k_eec_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffc00447 & mackerel_read_addr_32(_dev->base, 0x10010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10010, _regval);
    // No shadow register to write to
}

static inline void e10k_eec_ee_req_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eec_ee_req_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eec_t _regval = 0x40 & (((e10k_eec_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffc00437 & mackerel_read_addr_32(_dev->base, 0x10010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10010, _regval);
    // No shadow register to write to
}

/*
 * Register eerd: EEPROM Read Register
 * Type: e10k.eerd (Implicit type of EEPROM Read Register register)
 *   start	(size 1, offset 0, init 0):	RW	Start Read
 *   done	(size 1, offset 1, init 0):	RW	Read Done
 *   addr	(size 14, offset 2, init 0):	RW	Read Address
 *   data	(size 16, offset 16, init 0):	RW	Read Data
 */
static inline e10k_eerd_t e10k_eerd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eerd_t e10k_eerd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10014));
}

static inline e10k_eerd_t e10k_eerd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eerd_t e10k_eerd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10014));
}

static inline void e10k_eerd_rawwr(__DN(t) *_dev, e10k_eerd_t _regval) __attribute__ ((always_inline));
static inline void e10k_eerd_rawwr(__DN(t) *_dev, e10k_eerd_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10014, _regval);
}

static inline void e10k_eerd_wr(__DN(t) *_dev, e10k_eerd_t _regval) __attribute__ ((always_inline));
static inline void e10k_eerd_wr(__DN(t) *_dev, e10k_eerd_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10014, _regval);
}

static inline int e10k_eerd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eerd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eerd_t _regval = mackerel_read_addr_32(_dev->base, 0x10014);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eerd (EEPROM Read Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start Read)\n", e10k_eerd_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Read Done)\n", e10k_eerd_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(Read Address)\n", e10k_eerd_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx16 "\t(Read Data)\n", e10k_eerd_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_eerd_start_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eerd_start_rdf(__DN(t) *_dev)
{
    e10k_eerd_t _regval = mackerel_read_addr_32(_dev->base, 0x10014);
    return(e10k_eerd_start_extract(_regval));
}

static inline uint8_t e10k_eerd_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eerd_done_rdf(__DN(t) *_dev)
{
    e10k_eerd_t _regval = mackerel_read_addr_32(_dev->base, 0x10014);
    return(e10k_eerd_done_extract(_regval));
}

static inline uint16_t e10k_eerd_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_eerd_addr_rdf(__DN(t) *_dev)
{
    e10k_eerd_t _regval = mackerel_read_addr_32(_dev->base, 0x10014);
    return(e10k_eerd_addr_extract(_regval));
}

static inline uint16_t e10k_eerd_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_eerd_data_rdf(__DN(t) *_dev)
{
    e10k_eerd_t _regval = mackerel_read_addr_32(_dev->base, 0x10014);
    return(e10k_eerd_data_extract(_regval));
}

static inline void e10k_eerd_start_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eerd_start_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eerd_t _regval = 0x1 & (((e10k_eerd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x10014)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10014, _regval);
    // No shadow register to write to
}

static inline void e10k_eerd_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eerd_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eerd_t _regval = 0x2 & (((e10k_eerd_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x10014)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10014, _regval);
    // No shadow register to write to
}

static inline void e10k_eerd_addr_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eerd_addr_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_eerd_t _regval = 0xfffc & (((e10k_eerd_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffff0003 & mackerel_read_addr_32(_dev->base, 0x10014)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10014, _regval);
    // No shadow register to write to
}

static inline void e10k_eerd_data_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eerd_data_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_eerd_t _regval = 0xffff0000 & (((e10k_eerd_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x10014)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10014, _regval);
    // No shadow register to write to
}

/*
 * Register fla: Flash Access Register
 * Type: e10k.fla (Implicit type of Flash Access Register register)
 *   fl_sck	(size 1, offset 0, init 0):	RW	Clock input to the Flash
 *   fl_ce	(size 1, offset 1, init 0):	RW	Chip select input to the Flash
 *   fl_si	(size 1, offset 2, init 0):	RW	Data input to the Flash
 *   fl_so	(size 1, offset 3, init 0):	RO	Data output bit from the Flash
 *   fl_req	(size 1, offset 4, init 0):	RW	Request Flash Access
 *   fl_gnt	(size 1, offset 5, init 0):	RW	Grant Flash Access
 *   _anon6	(size 24, offset 6, init 0):	MBZ	_
 *   fl_busy	(size 1, offset 30, init 0):	RO	Flash Busy
 *   fl_er	(size 1, offset 31, init 0):	RW	Flash Erase Command
 */
static inline e10k_fla_t e10k_fla_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1001c));
}

static inline e10k_fla_t e10k_fla_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fla_t e10k_fla_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1001c));
}

static inline void e10k_fla_rawwr(__DN(t) *_dev, e10k_fla_t _regval) __attribute__ ((always_inline));
static inline void e10k_fla_rawwr(__DN(t) *_dev, e10k_fla_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1001c, _regval);
}

static inline void e10k_fla_wr(__DN(t) *_dev, e10k_fla_t _regval) __attribute__ ((always_inline));
static inline void e10k_fla_wr(__DN(t) *_dev, e10k_fla_t _regval)
{
    _regval = (_regval & 0xc000003f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1001c, _regval);
}

static inline int e10k_fla_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fla_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fla (Flash Access Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_sck =\t%" PRIx8 "\t(Clock input to the Flash)\n", e10k_fla_fl_sck_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_ce =\t%" PRIx8 "\t(Chip select input to the Flash)\n", e10k_fla_fl_ce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_si =\t%" PRIx8 "\t(Data input to the Flash)\n", e10k_fla_fl_si_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_so =\t%" PRIx8 "\t(Data output bit from the Flash)\n", e10k_fla_fl_so_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_req =\t%" PRIx8 "\t(Request Flash Access)\n", e10k_fla_fl_req_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_gnt =\t%" PRIx8 "\t(Grant Flash Access)\n", e10k_fla_fl_gnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_busy =\t%" PRIx8 "\t(Flash Busy)\n", e10k_fla_fl_busy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fl_er =\t%" PRIx8 "\t(Flash Erase Command)\n", e10k_fla_fl_er_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_fla_fl_sck_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_sck_rdf(__DN(t) *_dev)
{
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    return(e10k_fla_fl_sck_extract(_regval));
}

static inline uint8_t e10k_fla_fl_ce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_ce_rdf(__DN(t) *_dev)
{
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    return(e10k_fla_fl_ce_extract(_regval));
}

static inline uint8_t e10k_fla_fl_si_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_si_rdf(__DN(t) *_dev)
{
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    return(e10k_fla_fl_si_extract(_regval));
}

static inline uint8_t e10k_fla_fl_so_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_so_rdf(__DN(t) *_dev)
{
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    return(e10k_fla_fl_so_extract(_regval));
}

static inline uint8_t e10k_fla_fl_req_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_req_rdf(__DN(t) *_dev)
{
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    return(e10k_fla_fl_req_extract(_regval));
}

static inline uint8_t e10k_fla_fl_gnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_gnt_rdf(__DN(t) *_dev)
{
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    return(e10k_fla_fl_gnt_extract(_regval));
}

static inline uint8_t e10k_fla_fl_busy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_busy_rdf(__DN(t) *_dev)
{
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    return(e10k_fla_fl_busy_extract(_regval));
}

static inline uint8_t e10k_fla_fl_er_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fla_fl_er_rdf(__DN(t) *_dev)
{
    e10k_fla_t _regval = mackerel_read_addr_32(_dev->base, 0x1001c);
    return(e10k_fla_fl_er_extract(_regval));
}

static inline void e10k_fla_fl_sck_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fla_fl_sck_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fla_t _regval = 0x1 & (((e10k_fla_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80000036 & mackerel_read_addr_32(_dev->base, 0x1001c)));
    // No read of register shadow required
    _regval = (_regval & 0xc000003f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1001c, _regval);
    // No shadow register to write to
}

static inline void e10k_fla_fl_ce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fla_fl_ce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fla_t _regval = 0x2 & (((e10k_fla_t )(_fieldval)) << 1);
    _regval = (_regval | (0x80000035 & mackerel_read_addr_32(_dev->base, 0x1001c)));
    // No read of register shadow required
    _regval = (_regval & 0xc000003f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1001c, _regval);
    // No shadow register to write to
}

static inline void e10k_fla_fl_si_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fla_fl_si_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fla_t _regval = 0x4 & (((e10k_fla_t )(_fieldval)) << 2);
    _regval = (_regval | (0x80000033 & mackerel_read_addr_32(_dev->base, 0x1001c)));
    // No read of register shadow required
    _regval = (_regval & 0xc000003f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1001c, _regval);
    // No shadow register to write to
}

static inline void e10k_fla_fl_req_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fla_fl_req_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fla_t _regval = 0x10 & (((e10k_fla_t )(_fieldval)) << 4);
    _regval = (_regval | (0x80000027 & mackerel_read_addr_32(_dev->base, 0x1001c)));
    // No read of register shadow required
    _regval = (_regval & 0xc000003f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1001c, _regval);
    // No shadow register to write to
}

static inline void e10k_fla_fl_gnt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fla_fl_gnt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fla_t _regval = 0x20 & (((e10k_fla_t )(_fieldval)) << 5);
    _regval = (_regval | (0x80000017 & mackerel_read_addr_32(_dev->base, 0x1001c)));
    // No read of register shadow required
    _regval = (_regval & 0xc000003f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1001c, _regval);
    // No shadow register to write to
}

static inline void e10k_fla_fl_er_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fla_fl_er_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fla_t _regval = 0x80000000 & (((e10k_fla_t )(_fieldval)) << 31);
    _regval = (_regval | (0x37 & mackerel_read_addr_32(_dev->base, 0x1001c)));
    // No read of register shadow required
    _regval = (_regval & 0xc000003f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1001c, _regval);
    // No shadow register to write to
}

/*
 * Register eemngctl: Manageability EEPROM Control Register
 * Type: e10k.eemngctl (Implicit type of Manageability EEPROM Control Register register)
 *   addr	(size 15, offset 0, init 0):	RW	EEPROM address to read or write
 *   start	(size 1, offset 15, init 0):	RW	Start
 *   write	(size 1, offset 16, init 0):	RW	Write
 *   eebusy	(size 1, offset 17, init 0):	RW	EPROM Busy
 *   _anon18	(size 13, offset 18, init 0):	RSVD	_
 *   done	(size 1, offset 31, init 0):	RW	Transaction Done
 */
static inline e10k_eemngctl_t e10k_eemngctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eemngctl_t e10k_eemngctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10110));
}

static inline e10k_eemngctl_t e10k_eemngctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eemngctl_t e10k_eemngctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10110));
}

static inline void e10k_eemngctl_rawwr(__DN(t) *_dev, e10k_eemngctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_eemngctl_rawwr(__DN(t) *_dev, e10k_eemngctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10110, _regval);
}

static inline void e10k_eemngctl_wr(__DN(t) *_dev, e10k_eemngctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_eemngctl_wr(__DN(t) *_dev, e10k_eemngctl_t _regval)
{
    _regval = (_regval & 0x8003ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7ffc0000 & mackerel_read_addr_32(_dev->base, 0x10110)));
    mackerel_write_addr_32(_dev->base, 0x10110, _regval);
}

static inline int e10k_eemngctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eemngctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eemngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10110);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eemngctl (Manageability EEPROM Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx16 "\t(EEPROM address to read or write)\n", e10k_eemngctl_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " start =\t%" PRIx8 "\t(Start)\n", e10k_eemngctl_start_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " write =\t%" PRIx8 "\t(Write)\n", e10k_eemngctl_write_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eebusy =\t%" PRIx8 "\t(EPROM Busy)\n", e10k_eemngctl_eebusy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Transaction Done)\n", e10k_eemngctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_eemngctl_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_eemngctl_addr_rdf(__DN(t) *_dev)
{
    e10k_eemngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10110);
    return(e10k_eemngctl_addr_extract(_regval));
}

static inline uint8_t e10k_eemngctl_start_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eemngctl_start_rdf(__DN(t) *_dev)
{
    e10k_eemngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10110);
    return(e10k_eemngctl_start_extract(_regval));
}

static inline uint8_t e10k_eemngctl_write_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eemngctl_write_rdf(__DN(t) *_dev)
{
    e10k_eemngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10110);
    return(e10k_eemngctl_write_extract(_regval));
}

static inline uint8_t e10k_eemngctl_eebusy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eemngctl_eebusy_rdf(__DN(t) *_dev)
{
    e10k_eemngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10110);
    return(e10k_eemngctl_eebusy_extract(_regval));
}

static inline uint8_t e10k_eemngctl_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eemngctl_done_rdf(__DN(t) *_dev)
{
    e10k_eemngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10110);
    return(e10k_eemngctl_done_extract(_regval));
}

static inline void e10k_eemngctl_addr_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eemngctl_addr_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_eemngctl_t _regval = 0x7fff & (((e10k_eemngctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff8000 & mackerel_read_addr_32(_dev->base, 0x10110)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10110, _regval);
    // No shadow register to write to
}

static inline void e10k_eemngctl_start_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eemngctl_start_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eemngctl_t _regval = 0x8000 & (((e10k_eemngctl_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x10110)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10110, _regval);
    // No shadow register to write to
}

static inline void e10k_eemngctl_write_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eemngctl_write_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eemngctl_t _regval = 0x10000 & (((e10k_eemngctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x10110)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10110, _regval);
    // No shadow register to write to
}

static inline void e10k_eemngctl_eebusy_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eemngctl_eebusy_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eemngctl_t _regval = 0x20000 & (((e10k_eemngctl_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x10110)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10110, _regval);
    // No shadow register to write to
}

static inline void e10k_eemngctl_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eemngctl_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eemngctl_t _regval = 0x80000000 & (((e10k_eemngctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x10110)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10110, _regval);
    // No shadow register to write to
}

/*
 * Register eemngdata: Manageability EEPROM Read/Write Data
 * Type: e10k.eemngdata (Implicit type of Manageability EEPROM Read/Write Data register)
 *   wrdata	(size 16, offset 0, init 0):	RW	Data to be written to the EEPROM
 *   rddata	(size 16, offset 16, init 0):	RO	Data returned from the EEPROM read
 */
static inline e10k_eemngdata_t e10k_eemngdata_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eemngdata_t e10k_eemngdata_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10114));
}

static inline e10k_eemngdata_t e10k_eemngdata_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eemngdata_t e10k_eemngdata_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10114));
}

static inline void e10k_eemngdata_rawwr(__DN(t) *_dev, e10k_eemngdata_t _regval) __attribute__ ((always_inline));
static inline void e10k_eemngdata_rawwr(__DN(t) *_dev, e10k_eemngdata_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10114, _regval);
}

static inline void e10k_eemngdata_wr(__DN(t) *_dev, e10k_eemngdata_t _regval) __attribute__ ((always_inline));
static inline void e10k_eemngdata_wr(__DN(t) *_dev, e10k_eemngdata_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x10114, _regval);
}

static inline int e10k_eemngdata_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eemngdata_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eemngdata_t _regval = mackerel_read_addr_32(_dev->base, 0x10114);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eemngdata (Manageability EEPROM Read/Write Data): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrdata =\t%" PRIx16 "\t(Data to be written to the EEPROM)\n", e10k_eemngdata_wrdata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rddata =\t%" PRIx16 "\t(Data returned from the EEPROM read)\n", e10k_eemngdata_rddata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_eemngdata_wrdata_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_eemngdata_wrdata_rdf(__DN(t) *_dev)
{
    e10k_eemngdata_t _regval = mackerel_read_addr_32(_dev->base, 0x10114);
    return(e10k_eemngdata_wrdata_extract(_regval));
}

static inline uint16_t e10k_eemngdata_rddata_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_eemngdata_rddata_rdf(__DN(t) *_dev)
{
    e10k_eemngdata_t _regval = mackerel_read_addr_32(_dev->base, 0x10114);
    return(e10k_eemngdata_rddata_extract(_regval));
}

static inline void e10k_eemngdata_wrdata_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eemngdata_wrdata_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_eemngdata_t _regval = 0xffff & (((e10k_eemngdata_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10114, _regval);
    // No shadow register to write to
}

/*
 * Register flmngctl: Manageability Flash Control Register
 * Type: e10k.flmngctl (Implicit type of Manageability Flash Control Register register)
 *   addr	(size 24, offset 0, init 0):	RW	Flash address to read or write
 *   cmd	(size 2, offset 24, init 0):	RW	Command
 *   cmdv	(size 1, offset 26, init 0):	RW	Command Valid
 *   flbusy	(size 1, offset 27, init 0):	RW	Flash Busy
 *   _anon28	(size 2, offset 28, init 0):	RSVD	_
 *   done	(size 1, offset 30, init 0):	RC	Read Done
 *   wrdone	(size 1, offset 31, init 0):	RW	Global Done
 */
static inline e10k_flmngctl_t e10k_flmngctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_flmngctl_t e10k_flmngctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10118));
}

static inline e10k_flmngctl_t e10k_flmngctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_flmngctl_t e10k_flmngctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10118));
}

static inline void e10k_flmngctl_rawwr(__DN(t) *_dev, e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_flmngctl_rawwr(__DN(t) *_dev, e10k_flmngctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10118, _regval);
}

static inline void e10k_flmngctl_wr(__DN(t) *_dev, e10k_flmngctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_flmngctl_wr(__DN(t) *_dev, e10k_flmngctl_t _regval)
{
    _regval = (_regval & 0xcfffffff);
    // No MB1 fields present
    _regval = (_regval | (0x30000000 & mackerel_read_addr_32(_dev->base, 0x10118)));
    mackerel_write_addr_32(_dev->base, 0x10118, _regval);
}

static inline int e10k_flmngctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_flmngctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_flmngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10118);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register flmngctl (Manageability Flash Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " addr =\t%" PRIx32 "\t(Flash address to read or write)\n", e10k_flmngctl_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_flmng_command_prtval(_s + _r, _avail, e10k_flmngctl_cmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Command)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmdv =\t%" PRIx8 "\t(Command Valid)\n", e10k_flmngctl_cmdv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flbusy =\t%" PRIx8 "\t(Flash Busy)\n", e10k_flmngctl_flbusy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Read Done)\n", e10k_flmngctl_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wrdone =\t%" PRIx8 "\t(Global Done)\n", e10k_flmngctl_wrdone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_flmngctl_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_flmngctl_addr_rdf(__DN(t) *_dev)
{
    e10k_flmngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10118);
    return(e10k_flmngctl_addr_extract(_regval));
}

static inline e10k_flmng_command_t e10k_flmngctl_cmd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_flmng_command_t e10k_flmngctl_cmd_rdf(__DN(t) *_dev)
{
    e10k_flmngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10118);
    return(e10k_flmngctl_cmd_extract(_regval));
}

static inline uint8_t e10k_flmngctl_cmdv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_flmngctl_cmdv_rdf(__DN(t) *_dev)
{
    e10k_flmngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10118);
    return(e10k_flmngctl_cmdv_extract(_regval));
}

static inline uint8_t e10k_flmngctl_flbusy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_flmngctl_flbusy_rdf(__DN(t) *_dev)
{
    e10k_flmngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10118);
    return(e10k_flmngctl_flbusy_extract(_regval));
}

static inline uint8_t e10k_flmngctl_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_flmngctl_done_rdf(__DN(t) *_dev)
{
    e10k_flmngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10118);
    return(e10k_flmngctl_done_extract(_regval));
}

static inline uint8_t e10k_flmngctl_wrdone_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_flmngctl_wrdone_rdf(__DN(t) *_dev)
{
    e10k_flmngctl_t _regval = mackerel_read_addr_32(_dev->base, 0x10118);
    return(e10k_flmngctl_wrdone_extract(_regval));
}

static inline void e10k_flmngctl_addr_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_flmngctl_addr_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_flmngctl_t _regval = 0xffffff & (((e10k_flmngctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xbf000000 & mackerel_read_addr_32(_dev->base, 0x10118)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10118, _regval);
    // No shadow register to write to
}

static inline void e10k_flmngctl_cmd_wrf(__DN(t) *_dev, e10k_flmng_command_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_flmngctl_cmd_wrf(__DN(t) *_dev, e10k_flmng_command_t _fieldval)
{
    e10k_flmngctl_t _regval = 0x3000000 & (((e10k_flmngctl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xbcffffff & mackerel_read_addr_32(_dev->base, 0x10118)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10118, _regval);
    // No shadow register to write to
}

static inline void e10k_flmngctl_cmdv_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_flmngctl_cmdv_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_flmngctl_t _regval = 0x4000000 & (((e10k_flmngctl_t )(_fieldval)) << 26);
    _regval = (_regval | (0xbbffffff & mackerel_read_addr_32(_dev->base, 0x10118)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10118, _regval);
    // No shadow register to write to
}

static inline void e10k_flmngctl_flbusy_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_flmngctl_flbusy_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_flmngctl_t _regval = 0x8000000 & (((e10k_flmngctl_t )(_fieldval)) << 27);
    _regval = (_regval | (0xb7ffffff & mackerel_read_addr_32(_dev->base, 0x10118)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10118, _regval);
    // No shadow register to write to
}

static inline void e10k_flmngctl_wrdone_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_flmngctl_wrdone_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_flmngctl_t _regval = 0x80000000 & (((e10k_flmngctl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x3fffffff & mackerel_read_addr_32(_dev->base, 0x10118)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10118, _regval);
    // No shadow register to write to
}

/*
 * Register flmngdata: Manageability Flash Read Data
 * Type: e10k.flmngdata (Implicit type of Manageability Flash Read Data register)
 *   data	(size 32, offset 0, init 0):	RW	Read/Write Data
 */
static inline e10k_flmngdata_t e10k_flmngdata_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_flmngdata_t e10k_flmngdata_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1011c));
}

static inline e10k_flmngdata_t e10k_flmngdata_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_flmngdata_t e10k_flmngdata_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1011c));
}

static inline void e10k_flmngdata_rawwr(__DN(t) *_dev, e10k_flmngdata_t _regval) __attribute__ ((always_inline));
static inline void e10k_flmngdata_rawwr(__DN(t) *_dev, e10k_flmngdata_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1011c, _regval);
}

static inline void e10k_flmngdata_wr(__DN(t) *_dev, e10k_flmngdata_t _regval) __attribute__ ((always_inline));
static inline void e10k_flmngdata_wr(__DN(t) *_dev, e10k_flmngdata_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1011c, _regval);
}

static inline int e10k_flmngdata_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_flmngdata_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_flmngdata_t _regval = mackerel_read_addr_32(_dev->base, 0x1011c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register flmngdata (Manageability Flash Read Data): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx32 "\t(Read/Write Data)\n", e10k_flmngdata_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_flmngdata_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_flmngdata_data_rdf(__DN(t) *_dev)
{
    e10k_flmngdata_t _regval = mackerel_read_addr_32(_dev->base, 0x1011c);
    return(e10k_flmngdata_data_extract(_regval));
}

static inline void e10k_flmngdata_data_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_flmngdata_data_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_flmngdata_t _regval = 0xffffffff & (((e10k_flmngdata_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1011c, _regval);
    // No shadow register to write to
}

/*
 * Register flop: Flash Opcode Register
 * Type: e10k.flop (Implicit type of Flash Opcode Register register)
 *   serase	(size 8, offset 0, init 0):	RW	Flash Block Erase Instruction
 *   derase	(size 8, offset 8, init 0):	RW	Flash Device Erase Instruction
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_flop_t e10k_flop_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_flop_t e10k_flop_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1013c));
}

static inline e10k_flop_t e10k_flop_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_flop_t e10k_flop_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x1013c));
}

static inline void e10k_flop_rawwr(__DN(t) *_dev, e10k_flop_t _regval) __attribute__ ((always_inline));
static inline void e10k_flop_rawwr(__DN(t) *_dev, e10k_flop_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1013c, _regval);
}

static inline void e10k_flop_wr(__DN(t) *_dev, e10k_flop_t _regval) __attribute__ ((always_inline));
static inline void e10k_flop_wr(__DN(t) *_dev, e10k_flop_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x1013c)));
    mackerel_write_addr_32(_dev->base, 0x1013c, _regval);
}

static inline int e10k_flop_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_flop_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_flop_t _regval = mackerel_read_addr_32(_dev->base, 0x1013c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register flop (Flash Opcode Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " serase =\t%" PRIx8 "\t(Flash Block Erase Instruction)\n", e10k_flop_serase_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " derase =\t%" PRIx8 "\t(Flash Device Erase Instruction)\n", e10k_flop_derase_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e10k_flop_serase_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_flop_serase_rdf(__DN(t) *_dev)
{
    e10k_flop_t _regval = mackerel_read_addr_32(_dev->base, 0x1013c);
    return(e10k_flop_serase_extract(_regval));
}

static inline uint8_t e10k_flop_derase_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_flop_derase_rdf(__DN(t) *_dev)
{
    e10k_flop_t _regval = mackerel_read_addr_32(_dev->base, 0x1013c);
    return(e10k_flop_derase_extract(_regval));
}

static inline void e10k_flop_serase_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_flop_serase_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_flop_t _regval = 0xff & (((e10k_flop_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x1013c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1013c, _regval);
    // No shadow register to write to
}

static inline void e10k_flop_derase_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_flop_derase_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_flop_t _regval = 0xff00 & (((e10k_flop_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x1013c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1013c, _regval);
    // No shadow register to write to
}

/*
 * Register grc: General Receive Control
 * Type: e10k.grc (Implicit type of General Receive Control register)
 *   mng_en	(size 1, offset 0, init 0):	RO	Manageability Enable
 *   apme	(size 1, offset 1, init 0):	RW	Advance Power Management Enable
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline e10k_grc_t e10k_grc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_grc_t e10k_grc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10200));
}

static inline e10k_grc_t e10k_grc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_grc_t e10k_grc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10200));
}

static inline void e10k_grc_rawwr(__DN(t) *_dev, e10k_grc_t _regval) __attribute__ ((always_inline));
static inline void e10k_grc_rawwr(__DN(t) *_dev, e10k_grc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10200, _regval);
}

static inline void e10k_grc_wr(__DN(t) *_dev, e10k_grc_t _regval) __attribute__ ((always_inline));
static inline void e10k_grc_wr(__DN(t) *_dev, e10k_grc_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x10200)));
    mackerel_write_addr_32(_dev->base, 0x10200, _regval);
}

static inline int e10k_grc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_grc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_grc_t _regval = mackerel_read_addr_32(_dev->base, 0x10200);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register grc (General Receive Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mng_en =\t%" PRIx8 "\t(Manageability Enable)\n", e10k_grc_mng_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apme =\t%" PRIx8 "\t(Advance Power Management Enable)\n", e10k_grc_apme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t e10k_grc_mng_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_grc_mng_en_rdf(__DN(t) *_dev)
{
    e10k_grc_t _regval = mackerel_read_addr_32(_dev->base, 0x10200);
    return(e10k_grc_mng_en_extract(_regval));
}

static inline uint8_t e10k_grc_apme_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_grc_apme_rdf(__DN(t) *_dev)
{
    e10k_grc_t _regval = mackerel_read_addr_32(_dev->base, 0x10200);
    return(e10k_grc_apme_extract(_regval));
}

static inline void e10k_grc_apme_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_grc_apme_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_grc_t _regval = 0x2 & (((e10k_grc_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x10200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10200, _regval);
    // No shadow register to write to
}

/*
 * Register pfctop: Priority Flow Control Type Opcode
 * Type: e10k.pfctop (Implicit type of Priority Flow Control Type Opcode register)
 *   fct	(size 16, offset 0, init 0):	RW	Priority Flow Control EtherType
 *   fcop	(size 16, offset 16, init 0):	RW	Priority Flow Control Opcode
 */
static inline e10k_pfctop_t e10k_pfctop_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pfctop_t e10k_pfctop_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3008));
}

static inline e10k_pfctop_t e10k_pfctop_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pfctop_t e10k_pfctop_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3008));
}

static inline void e10k_pfctop_rawwr(__DN(t) *_dev, e10k_pfctop_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfctop_rawwr(__DN(t) *_dev, e10k_pfctop_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3008, _regval);
}

static inline void e10k_pfctop_wr(__DN(t) *_dev, e10k_pfctop_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfctop_wr(__DN(t) *_dev, e10k_pfctop_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3008, _regval);
}

static inline int e10k_pfctop_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pfctop_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pfctop_t _regval = mackerel_read_addr_32(_dev->base, 0x3008);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pfctop (Priority Flow Control Type Opcode): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fct =\t%" PRIx16 "\t(Priority Flow Control EtherType)\n", e10k_pfctop_fct_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcop =\t%" PRIx16 "\t(Priority Flow Control Opcode)\n", e10k_pfctop_fcop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_pfctop_fct_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_pfctop_fct_rdf(__DN(t) *_dev)
{
    e10k_pfctop_t _regval = mackerel_read_addr_32(_dev->base, 0x3008);
    return(e10k_pfctop_fct_extract(_regval));
}

static inline uint16_t e10k_pfctop_fcop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_pfctop_fcop_rdf(__DN(t) *_dev)
{
    e10k_pfctop_t _regval = mackerel_read_addr_32(_dev->base, 0x3008);
    return(e10k_pfctop_fcop_extract(_regval));
}

static inline void e10k_pfctop_fct_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfctop_fct_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_pfctop_t _regval = 0xffff & (((e10k_pfctop_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x3008)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3008, _regval);
    // No shadow register to write to
}

static inline void e10k_pfctop_fcop_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfctop_fcop_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_pfctop_t _regval = 0xffff0000 & (((e10k_pfctop_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x3008)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3008, _regval);
    // No shadow register to write to
}

/*
 * Register array fcttv: Flow Control Transmit Timer Value
 * Type: e10k.fcttv (Implicit type of Flow Control Transmit Timer Value register array)
 *   ttv0	(size 16, offset 0, init 0):	RW	Transmit Timer Value 2n
 *   ttv1	(size 16, offset 16, init 0):	RW	Transmit Timer Value 2n+1
 */
static const size_t e10k_fcttv_length = 4;
static inline e10k_fcttv_t e10k_fcttv_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_fcttv_t e10k_fcttv_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3200 + (_i * (32 / 8))));
}

static inline e10k_fcttv_t e10k_fcttv_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_fcttv_t e10k_fcttv_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3200 + (_i * (32 / 8))));
}

static inline void e10k_fcttv_rawwr(__DN(t) *_dev, int _i, e10k_fcttv_t _regval) __attribute__ ((always_inline));
static inline void e10k_fcttv_rawwr(__DN(t) *_dev, int _i, e10k_fcttv_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)), _regval);
}

static inline void e10k_fcttv_wr(__DN(t) *_dev, int _i, e10k_fcttv_t _regval) __attribute__ ((always_inline));
static inline void e10k_fcttv_wr(__DN(t) *_dev, int _i, e10k_fcttv_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)), _regval);
}

static inline int e10k_fcttv_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_fcttv_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fcttv_t _regval = mackerel_read_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fcttv", _i, "Flow Control Transmit Timer Value");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ttv0 =\t%" PRIx16 "\t(Transmit Timer Value 2n)\n", e10k_fcttv_ttv0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ttv1 =\t%" PRIx16 "\t(Transmit Timer Value 2n+1)\n", e10k_fcttv_ttv1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_fcttv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fcttv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_fcttv_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_fcttv_ttv0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_fcttv_ttv0_rdf(__DN(t) *_dev, int _i)
{
    e10k_fcttv_t _regval = mackerel_read_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)));
    return(e10k_fcttv_ttv0_extract(_regval));
}

static inline uint16_t e10k_fcttv_ttv1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_fcttv_ttv1_rdf(__DN(t) *_dev, int _i)
{
    e10k_fcttv_t _regval = mackerel_read_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)));
    return(e10k_fcttv_ttv1_extract(_regval));
}

static inline void e10k_fcttv_ttv0_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fcttv_ttv0_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_fcttv_t _regval = 0xffff & (((e10k_fcttv_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_fcttv_ttv1_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fcttv_ttv1_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_fcttv_t _regval = 0xffff0000 & (((e10k_fcttv_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3200 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array fcrtl: Flow Control Receive Threshold Low
 * Type: e10k.fcrtl (Implicit type of Flow Control Receive Threshold Low register array)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rtl	(size 14, offset 5, init 0):	RW	Receive Threshold Low n
 *   _anon19	(size 12, offset 19, init 0):	RSVD	_
 *   xone	(size 1, offset 31, init 0):	RW	XON Enable n
 */
static const size_t e10k_fcrtl_length = 8;
static inline e10k_fcrtl_t e10k_fcrtl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_fcrtl_t e10k_fcrtl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3220 + (_i * (32 / 8))));
}

static inline e10k_fcrtl_t e10k_fcrtl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_fcrtl_t e10k_fcrtl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3220 + (_i * (32 / 8))));
}

static inline void e10k_fcrtl_rawwr(__DN(t) *_dev, int _i, e10k_fcrtl_t _regval) __attribute__ ((always_inline));
static inline void e10k_fcrtl_rawwr(__DN(t) *_dev, int _i, e10k_fcrtl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)), _regval);
}

static inline void e10k_fcrtl_wr(__DN(t) *_dev, int _i, e10k_fcrtl_t _regval) __attribute__ ((always_inline));
static inline void e10k_fcrtl_wr(__DN(t) *_dev, int _i, e10k_fcrtl_t _regval)
{
    _regval = (_regval & 0x8007ffe0);
    // No MB1 fields present
    _regval = (_regval | (0x7ff8001f & mackerel_read_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)), _regval);
}

static inline int e10k_fcrtl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_fcrtl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fcrtl_t _regval = mackerel_read_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fcrtl", _i, "Flow Control Receive Threshold Low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtl =\t%" PRIx16 "\t(Receive Threshold Low n)\n", e10k_fcrtl_rtl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xone =\t%" PRIx8 "\t(XON Enable n)\n", e10k_fcrtl_xone_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_fcrtl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fcrtl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_fcrtl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_fcrtl_rtl_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_fcrtl_rtl_rdf(__DN(t) *_dev, int _i)
{
    e10k_fcrtl_t _regval = mackerel_read_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)));
    return(e10k_fcrtl_rtl_extract(_regval));
}

static inline uint8_t e10k_fcrtl_xone_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_fcrtl_xone_rdf(__DN(t) *_dev, int _i)
{
    e10k_fcrtl_t _regval = mackerel_read_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)));
    return(e10k_fcrtl_xone_extract(_regval));
}

static inline void e10k_fcrtl_rtl_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fcrtl_rtl_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_fcrtl_t _regval = 0x7ffe0 & (((e10k_fcrtl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfff8001f & mackerel_read_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_fcrtl_xone_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fcrtl_xone_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_fcrtl_t _regval = 0x80000000 & (((e10k_fcrtl_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3220 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array fcrth: Flow Control Receive Threshold High
 * Type: e10k.fcrth (Implicit type of Flow Control Receive Threshold High register array)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rth	(size 14, offset 5, init 0):	RW	Receive Threshold High n
 *   _anon19	(size 12, offset 19, init 0):	RSVD	_
 *   fcen	(size 1, offset 31, init 0):	RW	Transmit flow control enable for packet buffer n
 */
static const size_t e10k_fcrth_length = 8;
static inline e10k_fcrth_t e10k_fcrth_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_fcrth_t e10k_fcrth_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3260 + (_i * (32 / 8))));
}

static inline e10k_fcrth_t e10k_fcrth_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_fcrth_t e10k_fcrth_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3260 + (_i * (32 / 8))));
}

static inline void e10k_fcrth_rawwr(__DN(t) *_dev, int _i, e10k_fcrth_t _regval) __attribute__ ((always_inline));
static inline void e10k_fcrth_rawwr(__DN(t) *_dev, int _i, e10k_fcrth_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)), _regval);
}

static inline void e10k_fcrth_wr(__DN(t) *_dev, int _i, e10k_fcrth_t _regval) __attribute__ ((always_inline));
static inline void e10k_fcrth_wr(__DN(t) *_dev, int _i, e10k_fcrth_t _regval)
{
    _regval = (_regval & 0x8007ffe0);
    // No MB1 fields present
    _regval = (_regval | (0x7ff8001f & mackerel_read_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)), _regval);
}

static inline int e10k_fcrth_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_fcrth_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fcrth_t _regval = mackerel_read_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fcrth", _i, "Flow Control Receive Threshold High");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rth =\t%" PRIx16 "\t(Receive Threshold High n)\n", e10k_fcrth_rth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcen =\t%" PRIx8 "\t(Transmit flow control enable for packet buffer n)\n", e10k_fcrth_fcen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_fcrth_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fcrth_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_fcrth_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_fcrth_rth_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_fcrth_rth_rdf(__DN(t) *_dev, int _i)
{
    e10k_fcrth_t _regval = mackerel_read_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)));
    return(e10k_fcrth_rth_extract(_regval));
}

static inline uint8_t e10k_fcrth_fcen_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_fcrth_fcen_rdf(__DN(t) *_dev, int _i)
{
    e10k_fcrth_t _regval = mackerel_read_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)));
    return(e10k_fcrth_fcen_extract(_regval));
}

static inline void e10k_fcrth_rth_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fcrth_rth_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_fcrth_t _regval = 0x7ffe0 & (((e10k_fcrth_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfff8001f & mackerel_read_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_fcrth_fcen_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fcrth_fcen_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_fcrth_t _regval = 0x80000000 & (((e10k_fcrth_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3260 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register fcrtv: Flow Control Refresh Threshold Value
 * Type: e10k.fcrtv (Implicit type of Flow Control Refresh Threshold Value register)
 *   fc_refth	(size 16, offset 0, init 0):	RW	Flow Control Refresh Threshold
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_fcrtv_t e10k_fcrtv_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fcrtv_t e10k_fcrtv_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x32a0));
}

static inline e10k_fcrtv_t e10k_fcrtv_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fcrtv_t e10k_fcrtv_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x32a0));
}

static inline void e10k_fcrtv_rawwr(__DN(t) *_dev, e10k_fcrtv_t _regval) __attribute__ ((always_inline));
static inline void e10k_fcrtv_rawwr(__DN(t) *_dev, e10k_fcrtv_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x32a0, _regval);
}

static inline void e10k_fcrtv_wr(__DN(t) *_dev, e10k_fcrtv_t _regval) __attribute__ ((always_inline));
static inline void e10k_fcrtv_wr(__DN(t) *_dev, e10k_fcrtv_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x32a0)));
    mackerel_write_addr_32(_dev->base, 0x32a0, _regval);
}

static inline int e10k_fcrtv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fcrtv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fcrtv_t _regval = mackerel_read_addr_32(_dev->base, 0x32a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fcrtv (Flow Control Refresh Threshold Value): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fc_refth =\t%" PRIx16 "\t(Flow Control Refresh Threshold)\n", e10k_fcrtv_fc_refth_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e10k_fcrtv_fc_refth_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fcrtv_fc_refth_rdf(__DN(t) *_dev)
{
    e10k_fcrtv_t _regval = mackerel_read_addr_32(_dev->base, 0x32a0);
    return(e10k_fcrtv_fc_refth_extract(_regval));
}

static inline void e10k_fcrtv_fc_refth_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fcrtv_fc_refth_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fcrtv_t _regval = 0xffff & (((e10k_fcrtv_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x32a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x32a0, _regval);
    // No shadow register to write to
}

/*
 * Register tfcs: Transmit Flow Control Status
 * Type: e10k.tfcs (Implicit type of Transmit Flow Control Status register)
 *   tc_xon	(size 8, offset 0, init 0):	RO	Set if flow control is in XON state
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline e10k_tfcs_t e10k_tfcs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_tfcs_t e10k_tfcs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xce00));
}

static inline e10k_tfcs_t e10k_tfcs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_tfcs_t e10k_tfcs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xce00));
}

static inline void e10k_tfcs_rawwr(__DN(t) *_dev, e10k_tfcs_t _regval) __attribute__ ((always_inline));
static inline void e10k_tfcs_rawwr(__DN(t) *_dev, e10k_tfcs_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xce00, _regval);
}

// Register tfcs is not writeable
static inline int e10k_tfcs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tfcs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_tfcs_t _regval = mackerel_read_addr_32(_dev->base, 0xce00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tfcs (Transmit Flow Control Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc_xon =\t%" PRIx8 "\t(Set if flow control is in XON state)\n", e10k_tfcs_tc_xon_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t e10k_tfcs_tc_xon_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_tfcs_tc_xon_rdf(__DN(t) *_dev)
{
    e10k_tfcs_t _regval = mackerel_read_addr_32(_dev->base, 0xce00);
    return(e10k_tfcs_tc_xon_extract(_regval));
}

/*
 * Register fccfg: Flow Control Configuration
 * Type: e10k.fccfg (Implicit type of Flow Control Configuration register)
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   tfce	(size 2, offset 3, init 0):	RW	Transmit Flow Control Enable
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
static inline e10k_fccfg_t e10k_fccfg_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fccfg_t e10k_fccfg_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3d00));
}

static inline e10k_fccfg_t e10k_fccfg_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fccfg_t e10k_fccfg_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3d00));
}

static inline void e10k_fccfg_rawwr(__DN(t) *_dev, e10k_fccfg_t _regval) __attribute__ ((always_inline));
static inline void e10k_fccfg_rawwr(__DN(t) *_dev, e10k_fccfg_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3d00, _regval);
}

static inline void e10k_fccfg_wr(__DN(t) *_dev, e10k_fccfg_t _regval) __attribute__ ((always_inline));
static inline void e10k_fccfg_wr(__DN(t) *_dev, e10k_fccfg_t _regval)
{
    _regval = (_regval & 0x18);
    // No MB1 fields present
    _regval = (_regval | (0xffffffe7 & mackerel_read_addr_32(_dev->base, 0x3d00)));
    mackerel_write_addr_32(_dev->base, 0x3d00, _regval);
}

static inline int e10k_fccfg_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fccfg_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fccfg_t _regval = mackerel_read_addr_32(_dev->base, 0x3d00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fccfg (Flow Control Configuration): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tfce =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tfc_status_prtval(_s + _r, _avail, e10k_fccfg_tfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Transmit Flow Control Enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline e10k_tfc_status_t e10k_fccfg_tfce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_tfc_status_t e10k_fccfg_tfce_rdf(__DN(t) *_dev)
{
    e10k_fccfg_t _regval = mackerel_read_addr_32(_dev->base, 0x3d00);
    return(e10k_fccfg_tfce_extract(_regval));
}

static inline void e10k_fccfg_tfce_wrf(__DN(t) *_dev, e10k_tfc_status_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fccfg_tfce_wrf(__DN(t) *_dev, e10k_tfc_status_t _fieldval)
{
    e10k_fccfg_t _regval = 0x18 & (((e10k_fccfg_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffe7 & mackerel_read_addr_32(_dev->base, 0x3d00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3d00, _regval);
    // No shadow register to write to
}

/*
 * Register gcr: PCIe Control Register
 * Type: e10k.gcr (Implicit type of PCIe Control Register register)
 *   _anon0	(size 9, offset 0, init 0):	RSVD	_
 *   ctrsen	(size 1, offset 9, init 0):	RW	Completion Timeout resend enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   no_resend	(size 2, offset 11, init 0):	RW	Number of resends
 *   _anon13	(size 5, offset 13, init 0):	RSVD	_
 *   pcie_capver	(size 1, offset 18, init 0):	RW	PCIe Capability Version
 *   _anon19	(size 2, offset 19, init 0):	RSVD	_
 *   hdrlog_inv	(size 1, offset 21, init 0):	RW	hdr_log inversion
 *   _anon22	(size 10, offset 22, init 0):	RSVD	_
 */
static inline e10k_gcr_t e10k_gcr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gcr_t e10k_gcr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11000));
}

static inline e10k_gcr_t e10k_gcr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gcr_t e10k_gcr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11000));
}

static inline void e10k_gcr_rawwr(__DN(t) *_dev, e10k_gcr_t _regval) __attribute__ ((always_inline));
static inline void e10k_gcr_rawwr(__DN(t) *_dev, e10k_gcr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11000, _regval);
}

static inline void e10k_gcr_wr(__DN(t) *_dev, e10k_gcr_t _regval) __attribute__ ((always_inline));
static inline void e10k_gcr_wr(__DN(t) *_dev, e10k_gcr_t _regval)
{
    _regval = (_regval & 0x241a00);
    // No MB1 fields present
    _regval = (_regval | (0xffdbe5ff & mackerel_read_addr_32(_dev->base, 0x11000)));
    mackerel_write_addr_32(_dev->base, 0x11000, _regval);
}

static inline int e10k_gcr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gcr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x11000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gcr (PCIe Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ctrsen =\t%" PRIx8 "\t(Completion Timeout resend enable)\n", e10k_gcr_ctrsen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " no_resend =\t%" PRIx8 "\t(Number of resends)\n", e10k_gcr_no_resend_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_capver =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_capability_version_prtval(_s + _r, _avail, e10k_gcr_pcie_capver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PCIe Capability Version)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hdrlog_inv =\t%" PRIx8 "\t(hdr_log inversion)\n", e10k_gcr_hdrlog_inv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    return(_r);
}

static inline uint8_t e10k_gcr_ctrsen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gcr_ctrsen_rdf(__DN(t) *_dev)
{
    e10k_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x11000);
    return(e10k_gcr_ctrsen_extract(_regval));
}

static inline uint8_t e10k_gcr_no_resend_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gcr_no_resend_rdf(__DN(t) *_dev)
{
    e10k_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x11000);
    return(e10k_gcr_no_resend_extract(_regval));
}

static inline e10k_pcie_capability_version_t e10k_gcr_pcie_capver_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcie_capability_version_t e10k_gcr_pcie_capver_rdf(__DN(t) *_dev)
{
    e10k_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x11000);
    return(e10k_gcr_pcie_capver_extract(_regval));
}

static inline uint8_t e10k_gcr_hdrlog_inv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gcr_hdrlog_inv_rdf(__DN(t) *_dev)
{
    e10k_gcr_t _regval = mackerel_read_addr_32(_dev->base, 0x11000);
    return(e10k_gcr_hdrlog_inv_extract(_regval));
}

static inline void e10k_gcr_ctrsen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gcr_ctrsen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gcr_t _regval = 0x200 & (((e10k_gcr_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x11000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11000, _regval);
    // No shadow register to write to
}

static inline void e10k_gcr_no_resend_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gcr_no_resend_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gcr_t _regval = 0x1800 & (((e10k_gcr_t )(_fieldval)) << 11);
    _regval = (_regval | (0xffffe7ff & mackerel_read_addr_32(_dev->base, 0x11000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11000, _regval);
    // No shadow register to write to
}

static inline void e10k_gcr_pcie_capver_wrf(__DN(t) *_dev, e10k_pcie_capability_version_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gcr_pcie_capver_wrf(__DN(t) *_dev, e10k_pcie_capability_version_t _fieldval)
{
    e10k_gcr_t _regval = 0x40000 & (((e10k_gcr_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffbffff & mackerel_read_addr_32(_dev->base, 0x11000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11000, _regval);
    // No shadow register to write to
}

static inline void e10k_gcr_hdrlog_inv_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gcr_hdrlog_inv_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gcr_t _regval = 0x200000 & (((e10k_gcr_t )(_fieldval)) << 21);
    _regval = (_regval | (0xffdfffff & mackerel_read_addr_32(_dev->base, 0x11000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11000, _regval);
    // No shadow register to write to
}

/*
 * Register gscl_1: PCIe Statistic Control Register #1
 * Type: e10k.gscl_1 (Implicit type of PCIe Statistic Control Register #1 register)
 *   gio_cnt_en0	(size 1, offset 0, init 0):	RW	Enables PCIe statistic counter number 0
 *   gio_cnt_en1	(size 1, offset 1, init 0):	RW	Enables PCIe statistic counter number 1
 *   gio_cnt_en2	(size 1, offset 2, init 0):	RW	Enables PCIe statistic counter number 2
 *   gio_cnt_en3	(size 1, offset 3, init 0):	RW	Enables PCIe statistic counter number 3
 *   lbc_en0	(size 1, offset 4, init 0):	RW	LBC Enable 0
 *   lbc_en1	(size 1, offset 5, init 0):	RW	LBC Enable 1
 *   lbc_en2	(size 1, offset 6, init 0):	RW	LBC Enable 2
 *   lbc_en3	(size 1, offset 7, init 0):	RW	LBC Enable 3
 *   _anon8	(size 19, offset 8, init 0):	RSVD	_
 *   gio_cnt_tst	(size 1, offset 27, init 0):	RW	Test Bit
 *   gio_64bit	(size 1, offset 28, init 0):	RW	Enables two 64-bit counters instead of four 32-bit counters
 *   gio_cnt_rst	(size 1, offset 29, init 0):	RW	Reset indication of PCIe statistic counters
 *   gio_cnt_stp	(size 1, offset 30, init 0):	RW	Stop indication of PCIe statistic counters.
 *   gio_cnt_sta	(size 1, offset 31, init 0):	RW	Start indication of PCIe statistic counters.
 */
static inline e10k_gscl_1_t e10k_gscl_1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11010));
}

static inline e10k_gscl_1_t e10k_gscl_1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gscl_1_t e10k_gscl_1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11010));
}

static inline void e10k_gscl_1_rawwr(__DN(t) *_dev, e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_rawwr(__DN(t) *_dev, e10k_gscl_1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
}

static inline void e10k_gscl_1_wr(__DN(t) *_dev, e10k_gscl_1_t _regval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_wr(__DN(t) *_dev, e10k_gscl_1_t _regval)
{
    _regval = (_regval & 0xf80000ff);
    // No MB1 fields present
    _regval = (_regval | (0x7ffff00 & mackerel_read_addr_32(_dev->base, 0x11010)));
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
}

static inline int e10k_gscl_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gscl_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gscl_1 (PCIe Statistic Control Register #1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_en0 =\t%" PRIx8 "\t(Enables PCIe statistic counter number 0)\n", e10k_gscl_1_gio_cnt_en0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_en1 =\t%" PRIx8 "\t(Enables PCIe statistic counter number 1)\n", e10k_gscl_1_gio_cnt_en1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_en2 =\t%" PRIx8 "\t(Enables PCIe statistic counter number 2)\n", e10k_gscl_1_gio_cnt_en2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_en3 =\t%" PRIx8 "\t(Enables PCIe statistic counter number 3)\n", e10k_gscl_1_gio_cnt_en3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_en0 =\t%" PRIx8 "\t(LBC Enable 0)\n", e10k_gscl_1_lbc_en0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_en1 =\t%" PRIx8 "\t(LBC Enable 1)\n", e10k_gscl_1_lbc_en1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_en2 =\t%" PRIx8 "\t(LBC Enable 2)\n", e10k_gscl_1_lbc_en2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_en3 =\t%" PRIx8 "\t(LBC Enable 3)\n", e10k_gscl_1_lbc_en3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_tst =\t%" PRIx8 "\t(Test Bit)\n", e10k_gscl_1_gio_cnt_tst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_64bit =\t%" PRIx8 "\t(Enables two 64-bit counters instead of four 32-bit counters)\n", e10k_gscl_1_gio_64bit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_rst =\t%" PRIx8 "\t(Reset indication of PCIe statistic counters)\n", e10k_gscl_1_gio_cnt_rst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_stp =\t%" PRIx8 "\t(Stop indication of PCIe statistic counters.)\n", e10k_gscl_1_gio_cnt_stp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_cnt_sta =\t%" PRIx8 "\t(Start indication of PCIe statistic counters.)\n", e10k_gscl_1_gio_cnt_sta_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_gscl_1_gio_cnt_en0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_en0_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_cnt_en0_extract(_regval));
}

static inline uint8_t e10k_gscl_1_gio_cnt_en1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_en1_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_cnt_en1_extract(_regval));
}

static inline uint8_t e10k_gscl_1_gio_cnt_en2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_en2_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_cnt_en2_extract(_regval));
}

static inline uint8_t e10k_gscl_1_gio_cnt_en3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_en3_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_cnt_en3_extract(_regval));
}

static inline uint8_t e10k_gscl_1_lbc_en0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_lbc_en0_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_lbc_en0_extract(_regval));
}

static inline uint8_t e10k_gscl_1_lbc_en1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_lbc_en1_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_lbc_en1_extract(_regval));
}

static inline uint8_t e10k_gscl_1_lbc_en2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_lbc_en2_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_lbc_en2_extract(_regval));
}

static inline uint8_t e10k_gscl_1_lbc_en3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_lbc_en3_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_lbc_en3_extract(_regval));
}

static inline uint8_t e10k_gscl_1_gio_cnt_tst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_tst_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_cnt_tst_extract(_regval));
}

static inline uint8_t e10k_gscl_1_gio_64bit_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_64bit_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_64bit_extract(_regval));
}

static inline uint8_t e10k_gscl_1_gio_cnt_rst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_rst_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_cnt_rst_extract(_regval));
}

static inline uint8_t e10k_gscl_1_gio_cnt_stp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_stp_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_cnt_stp_extract(_regval));
}

static inline uint8_t e10k_gscl_1_gio_cnt_sta_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gscl_1_gio_cnt_sta_rdf(__DN(t) *_dev)
{
    e10k_gscl_1_t _regval = mackerel_read_addr_32(_dev->base, 0x11010);
    return(e10k_gscl_1_gio_cnt_sta_extract(_regval));
}

static inline void e10k_gscl_1_gio_cnt_en0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_cnt_en0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x1 & (((e10k_gscl_1_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_gio_cnt_en1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_cnt_en1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x2 & (((e10k_gscl_1_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_gio_cnt_en2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_cnt_en2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x4 & (((e10k_gscl_1_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_gio_cnt_en3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_cnt_en3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x8 & (((e10k_gscl_1_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_lbc_en0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_lbc_en0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x10 & (((e10k_gscl_1_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_lbc_en1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_lbc_en1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x20 & (((e10k_gscl_1_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_lbc_en2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_lbc_en2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x40 & (((e10k_gscl_1_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_lbc_en3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_lbc_en3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x80 & (((e10k_gscl_1_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_gio_cnt_tst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_cnt_tst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x8000000 & (((e10k_gscl_1_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7ffffff & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_gio_64bit_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_64bit_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x10000000 & (((e10k_gscl_1_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_gio_cnt_rst_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_cnt_rst_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x20000000 & (((e10k_gscl_1_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_gio_cnt_stp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_cnt_stp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x40000000 & (((e10k_gscl_1_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_1_gio_cnt_sta_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_1_gio_cnt_sta_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gscl_1_t _regval = 0x80000000 & (((e10k_gscl_1_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x11010)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11010, _regval);
    // No shadow register to write to
}

/*
 * Register gscl_2: PCIe Statistic Control Register #2
 * Type: e10k.gscl_2 (Implicit type of PCIe Statistic Control Register #2 register)
 *   gio_evcnt0	(size 8, offset 0, init 0):	RW	Event number that counter 0 counts
 *   gio_evcnt1	(size 8, offset 8, init 0):	RW	Event number that counter 1 counts
 *   gio_evcnt2	(size 8, offset 16, init 0):	RW	Event number that counter 2 counts
 *   gio_evcnt3	(size 8, offset 24, init 0):	RW	Event number that counter 3 counts
 */
static inline e10k_gscl_2_t e10k_gscl_2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gscl_2_t e10k_gscl_2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11014));
}

static inline e10k_gscl_2_t e10k_gscl_2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gscl_2_t e10k_gscl_2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11014));
}

static inline void e10k_gscl_2_rawwr(__DN(t) *_dev, e10k_gscl_2_t _regval) __attribute__ ((always_inline));
static inline void e10k_gscl_2_rawwr(__DN(t) *_dev, e10k_gscl_2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11014, _regval);
}

static inline void e10k_gscl_2_wr(__DN(t) *_dev, e10k_gscl_2_t _regval) __attribute__ ((always_inline));
static inline void e10k_gscl_2_wr(__DN(t) *_dev, e10k_gscl_2_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x11014, _regval);
}

static inline int e10k_gscl_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gscl_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_gscl_2_t _regval = mackerel_read_addr_32(_dev->base, 0x11014);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gscl_2 (PCIe Statistic Control Register #2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_evcnt0 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_statenc_prtval(_s + _r, _avail, e10k_gscl_2_gio_evcnt0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Event number that counter 0 counts)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_evcnt1 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_statenc_prtval(_s + _r, _avail, e10k_gscl_2_gio_evcnt1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Event number that counter 1 counts)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_evcnt2 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_statenc_prtval(_s + _r, _avail, e10k_gscl_2_gio_evcnt2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Event number that counter 2 counts)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gio_evcnt3 =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcie_statenc_prtval(_s + _r, _avail, e10k_gscl_2_gio_evcnt3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Event number that counter 3 counts)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt0_rdf(__DN(t) *_dev)
{
    e10k_gscl_2_t _regval = mackerel_read_addr_32(_dev->base, 0x11014);
    return(e10k_gscl_2_gio_evcnt0_extract(_regval));
}

static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt1_rdf(__DN(t) *_dev)
{
    e10k_gscl_2_t _regval = mackerel_read_addr_32(_dev->base, 0x11014);
    return(e10k_gscl_2_gio_evcnt1_extract(_regval));
}

static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt2_rdf(__DN(t) *_dev)
{
    e10k_gscl_2_t _regval = mackerel_read_addr_32(_dev->base, 0x11014);
    return(e10k_gscl_2_gio_evcnt2_extract(_regval));
}

static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcie_statenc_t e10k_gscl_2_gio_evcnt3_rdf(__DN(t) *_dev)
{
    e10k_gscl_2_t _regval = mackerel_read_addr_32(_dev->base, 0x11014);
    return(e10k_gscl_2_gio_evcnt3_extract(_regval));
}

static inline void e10k_gscl_2_gio_evcnt0_wrf(__DN(t) *_dev, e10k_pcie_statenc_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_2_gio_evcnt0_wrf(__DN(t) *_dev, e10k_pcie_statenc_t _fieldval)
{
    e10k_gscl_2_t _regval = 0xff & (((e10k_gscl_2_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x11014)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11014, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_2_gio_evcnt1_wrf(__DN(t) *_dev, e10k_pcie_statenc_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_2_gio_evcnt1_wrf(__DN(t) *_dev, e10k_pcie_statenc_t _fieldval)
{
    e10k_gscl_2_t _regval = 0xff00 & (((e10k_gscl_2_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x11014)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11014, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_2_gio_evcnt2_wrf(__DN(t) *_dev, e10k_pcie_statenc_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_2_gio_evcnt2_wrf(__DN(t) *_dev, e10k_pcie_statenc_t _fieldval)
{
    e10k_gscl_2_t _regval = 0xff0000 & (((e10k_gscl_2_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->base, 0x11014)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11014, _regval);
    // No shadow register to write to
}

static inline void e10k_gscl_2_gio_evcnt3_wrf(__DN(t) *_dev, e10k_pcie_statenc_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl_2_gio_evcnt3_wrf(__DN(t) *_dev, e10k_pcie_statenc_t _fieldval)
{
    e10k_gscl_2_t _regval = 0xff000000 & (((e10k_gscl_2_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x11014)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11014, _regval);
    // No shadow register to write to
}

/*
 * Register array gscl5_8: PCIe Statistic Control Register #5...#8
 * Type: e10k.gscl5_8 (Implicit type of PCIe Statistic Control Register #5...#8 register array)
 *   lbc_thr	(size 16, offset 0, init 0):	RW	Threshold for the leaky bucket counter n.
 *   lbc_timer	(size 16, offset 16, init 0):	RW	Time period between decrementing value in leaky bucket Counter n.
 */
static const size_t e10k_gscl5_8_length = 4;
static inline e10k_gscl5_8_t e10k_gscl5_8_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_gscl5_8_t e10k_gscl5_8_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x11030 + (_i * (32 / 8))));
}

static inline e10k_gscl5_8_t e10k_gscl5_8_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_gscl5_8_t e10k_gscl5_8_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x11030 + (_i * (32 / 8))));
}

static inline void e10k_gscl5_8_rawwr(__DN(t) *_dev, int _i, e10k_gscl5_8_t _regval) __attribute__ ((always_inline));
static inline void e10k_gscl5_8_rawwr(__DN(t) *_dev, int _i, e10k_gscl5_8_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)), _regval);
}

static inline void e10k_gscl5_8_wr(__DN(t) *_dev, int _i, e10k_gscl5_8_t _regval) __attribute__ ((always_inline));
static inline void e10k_gscl5_8_wr(__DN(t) *_dev, int _i, e10k_gscl5_8_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)), _regval);
}

static inline int e10k_gscl5_8_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_gscl5_8_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_gscl5_8_t _regval = mackerel_read_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "gscl5_8", _i, "PCIe Statistic Control Register #5...#8");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_thr =\t%" PRIx16 "\t(Threshold for the leaky bucket counter n.)\n", e10k_gscl5_8_lbc_thr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lbc_timer =\t%" PRIx16 "\t(Time period between decrementing value in leaky bucket Counter n.)\n", e10k_gscl5_8_lbc_timer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_gscl5_8_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gscl5_8_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_gscl5_8_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_gscl5_8_lbc_thr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_gscl5_8_lbc_thr_rdf(__DN(t) *_dev, int _i)
{
    e10k_gscl5_8_t _regval = mackerel_read_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)));
    return(e10k_gscl5_8_lbc_thr_extract(_regval));
}

static inline uint16_t e10k_gscl5_8_lbc_timer_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_gscl5_8_lbc_timer_rdf(__DN(t) *_dev, int _i)
{
    e10k_gscl5_8_t _regval = mackerel_read_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)));
    return(e10k_gscl5_8_lbc_timer_extract(_regval));
}

static inline void e10k_gscl5_8_lbc_thr_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl5_8_lbc_thr_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_gscl5_8_t _regval = 0xffff & (((e10k_gscl5_8_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_gscl5_8_lbc_timer_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gscl5_8_lbc_timer_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_gscl5_8_t _regval = 0xffff0000 & (((e10k_gscl5_8_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11030 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array gscn: PCIe Statistic Counter Registers #0...#3
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_gscn_length = 4;
static inline uint32_t e10k_gscn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_gscn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x11020 + (_i * (32 / 8))));
}

static inline uint32_t e10k_gscn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_gscn_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x11020 + (_i * (32 / 8))));
}

static inline void e10k_gscn_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_gscn_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11020 + (_i * (32 / 8)), _regval);
}

// Register gscn is not writeable
static inline int e10k_gscn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_gscn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x11020 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "gscn", _i, "PCIe Statistic Counter Registers #0...#3");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_gscn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gscn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_gscn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register factps: Function Active and Power State to Manageability
 * Type: e10k.factps (Implicit type of Function Active and Power State to Manageability register)
 *   f0_pstate	(size 2, offset 0, init 0):	RO	Func0 Power State
 *   lan0_valid	(size 1, offset 2, init 0):	RO	LAN0 Valid
 *   f0_auxen	(size 1, offset 3, init 0):	RO	Function 0 Auxiliary (AUX) Power PM Enable 
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   f1_pstate	(size 2, offset 6, init 0):	RO	Func1 Power State
 *   lan1_valid	(size 1, offset 8, init 0):	RO	LAN1 Valid
 *   f1_auxen	(size 1, offset 9, init 0):	RO	Function 1 Auxiliary (AUX) Power PM Enable 
 *   _anon10	(size 19, offset 10, init 0):	RSVD	_
 *   mngcg	(size 1, offset 29, init 0):	RO	Manageability Clock Gated
 *   lan_fsel	(size 1, offset 30, init 0):	RO	LAN Function Sel
 *   pstate_chg	(size 1, offset 31, init 0):	RO	PM State changed
 */
static inline e10k_factps_t e10k_factps_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10150));
}

static inline e10k_factps_t e10k_factps_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_factps_t e10k_factps_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10150));
}

static inline void e10k_factps_rawwr(__DN(t) *_dev, e10k_factps_t _regval) __attribute__ ((always_inline));
static inline void e10k_factps_rawwr(__DN(t) *_dev, e10k_factps_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10150, _regval);
}

// Register factps is not writeable
static inline int e10k_factps_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_factps_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register factps (Function Active and Power State to Manageability): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f0_pstate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_power_state_prtval(_s + _r, _avail, e10k_factps_f0_pstate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Func0 Power State)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan0_valid =\t%" PRIx8 "\t(LAN0 Valid)\n", e10k_factps_lan0_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f0_auxen =\t%" PRIx8 "\t(Function 0 Auxiliary (AUX) Power PM Enable )\n", e10k_factps_f0_auxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f1_pstate =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_power_state_prtval(_s + _r, _avail, e10k_factps_f1_pstate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Func1 Power State)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan1_valid =\t%" PRIx8 "\t(LAN1 Valid)\n", e10k_factps_lan1_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " f1_auxen =\t%" PRIx8 "\t(Function 1 Auxiliary (AUX) Power PM Enable )\n", e10k_factps_f1_auxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mngcg =\t%" PRIx8 "\t(Manageability Clock Gated)\n", e10k_factps_mngcg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lan_fsel =\t%" PRIx8 "\t(LAN Function Sel)\n", e10k_factps_lan_fsel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pstate_chg =\t%" PRIx8 "\t(PM State changed)\n", e10k_factps_pstate_chg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline e10k_power_state_t e10k_factps_f0_pstate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_power_state_t e10k_factps_f0_pstate_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_f0_pstate_extract(_regval));
}

static inline uint8_t e10k_factps_lan0_valid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_lan0_valid_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_lan0_valid_extract(_regval));
}

static inline uint8_t e10k_factps_f0_auxen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_f0_auxen_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_f0_auxen_extract(_regval));
}

static inline e10k_power_state_t e10k_factps_f1_pstate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_power_state_t e10k_factps_f1_pstate_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_f1_pstate_extract(_regval));
}

static inline uint8_t e10k_factps_lan1_valid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_lan1_valid_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_lan1_valid_extract(_regval));
}

static inline uint8_t e10k_factps_f1_auxen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_f1_auxen_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_f1_auxen_extract(_regval));
}

static inline uint8_t e10k_factps_mngcg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_mngcg_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_mngcg_extract(_regval));
}

static inline uint8_t e10k_factps_lan_fsel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_lan_fsel_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_lan_fsel_extract(_regval));
}

static inline uint8_t e10k_factps_pstate_chg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_factps_pstate_chg_rdf(__DN(t) *_dev)
{
    e10k_factps_t _regval = mackerel_read_addr_32(_dev->base, 0x10150);
    return(e10k_factps_pstate_chg_extract(_regval));
}

/*
 * Register pciephyadr: PCIe Analog Configuration Register
 * Type: e10k.pciephyadr (Implicit type of PCIe Analog Configuration Register register)
 *   address	(size 12, offset 0, init 0):	RW	The indirect access' address
 *   _anon12	(size 13, offset 12, init 0):	RSVD	_
 *   byte_en	(size 4, offset 25, init 0):	RW	The indirect access' byte enable
 *   read_en	(size 1, offset 29, init 0):	RW	The indirect access is read transaction
 *   write_en	(size 1, offset 30, init 0):	RW	The indirect access is write transaction
 *   done	(size 1, offset 31, init 0):	RW	Acknowledge for the indirect access to the CSR
 */
static inline e10k_pciephyadr_t e10k_pciephyadr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pciephyadr_t e10k_pciephyadr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11040));
}

static inline e10k_pciephyadr_t e10k_pciephyadr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pciephyadr_t e10k_pciephyadr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11040));
}

static inline void e10k_pciephyadr_rawwr(__DN(t) *_dev, e10k_pciephyadr_t _regval) __attribute__ ((always_inline));
static inline void e10k_pciephyadr_rawwr(__DN(t) *_dev, e10k_pciephyadr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11040, _regval);
}

static inline void e10k_pciephyadr_wr(__DN(t) *_dev, e10k_pciephyadr_t _regval) __attribute__ ((always_inline));
static inline void e10k_pciephyadr_wr(__DN(t) *_dev, e10k_pciephyadr_t _regval)
{
    _regval = (_regval & 0xfe000fff);
    // No MB1 fields present
    _regval = (_regval | (0x1fff000 & mackerel_read_addr_32(_dev->base, 0x11040)));
    mackerel_write_addr_32(_dev->base, 0x11040, _regval);
}

static inline int e10k_pciephyadr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pciephyadr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pciephyadr_t _regval = mackerel_read_addr_32(_dev->base, 0x11040);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pciephyadr (PCIe Analog Configuration Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx16 "\t(The indirect access' address)\n", e10k_pciephyadr_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " byte_en =\t%" PRIx8 "\t(The indirect access' byte enable)\n", e10k_pciephyadr_byte_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " read_en =\t%" PRIx8 "\t(The indirect access is read transaction)\n", e10k_pciephyadr_read_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " write_en =\t%" PRIx8 "\t(The indirect access is write transaction)\n", e10k_pciephyadr_write_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " done =\t%" PRIx8 "\t(Acknowledge for the indirect access to the CSR)\n", e10k_pciephyadr_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_pciephyadr_address_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_pciephyadr_address_rdf(__DN(t) *_dev)
{
    e10k_pciephyadr_t _regval = mackerel_read_addr_32(_dev->base, 0x11040);
    return(e10k_pciephyadr_address_extract(_regval));
}

static inline uint8_t e10k_pciephyadr_byte_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pciephyadr_byte_en_rdf(__DN(t) *_dev)
{
    e10k_pciephyadr_t _regval = mackerel_read_addr_32(_dev->base, 0x11040);
    return(e10k_pciephyadr_byte_en_extract(_regval));
}

static inline uint8_t e10k_pciephyadr_read_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pciephyadr_read_en_rdf(__DN(t) *_dev)
{
    e10k_pciephyadr_t _regval = mackerel_read_addr_32(_dev->base, 0x11040);
    return(e10k_pciephyadr_read_en_extract(_regval));
}

static inline uint8_t e10k_pciephyadr_write_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pciephyadr_write_en_rdf(__DN(t) *_dev)
{
    e10k_pciephyadr_t _regval = mackerel_read_addr_32(_dev->base, 0x11040);
    return(e10k_pciephyadr_write_en_extract(_regval));
}

static inline uint8_t e10k_pciephyadr_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pciephyadr_done_rdf(__DN(t) *_dev)
{
    e10k_pciephyadr_t _regval = mackerel_read_addr_32(_dev->base, 0x11040);
    return(e10k_pciephyadr_done_extract(_regval));
}

static inline void e10k_pciephyadr_address_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pciephyadr_address_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_pciephyadr_t _regval = 0xfff & (((e10k_pciephyadr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x11040)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11040, _regval);
    // No shadow register to write to
}

static inline void e10k_pciephyadr_byte_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pciephyadr_byte_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pciephyadr_t _regval = 0x1e000000 & (((e10k_pciephyadr_t )(_fieldval)) << 25);
    _regval = (_regval | (0xe1ffffff & mackerel_read_addr_32(_dev->base, 0x11040)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11040, _regval);
    // No shadow register to write to
}

static inline void e10k_pciephyadr_read_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pciephyadr_read_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pciephyadr_t _regval = 0x20000000 & (((e10k_pciephyadr_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0x11040)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11040, _regval);
    // No shadow register to write to
}

static inline void e10k_pciephyadr_write_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pciephyadr_write_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pciephyadr_t _regval = 0x40000000 & (((e10k_pciephyadr_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x11040)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11040, _regval);
    // No shadow register to write to
}

static inline void e10k_pciephyadr_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pciephyadr_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pciephyadr_t _regval = 0x80000000 & (((e10k_pciephyadr_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x11040)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11040, _regval);
    // No shadow register to write to
}

/*
 * Register pciephydat: PCIe PHY Data Register
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_pciephydat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_pciephydat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11044));
}

static inline uint32_t e10k_pciephydat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_pciephydat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11044));
}

static inline void e10k_pciephydat_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_pciephydat_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11044, _regval);
}

static inline void e10k_pciephydat_wr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_pciephydat_wr(__DN(t) *_dev, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x11044, _regval);
}

static inline int e10k_pciephydat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pciephydat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x11044);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pciephydat (PCIe PHY Data Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register swsm: Software Semaphore Register
 * Type: e10k.swsm (Implicit type of Software Semaphore Register register)
 *   smbi	(size 1, offset 0, init 0):	RWZC	Semaphore Bit
 *   swesmbi	(size 1, offset 1, init 0):	RW	Software Semaphore bi
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline e10k_swsm_t e10k_swsm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_swsm_t e10k_swsm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10140));
}

static inline e10k_swsm_t e10k_swsm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_swsm_t e10k_swsm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10140));
}

static inline void e10k_swsm_rawwr(__DN(t) *_dev, e10k_swsm_t _regval) __attribute__ ((always_inline));
static inline void e10k_swsm_rawwr(__DN(t) *_dev, e10k_swsm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10140, _regval);
}

static inline void e10k_swsm_wr(__DN(t) *_dev, e10k_swsm_t _regval) __attribute__ ((always_inline));
static inline void e10k_swsm_wr(__DN(t) *_dev, e10k_swsm_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x10140)));
    mackerel_write_addr_32(_dev->base, 0x10140, _regval);
}

static inline int e10k_swsm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_swsm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_swsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10140);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register swsm (Software Semaphore Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " smbi =\t%" PRIx8 "\t(Semaphore Bit)\n", e10k_swsm_smbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swesmbi =\t%" PRIx8 "\t(Software Semaphore bi)\n", e10k_swsm_swesmbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t e10k_swsm_smbi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swsm_smbi_rdf(__DN(t) *_dev)
{
    e10k_swsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10140);
    return(e10k_swsm_smbi_extract(_regval));
}

static inline uint8_t e10k_swsm_swesmbi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swsm_swesmbi_rdf(__DN(t) *_dev)
{
    e10k_swsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10140);
    return(e10k_swsm_swesmbi_extract(_regval));
}

static inline void e10k_swsm_smbi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_swsm_smbi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_swsm_t _regval = 0x1 & (((e10k_swsm_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x10140)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10140, _regval);
    // No shadow register to write to
}

static inline void e10k_swsm_swesmbi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_swsm_swesmbi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_swsm_t _regval = 0x2 & (((e10k_swsm_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x10140)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10140, _regval);
    // No shadow register to write to
}

/*
 * Register fwsm: Firmware Semaphore Register
 * Type: e10k.fwsm (Implicit type of Firmware Semaphore Register register)
 *   fwsmbi	(size 1, offset 0, init 0):	RO	Firmware Semaphore
 *   fw_mode	(size 3, offset 1, init 0):	RO	Firmware Mode
 *   _anon4	(size 2, offset 4, init 0):	RSVD	_
 *   eep_relind	(size 1, offset 6, init 0):	RO	EEPROM Reloaded Indication
 *   _anon7	(size 8, offset 7, init 0):	RSVD	_
 *   fw_valid	(size 1, offset 15, init 0):	RO	Firmware Valid
 *   reset_cnt	(size 3, offset 16, init 0):	RO	Reset Counter
 *   exterr_ind	(size 6, offset 19, init 0):	RO	External Error Indication
 *   pcie_cfgerr	(size 1, offset 25, init 0):	RO	PCIe Configuration Error Indication
 *   sdes0_err	(size 1, offset 26, init 0):	RO	PHY/SERDES0 Configuration Error Indication
 *   sdes1_err	(size 1, offset 27, init 0):	RO	PHY/SERDES1 Configuration Error Indication
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static inline e10k_fwsm_t e10k_fwsm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10148));
}

static inline e10k_fwsm_t e10k_fwsm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fwsm_t e10k_fwsm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10148));
}

static inline void e10k_fwsm_rawwr(__DN(t) *_dev, e10k_fwsm_t _regval) __attribute__ ((always_inline));
static inline void e10k_fwsm_rawwr(__DN(t) *_dev, e10k_fwsm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10148, _regval);
}

// Register fwsm is not writeable
static inline int e10k_fwsm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fwsm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fwsm (Firmware Semaphore Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fwsmbi =\t%" PRIx8 "\t(Firmware Semaphore)\n", e10k_fwsm_fwsmbi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fw_mode_prtval(_s + _r, _avail, e10k_fwsm_fw_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Firmware Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eep_relind =\t%" PRIx8 "\t(EEPROM Reloaded Indication)\n", e10k_fwsm_eep_relind_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_valid =\t%" PRIx8 "\t(Firmware Valid)\n", e10k_fwsm_fw_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " reset_cnt =\t%" PRIx8 "\t(Reset Counter)\n", e10k_fwsm_reset_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " exterr_ind =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ext_err_ind_prtval(_s + _r, _avail, e10k_fwsm_exterr_ind_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(External Error Indication)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcie_cfgerr =\t%" PRIx8 "\t(PCIe Configuration Error Indication)\n", e10k_fwsm_pcie_cfgerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdes0_err =\t%" PRIx8 "\t(PHY/SERDES0 Configuration Error Indication)\n", e10k_fwsm_sdes0_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sdes1_err =\t%" PRIx8 "\t(PHY/SERDES1 Configuration Error Indication)\n", e10k_fwsm_sdes1_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline uint8_t e10k_fwsm_fwsmbi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_fwsmbi_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_fwsmbi_extract(_regval));
}

static inline e10k_fw_mode_t e10k_fwsm_fw_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fw_mode_t e10k_fwsm_fw_mode_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_fw_mode_extract(_regval));
}

static inline uint8_t e10k_fwsm_eep_relind_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_eep_relind_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_eep_relind_extract(_regval));
}

static inline uint8_t e10k_fwsm_fw_valid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_fw_valid_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_fw_valid_extract(_regval));
}

static inline uint8_t e10k_fwsm_reset_cnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_reset_cnt_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_reset_cnt_extract(_regval));
}

static inline e10k_ext_err_ind_t e10k_fwsm_exterr_ind_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ext_err_ind_t e10k_fwsm_exterr_ind_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_exterr_ind_extract(_regval));
}

static inline uint8_t e10k_fwsm_pcie_cfgerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_pcie_cfgerr_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_pcie_cfgerr_extract(_regval));
}

static inline uint8_t e10k_fwsm_sdes0_err_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_sdes0_err_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_sdes0_err_extract(_regval));
}

static inline uint8_t e10k_fwsm_sdes1_err_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fwsm_sdes1_err_rdf(__DN(t) *_dev)
{
    e10k_fwsm_t _regval = mackerel_read_addr_32(_dev->base, 0x10148);
    return(e10k_fwsm_sdes1_err_extract(_regval));
}

/*
 * Register swfw_sync: Software Firmware Synchronization
 * Type: e10k.swfw_sync (Implicit type of Software Firmware Synchronization register)
 *   sw_eepsm	(size 1, offset 0, init 0):	RW	EEPROM access is owned by software
 *   sw_physm0	(size 1, offset 1, init 0):	RW	PHY 0 access is owned by software
 *   sw_physm1	(size 1, offset 2, init 0):	RW	PHY 1 access is owned by software
 *   sw_maccsrsm	(size 1, offset 3, init 0):	RW	Software owns access to shared CSRs
 *   sw_flsm	(size 1, offset 4, init 0):	RW	Software Flash semaphore
 *   fw_eepsm	(size 1, offset 5, init 0):	RO	EEPROM access is owned by firmware
 *   fw_physm0	(size 1, offset 6, init 0):	RO	PHY 0 access is owned by firmware
 *   fw_physm1	(size 1, offset 7, init 0):	RO	PHY 1 access is owned by firmware
 *   fw_maccsrsm	(size 1, offset 8, init 0):	RO	Firmware owns access to shared CSRs
 *   fw_flsm	(size 1, offset 9, init 0):	RO	Firmware Flash semaphore
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
static inline e10k_swfw_sync_t e10k_swfw_sync_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10160));
}

static inline e10k_swfw_sync_t e10k_swfw_sync_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_swfw_sync_t e10k_swfw_sync_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x10160));
}

static inline void e10k_swfw_sync_rawwr(__DN(t) *_dev, e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline void e10k_swfw_sync_rawwr(__DN(t) *_dev, e10k_swfw_sync_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x10160, _regval);
}

static inline void e10k_swfw_sync_wr(__DN(t) *_dev, e10k_swfw_sync_t _regval) __attribute__ ((always_inline));
static inline void e10k_swfw_sync_wr(__DN(t) *_dev, e10k_swfw_sync_t _regval)
{
    _regval = (_regval & 0x3ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffffc00 & mackerel_read_addr_32(_dev->base, 0x10160)));
    mackerel_write_addr_32(_dev->base, 0x10160, _regval);
}

static inline int e10k_swfw_sync_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_swfw_sync_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register swfw_sync (Software Firmware Synchronization): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_eepsm =\t%" PRIx8 "\t(EEPROM access is owned by software)\n", e10k_swfw_sync_sw_eepsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_physm0 =\t%" PRIx8 "\t(PHY 0 access is owned by software)\n", e10k_swfw_sync_sw_physm0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_physm1 =\t%" PRIx8 "\t(PHY 1 access is owned by software)\n", e10k_swfw_sync_sw_physm1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_maccsrsm =\t%" PRIx8 "\t(Software owns access to shared CSRs)\n", e10k_swfw_sync_sw_maccsrsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sw_flsm =\t%" PRIx8 "\t(Software Flash semaphore)\n", e10k_swfw_sync_sw_flsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_eepsm =\t%" PRIx8 "\t(EEPROM access is owned by firmware)\n", e10k_swfw_sync_fw_eepsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_physm0 =\t%" PRIx8 "\t(PHY 0 access is owned by firmware)\n", e10k_swfw_sync_fw_physm0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_physm1 =\t%" PRIx8 "\t(PHY 1 access is owned by firmware)\n", e10k_swfw_sync_fw_physm1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_maccsrsm =\t%" PRIx8 "\t(Firmware owns access to shared CSRs)\n", e10k_swfw_sync_fw_maccsrsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fw_flsm =\t%" PRIx8 "\t(Firmware Flash semaphore)\n", e10k_swfw_sync_fw_flsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline uint8_t e10k_swfw_sync_sw_eepsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_eepsm_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_sw_eepsm_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_sw_physm0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_physm0_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_sw_physm0_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_sw_physm1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_physm1_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_sw_physm1_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_sw_maccsrsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_maccsrsm_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_sw_maccsrsm_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_sw_flsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_sw_flsm_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_sw_flsm_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_fw_eepsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_eepsm_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_fw_eepsm_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_fw_physm0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_physm0_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_fw_physm0_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_fw_physm1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_physm1_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_fw_physm1_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_fw_maccsrsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_maccsrsm_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_fw_maccsrsm_extract(_regval));
}

static inline uint8_t e10k_swfw_sync_fw_flsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_swfw_sync_fw_flsm_rdf(__DN(t) *_dev)
{
    e10k_swfw_sync_t _regval = mackerel_read_addr_32(_dev->base, 0x10160);
    return(e10k_swfw_sync_fw_flsm_extract(_regval));
}

static inline void e10k_swfw_sync_sw_eepsm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_swfw_sync_sw_eepsm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_swfw_sync_t _regval = 0x1 & (((e10k_swfw_sync_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffc1e & mackerel_read_addr_32(_dev->base, 0x10160)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10160, _regval);
    // No shadow register to write to
}

static inline void e10k_swfw_sync_sw_physm0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_swfw_sync_sw_physm0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_swfw_sync_t _regval = 0x2 & (((e10k_swfw_sync_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffc1d & mackerel_read_addr_32(_dev->base, 0x10160)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10160, _regval);
    // No shadow register to write to
}

static inline void e10k_swfw_sync_sw_physm1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_swfw_sync_sw_physm1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_swfw_sync_t _regval = 0x4 & (((e10k_swfw_sync_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffc1b & mackerel_read_addr_32(_dev->base, 0x10160)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10160, _regval);
    // No shadow register to write to
}

static inline void e10k_swfw_sync_sw_maccsrsm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_swfw_sync_sw_maccsrsm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_swfw_sync_t _regval = 0x8 & (((e10k_swfw_sync_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffc17 & mackerel_read_addr_32(_dev->base, 0x10160)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10160, _regval);
    // No shadow register to write to
}

static inline void e10k_swfw_sync_sw_flsm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_swfw_sync_sw_flsm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_swfw_sync_t _regval = 0x10 & (((e10k_swfw_sync_t )(_fieldval)) << 4);
    _regval = (_regval | (0xfffffc0f & mackerel_read_addr_32(_dev->base, 0x10160)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x10160, _regval);
    // No shadow register to write to
}

/*
 * Register gcr_ext: PCIe Control Extended Register
 * Type: e10k.gcr_ext (Implicit type of PCIe Control Extended Register register)
 *   vtmode	(size 2, offset 0, init 0):	RW	VT mode of operation
 *   _anon2	(size 2, offset 2, init 0):	RSVD	_
 *   apbacd	(size 1, offset 4, init 0):	RW	Auto PBA Clear Disable
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
static inline e10k_gcr_ext_t e10k_gcr_ext_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gcr_ext_t e10k_gcr_ext_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11050));
}

static inline e10k_gcr_ext_t e10k_gcr_ext_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gcr_ext_t e10k_gcr_ext_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11050));
}

static inline void e10k_gcr_ext_rawwr(__DN(t) *_dev, e10k_gcr_ext_t _regval) __attribute__ ((always_inline));
static inline void e10k_gcr_ext_rawwr(__DN(t) *_dev, e10k_gcr_ext_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11050, _regval);
}

static inline void e10k_gcr_ext_wr(__DN(t) *_dev, e10k_gcr_ext_t _regval) __attribute__ ((always_inline));
static inline void e10k_gcr_ext_wr(__DN(t) *_dev, e10k_gcr_ext_t _regval)
{
    _regval = (_regval & 0x13);
    // No MB1 fields present
    _regval = (_regval | (0xffffffec & mackerel_read_addr_32(_dev->base, 0x11050)));
    mackerel_write_addr_32(_dev->base, 0x11050, _regval);
}

static inline int e10k_gcr_ext_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gcr_ext_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_gcr_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x11050);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gcr_ext (PCIe Control Extended Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vtmode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vt_mode_prtval(_s + _r, _avail, e10k_gcr_ext_vtmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(VT mode of operation)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " apbacd =\t%" PRIx8 "\t(Auto PBA Clear Disable)\n", e10k_gcr_ext_apbacd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline e10k_vt_mode_t e10k_gcr_ext_vtmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vt_mode_t e10k_gcr_ext_vtmode_rdf(__DN(t) *_dev)
{
    e10k_gcr_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x11050);
    return(e10k_gcr_ext_vtmode_extract(_regval));
}

static inline uint8_t e10k_gcr_ext_apbacd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gcr_ext_apbacd_rdf(__DN(t) *_dev)
{
    e10k_gcr_ext_t _regval = mackerel_read_addr_32(_dev->base, 0x11050);
    return(e10k_gcr_ext_apbacd_extract(_regval));
}

static inline void e10k_gcr_ext_vtmode_wrf(__DN(t) *_dev, e10k_vt_mode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gcr_ext_vtmode_wrf(__DN(t) *_dev, e10k_vt_mode_t _fieldval)
{
    e10k_gcr_ext_t _regval = 0x3 & (((e10k_gcr_ext_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x11050)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11050, _regval);
    // No shadow register to write to
}

static inline void e10k_gcr_ext_apbacd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gcr_ext_apbacd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gcr_ext_t _regval = 0x10 & (((e10k_gcr_ext_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x11050)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11050, _regval);
    // No shadow register to write to
}

/*
 * Register mrevid: Mirrored Revision ID
 * Type: e10k.mrevid (Implicit type of Mirrored Revision ID register)
 *   eeprom_rev	(size 8, offset 0, init 0):	RO	Mirroring of rev ID loaded from EEPROM
 *   default_rev	(size 8, offset 8, init 0):	RO	Mirroring of default rev ID, before EEPROM load
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_mrevid_t e10k_mrevid_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mrevid_t e10k_mrevid_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11064));
}

static inline e10k_mrevid_t e10k_mrevid_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mrevid_t e10k_mrevid_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11064));
}

static inline void e10k_mrevid_rawwr(__DN(t) *_dev, e10k_mrevid_t _regval) __attribute__ ((always_inline));
static inline void e10k_mrevid_rawwr(__DN(t) *_dev, e10k_mrevid_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11064, _regval);
}

// Register mrevid is not writeable
static inline int e10k_mrevid_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mrevid_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mrevid_t _regval = mackerel_read_addr_32(_dev->base, 0x11064);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mrevid (Mirrored Revision ID): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eeprom_rev =\t%" PRIx8 "\t(Mirroring of rev ID loaded from EEPROM)\n", e10k_mrevid_eeprom_rev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " default_rev =\t%" PRIx8 "\t(Mirroring of default rev ID, before EEPROM load)\n", e10k_mrevid_default_rev_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e10k_mrevid_eeprom_rev_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mrevid_eeprom_rev_rdf(__DN(t) *_dev)
{
    e10k_mrevid_t _regval = mackerel_read_addr_32(_dev->base, 0x11064);
    return(e10k_mrevid_eeprom_rev_extract(_regval));
}

static inline uint8_t e10k_mrevid_default_rev_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mrevid_default_rev_rdf(__DN(t) *_dev)
{
    e10k_mrevid_t _regval = mackerel_read_addr_32(_dev->base, 0x11064);
    return(e10k_mrevid_default_rev_extract(_regval));
}

/*
 * Register picause: PCIe Interrupt Cause
 * Type: e10k.picause (Implicit type of PCIe Interrupt Cause register)
 *   ca	(size 1, offset 0, init 0):	RWC	PCI completion abort exception
 *   ua	(size 1, offset 1, init 0):	RWC	Unsupported I/O address exception
 *   be	(size 1, offset 2, init 0):	RWC	Wrong byte-enable exception in the FUNC unit
 *   to	(size 1, offset 3, init 0):	RWC	PCI timeout exception in the FUNC unit
 *   bmef	(size 1, offset 4, init 0):	RWC	Bus master enable of the PF or one of the VFs is de-asserted
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
static inline e10k_picause_t e10k_picause_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_picause_t e10k_picause_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x110b0));
}

static inline e10k_picause_t e10k_picause_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_picause_t e10k_picause_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x110b0));
}

static inline void e10k_picause_rawwr(__DN(t) *_dev, e10k_picause_t _regval) __attribute__ ((always_inline));
static inline void e10k_picause_rawwr(__DN(t) *_dev, e10k_picause_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x110b0, _regval);
}

static inline void e10k_picause_wr(__DN(t) *_dev, e10k_picause_t _regval) __attribute__ ((always_inline));
static inline void e10k_picause_wr(__DN(t) *_dev, e10k_picause_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x110b0)));
    mackerel_write_addr_32(_dev->base, 0x110b0, _regval);
}

static inline int e10k_picause_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_picause_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_picause_t _regval = mackerel_read_addr_32(_dev->base, 0x110b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register picause (PCIe Interrupt Cause): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ca =\t%" PRIx8 "\t(PCI completion abort exception)\n", e10k_picause_ca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ua =\t%" PRIx8 "\t(Unsupported I/O address exception)\n", e10k_picause_ua_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Wrong byte-enable exception in the FUNC unit)\n", e10k_picause_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " to =\t%" PRIx8 "\t(PCI timeout exception in the FUNC unit)\n", e10k_picause_to_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bmef =\t%" PRIx8 "\t(Bus master enable of the PF or one of the VFs is de-asserted)\n", e10k_picause_bmef_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t e10k_picause_ca_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_ca_rdf(__DN(t) *_dev)
{
    e10k_picause_t _regval = mackerel_read_addr_32(_dev->base, 0x110b0);
    return(e10k_picause_ca_extract(_regval));
}

static inline uint8_t e10k_picause_ua_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_ua_rdf(__DN(t) *_dev)
{
    e10k_picause_t _regval = mackerel_read_addr_32(_dev->base, 0x110b0);
    return(e10k_picause_ua_extract(_regval));
}

static inline uint8_t e10k_picause_be_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_be_rdf(__DN(t) *_dev)
{
    e10k_picause_t _regval = mackerel_read_addr_32(_dev->base, 0x110b0);
    return(e10k_picause_be_extract(_regval));
}

static inline uint8_t e10k_picause_to_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_to_rdf(__DN(t) *_dev)
{
    e10k_picause_t _regval = mackerel_read_addr_32(_dev->base, 0x110b0);
    return(e10k_picause_to_extract(_regval));
}

static inline uint8_t e10k_picause_bmef_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_picause_bmef_rdf(__DN(t) *_dev)
{
    e10k_picause_t _regval = mackerel_read_addr_32(_dev->base, 0x110b0);
    return(e10k_picause_bmef_extract(_regval));
}

static inline void e10k_picause_ca_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_picause_ca_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_picause_t _regval = 0x1 & (((e10k_picause_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x110b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b0, _regval);
    // No shadow register to write to
}

static inline void e10k_picause_ua_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_picause_ua_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_picause_t _regval = 0x2 & (((e10k_picause_t )(_fieldval)) << 1);
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x110b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b0, _regval);
    // No shadow register to write to
}

static inline void e10k_picause_be_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_picause_be_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_picause_t _regval = 0x4 & (((e10k_picause_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x110b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b0, _regval);
    // No shadow register to write to
}

static inline void e10k_picause_to_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_picause_to_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_picause_t _regval = 0x8 & (((e10k_picause_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x110b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b0, _regval);
    // No shadow register to write to
}

static inline void e10k_picause_bmef_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_picause_bmef_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_picause_t _regval = 0x10 & (((e10k_picause_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x110b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b0, _regval);
    // No shadow register to write to
}

/*
 * Register piena: PCIe Interrupt Enable
 * Type: e10k.piena (Implicit type of PCIe Interrupt Enable register)
 *   ca	(size 1, offset 0, init 0):	RW	Enable PCI completion abort interrupt
 *   ua	(size 1, offset 1, init 0):	RW	Enable unsupported I/O address interrupt
 *   be	(size 1, offset 2, init 0):	RW	Enable wrong byte-enable interrupt
 *   to	(size 1, offset 3, init 0):	RW	Enable PCI timeout interrupt
 *   bmef	(size 1, offset 4, init 0):	RW	Enable bus master enable interrupt
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
static inline e10k_piena_t e10k_piena_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_piena_t e10k_piena_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x110b8));
}

static inline e10k_piena_t e10k_piena_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_piena_t e10k_piena_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x110b8));
}

static inline void e10k_piena_rawwr(__DN(t) *_dev, e10k_piena_t _regval) __attribute__ ((always_inline));
static inline void e10k_piena_rawwr(__DN(t) *_dev, e10k_piena_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x110b8, _regval);
}

static inline void e10k_piena_wr(__DN(t) *_dev, e10k_piena_t _regval) __attribute__ ((always_inline));
static inline void e10k_piena_wr(__DN(t) *_dev, e10k_piena_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x110b8)));
    mackerel_write_addr_32(_dev->base, 0x110b8, _regval);
}

static inline int e10k_piena_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_piena_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_piena_t _regval = mackerel_read_addr_32(_dev->base, 0x110b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register piena (PCIe Interrupt Enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ca =\t%" PRIx8 "\t(Enable PCI completion abort interrupt)\n", e10k_piena_ca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ua =\t%" PRIx8 "\t(Enable unsupported I/O address interrupt)\n", e10k_piena_ua_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " be =\t%" PRIx8 "\t(Enable wrong byte-enable interrupt)\n", e10k_piena_be_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " to =\t%" PRIx8 "\t(Enable PCI timeout interrupt)\n", e10k_piena_to_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bmef =\t%" PRIx8 "\t(Enable bus master enable interrupt)\n", e10k_piena_bmef_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t e10k_piena_ca_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_ca_rdf(__DN(t) *_dev)
{
    e10k_piena_t _regval = mackerel_read_addr_32(_dev->base, 0x110b8);
    return(e10k_piena_ca_extract(_regval));
}

static inline uint8_t e10k_piena_ua_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_ua_rdf(__DN(t) *_dev)
{
    e10k_piena_t _regval = mackerel_read_addr_32(_dev->base, 0x110b8);
    return(e10k_piena_ua_extract(_regval));
}

static inline uint8_t e10k_piena_be_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_be_rdf(__DN(t) *_dev)
{
    e10k_piena_t _regval = mackerel_read_addr_32(_dev->base, 0x110b8);
    return(e10k_piena_be_extract(_regval));
}

static inline uint8_t e10k_piena_to_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_to_rdf(__DN(t) *_dev)
{
    e10k_piena_t _regval = mackerel_read_addr_32(_dev->base, 0x110b8);
    return(e10k_piena_to_extract(_regval));
}

static inline uint8_t e10k_piena_bmef_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_piena_bmef_rdf(__DN(t) *_dev)
{
    e10k_piena_t _regval = mackerel_read_addr_32(_dev->base, 0x110b8);
    return(e10k_piena_bmef_extract(_regval));
}

static inline void e10k_piena_ca_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_piena_ca_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_piena_t _regval = 0x1 & (((e10k_piena_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x110b8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b8, _regval);
    // No shadow register to write to
}

static inline void e10k_piena_ua_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_piena_ua_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_piena_t _regval = 0x2 & (((e10k_piena_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x110b8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b8, _regval);
    // No shadow register to write to
}

static inline void e10k_piena_be_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_piena_be_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_piena_t _regval = 0x4 & (((e10k_piena_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x110b8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b8, _regval);
    // No shadow register to write to
}

static inline void e10k_piena_to_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_piena_to_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_piena_t _regval = 0x8 & (((e10k_piena_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x110b8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b8, _regval);
    // No shadow register to write to
}

static inline void e10k_piena_bmef_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_piena_bmef_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_piena_t _regval = 0x10 & (((e10k_piena_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x110b8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110b8, _regval);
    // No shadow register to write to
}

/*
 * Register eicr: Extended Interrupt Cause Register
 * Type: e10k.eicr (Implicit type of Extended Interrupt Cause Register register)
 *   rtxq	(size 16, offset 0, init 0):	RWC	Receive/Transmit Queue Interrupts
 *   flow_dir	(size 1, offset 16, init 0):	RWC	Flow Director Exception
 *   rx_miss	(size 1, offset 17, init 0):	RWC	Rx Miss
 *   pci_ex	(size 1, offset 18, init 0):	RWC	PCI Timeout Exception
 *   mailbox	(size 1, offset 19, init 0):	RWC	VF to PF MailBox Interrupt
 *   lsc	(size 1, offset 20, init 0):	RWC	Link Status Change
 *   linksec	(size 1, offset 21, init 0):	RWC	LinkSec
 *   mng	(size 1, offset 22, init 0):	RWC	Manageability Event Detected
 *   _anon23	(size 1, offset 23, init 0):	RSVD	_
 *   gpi_spd0	(size 1, offset 24, init 0):	RWC	General Purpose Interrupt on SDP0
 *   gpi_spd1	(size 1, offset 25, init 0):	RWC	General Purpose Interrupt on SDP1
 *   gpi_spd2	(size 1, offset 26, init 0):	RWC	General Purpose Interrupt on SDP2
 *   gpi_spd3	(size 1, offset 27, init 0):	RWC	General Purpose Interrupt on SDP3
 *   ecc	(size 1, offset 28, init 0):	RWC	Unrecoverable ECC Error
 *   _anon29	(size 1, offset 29, init 0):	RSVD	_
 *   tcp_timer	(size 1, offset 30, init 0):	RWC	TCP Timer Expired
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_eicr_t e10k_eicr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x800));
}

static inline e10k_eicr_t e10k_eicr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eicr_t e10k_eicr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x800));
}

static inline void e10k_eicr_rawwr(__DN(t) *_dev, e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline void e10k_eicr_rawwr(__DN(t) *_dev, e10k_eicr_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
}

static inline void e10k_eicr_wr(__DN(t) *_dev, e10k_eicr_t _regval) __attribute__ ((always_inline));
static inline void e10k_eicr_wr(__DN(t) *_dev, e10k_eicr_t _regval)
{
    _regval = (_regval & 0x5f7fffff);
    // No MB1 fields present
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
}

static inline int e10k_eicr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eicr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eicr (Extended Interrupt Cause Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtxq =\t%" PRIx16 "\t(Receive/Transmit Queue Interrupts)\n", e10k_eicr_rtxq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flow_dir =\t%" PRIx8 "\t(Flow Director Exception)\n", e10k_eicr_flow_dir_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_miss =\t%" PRIx8 "\t(Rx Miss)\n", e10k_eicr_rx_miss_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pci_ex =\t%" PRIx8 "\t(PCI Timeout Exception)\n", e10k_eicr_pci_ex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mailbox =\t%" PRIx8 "\t(VF to PF MailBox Interrupt)\n", e10k_eicr_mailbox_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsc =\t%" PRIx8 "\t(Link Status Change)\n", e10k_eicr_lsc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " linksec =\t%" PRIx8 "\t(LinkSec)\n", e10k_eicr_linksec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mng =\t%" PRIx8 "\t(Manageability Event Detected)\n", e10k_eicr_mng_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_spd0 =\t%" PRIx8 "\t(General Purpose Interrupt on SDP0)\n", e10k_eicr_gpi_spd0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_spd1 =\t%" PRIx8 "\t(General Purpose Interrupt on SDP1)\n", e10k_eicr_gpi_spd1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_spd2 =\t%" PRIx8 "\t(General Purpose Interrupt on SDP2)\n", e10k_eicr_gpi_spd2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gpi_spd3 =\t%" PRIx8 "\t(General Purpose Interrupt on SDP3)\n", e10k_eicr_gpi_spd3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ecc =\t%" PRIx8 "\t(Unrecoverable ECC Error)\n", e10k_eicr_ecc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_timer =\t%" PRIx8 "\t(TCP Timer Expired)\n", e10k_eicr_tcp_timer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint16_t e10k_eicr_rtxq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_eicr_rtxq_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_rtxq_extract(_regval));
}

static inline uint8_t e10k_eicr_flow_dir_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_flow_dir_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_flow_dir_extract(_regval));
}

static inline uint8_t e10k_eicr_rx_miss_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_rx_miss_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_rx_miss_extract(_regval));
}

static inline uint8_t e10k_eicr_pci_ex_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_pci_ex_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_pci_ex_extract(_regval));
}

static inline uint8_t e10k_eicr_mailbox_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_mailbox_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_mailbox_extract(_regval));
}

static inline uint8_t e10k_eicr_lsc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_lsc_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_lsc_extract(_regval));
}

static inline uint8_t e10k_eicr_linksec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_linksec_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_linksec_extract(_regval));
}

static inline uint8_t e10k_eicr_mng_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_mng_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_mng_extract(_regval));
}

static inline uint8_t e10k_eicr_gpi_spd0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_gpi_spd0_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_gpi_spd0_extract(_regval));
}

static inline uint8_t e10k_eicr_gpi_spd1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_gpi_spd1_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_gpi_spd1_extract(_regval));
}

static inline uint8_t e10k_eicr_gpi_spd2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_gpi_spd2_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_gpi_spd2_extract(_regval));
}

static inline uint8_t e10k_eicr_gpi_spd3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_gpi_spd3_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_gpi_spd3_extract(_regval));
}

static inline uint8_t e10k_eicr_ecc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_ecc_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_ecc_extract(_regval));
}

static inline uint8_t e10k_eicr_tcp_timer_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eicr_tcp_timer_rdf(__DN(t) *_dev)
{
    e10k_eicr_t _regval = mackerel_read_addr_32(_dev->base, 0x800);
    return(e10k_eicr_tcp_timer_extract(_regval));
}

static inline void e10k_eicr_rtxq_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_rtxq_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_eicr_t _regval = 0xffff & (((e10k_eicr_t )(_fieldval)) << 0);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_flow_dir_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_flow_dir_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x10000 & (((e10k_eicr_t )(_fieldval)) << 16);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_rx_miss_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_rx_miss_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x20000 & (((e10k_eicr_t )(_fieldval)) << 17);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_pci_ex_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_pci_ex_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x40000 & (((e10k_eicr_t )(_fieldval)) << 18);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_mailbox_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_mailbox_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x80000 & (((e10k_eicr_t )(_fieldval)) << 19);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_lsc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x100000 & (((e10k_eicr_t )(_fieldval)) << 20);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_linksec_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_linksec_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x200000 & (((e10k_eicr_t )(_fieldval)) << 21);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_mng_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_mng_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x400000 & (((e10k_eicr_t )(_fieldval)) << 22);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_gpi_spd0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_gpi_spd0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x1000000 & (((e10k_eicr_t )(_fieldval)) << 24);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_gpi_spd1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_gpi_spd1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x2000000 & (((e10k_eicr_t )(_fieldval)) << 25);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_gpi_spd2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_gpi_spd2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x4000000 & (((e10k_eicr_t )(_fieldval)) << 26);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_gpi_spd3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_gpi_spd3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x8000000 & (((e10k_eicr_t )(_fieldval)) << 27);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_ecc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_ecc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x10000000 & (((e10k_eicr_t )(_fieldval)) << 28);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

static inline void e10k_eicr_tcp_timer_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicr_tcp_timer_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eicr_t _regval = 0x40000000 & (((e10k_eicr_t )(_fieldval)) << 30);
    _regval = (_regval | (0xa0800000 & mackerel_read_addr_32(_dev->base, 0x800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x800, _regval);
    // No shadow register to write to
}

/*
 * Register eics: Extended Interrupt Cause Set Register
 * Type: e10k.eics (Implicit type of Extended Interrupt Cause Set Register register)
 *   cause	(size 31, offset 0, init 0):	WO	Interrupt Cause Set
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_eics_t e10k_eics_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eics_t e10k_eics_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x808));
}

static inline e10k_eics_t e10k_eics_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eics_t e10k_eics_rd(__DN(t) *_dev)
{
    return(_dev->eics_shadow);
}

static inline void e10k_eics_rawwr(__DN(t) *_dev, e10k_eics_t _regval) __attribute__ ((always_inline));
static inline void e10k_eics_rawwr(__DN(t) *_dev, e10k_eics_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x808, _regval);
}

static inline void e10k_eics_wr(__DN(t) *_dev, e10k_eics_t _regval) __attribute__ ((always_inline));
static inline void e10k_eics_wr(__DN(t) *_dev, e10k_eics_t _regval)
{
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x808)));
    mackerel_write_addr_32(_dev->base, 0x808, _regval);
}

static inline int e10k_eics_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eics_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eics_t _regval = _dev->eics_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eics (Extended Interrupt Cause Set Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Cause Set)\n", e10k_eics_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint32_t e10k_eics_cause_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_eics_cause_rd_shadow(__DN(t) *_dev)
{
    return(e10k_eics_cause_extract(_dev->eics_shadow));
}

static inline void e10k_eics_cause_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eics_cause_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_eics_t _regval = 0x7fffffff & (((e10k_eics_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x808)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x808, _regval);
    _dev->eics_shadow = _regval;
}

/*
 * Register eims: Extended Interrupt Mask Set/Read Register
 * Type: e10k.eims (Implicit type of Extended Interrupt Mask Set/Read Register register)
 *   cause	(size 31, offset 0, init 0):	RWS	Interrupt Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_eims_t e10k_eims_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eims_t e10k_eims_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x880));
}

static inline e10k_eims_t e10k_eims_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eims_t e10k_eims_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x880));
}

static inline void e10k_eims_rawwr(__DN(t) *_dev, e10k_eims_t _regval) __attribute__ ((always_inline));
static inline void e10k_eims_rawwr(__DN(t) *_dev, e10k_eims_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x880, _regval);
}

static inline void e10k_eims_wr(__DN(t) *_dev, e10k_eims_t _regval) __attribute__ ((always_inline));
static inline void e10k_eims_wr(__DN(t) *_dev, e10k_eims_t _regval)
{
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x880)));
    mackerel_write_addr_32(_dev->base, 0x880, _regval);
}

static inline int e10k_eims_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eims_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eims_t _regval = mackerel_read_addr_32(_dev->base, 0x880);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eims (Extended Interrupt Mask Set/Read Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Enable)\n", e10k_eims_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint32_t e10k_eims_cause_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_eims_cause_rdf(__DN(t) *_dev)
{
    e10k_eims_t _regval = mackerel_read_addr_32(_dev->base, 0x880);
    return(e10k_eims_cause_extract(_regval));
}

static inline void e10k_eims_cause_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eims_cause_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_eims_t _regval = 0x7fffffff & (((e10k_eims_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x880)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x880, _regval);
    // No shadow register to write to
}

/*
 * Register eimc: Extended Interrupt Mask Clear Register
 * Type: e10k.eimc (Implicit type of Extended Interrupt Mask Clear Register register)
 *   cause	(size 31, offset 0, init 0):	WO	Interrupt Mask
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_eimc_t e10k_eimc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eimc_t e10k_eimc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x888));
}

static inline e10k_eimc_t e10k_eimc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eimc_t e10k_eimc_rd(__DN(t) *_dev)
{
    return(_dev->eimc_shadow);
}

static inline void e10k_eimc_rawwr(__DN(t) *_dev, e10k_eimc_t _regval) __attribute__ ((always_inline));
static inline void e10k_eimc_rawwr(__DN(t) *_dev, e10k_eimc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x888, _regval);
}

static inline void e10k_eimc_wr(__DN(t) *_dev, e10k_eimc_t _regval) __attribute__ ((always_inline));
static inline void e10k_eimc_wr(__DN(t) *_dev, e10k_eimc_t _regval)
{
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x888)));
    mackerel_write_addr_32(_dev->base, 0x888, _regval);
}

static inline int e10k_eimc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eimc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eimc_t _regval = _dev->eimc_shadow;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eimc (Extended Interrupt Mask Clear Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Mask)\n", e10k_eimc_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint32_t e10k_eimc_cause_rd_shadow(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_eimc_cause_rd_shadow(__DN(t) *_dev)
{
    return(e10k_eimc_cause_extract(_dev->eimc_shadow));
}

static inline void e10k_eimc_cause_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eimc_cause_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_eimc_t _regval = 0x7fffffff & (((e10k_eimc_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x888)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x888, _regval);
    _dev->eimc_shadow = _regval;
}

/*
 * Register eiac: Extended Interrupt Auto Clear Register
 * Type: e10k.eiac (Implicit type of Extended Interrupt Auto Clear Register register)
 *   rtxq	(size 16, offset 0, init 0):	RW	RTxQ Auto Clear
 *   _anon16	(size 14, offset 16, init 0):	RSVD	_
 *   tcp_timer	(size 1, offset 30, init 0):	RW	TCP Timer Auto Clear
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_eiac_t e10k_eiac_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eiac_t e10k_eiac_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x810));
}

static inline e10k_eiac_t e10k_eiac_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eiac_t e10k_eiac_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x810));
}

static inline void e10k_eiac_rawwr(__DN(t) *_dev, e10k_eiac_t _regval) __attribute__ ((always_inline));
static inline void e10k_eiac_rawwr(__DN(t) *_dev, e10k_eiac_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x810, _regval);
}

static inline void e10k_eiac_wr(__DN(t) *_dev, e10k_eiac_t _regval) __attribute__ ((always_inline));
static inline void e10k_eiac_wr(__DN(t) *_dev, e10k_eiac_t _regval)
{
    _regval = (_regval & 0x4000ffff);
    // No MB1 fields present
    _regval = (_regval | (0xbfff0000 & mackerel_read_addr_32(_dev->base, 0x810)));
    mackerel_write_addr_32(_dev->base, 0x810, _regval);
}

static inline int e10k_eiac_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eiac_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eiac_t _regval = mackerel_read_addr_32(_dev->base, 0x810);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eiac (Extended Interrupt Auto Clear Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rtxq =\t%" PRIx16 "\t(RTxQ Auto Clear)\n", e10k_eiac_rtxq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_timer =\t%" PRIx8 "\t(TCP Timer Auto Clear)\n", e10k_eiac_tcp_timer_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint16_t e10k_eiac_rtxq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_eiac_rtxq_rdf(__DN(t) *_dev)
{
    e10k_eiac_t _regval = mackerel_read_addr_32(_dev->base, 0x810);
    return(e10k_eiac_rtxq_extract(_regval));
}

static inline uint8_t e10k_eiac_tcp_timer_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_eiac_tcp_timer_rdf(__DN(t) *_dev)
{
    e10k_eiac_t _regval = mackerel_read_addr_32(_dev->base, 0x810);
    return(e10k_eiac_tcp_timer_extract(_regval));
}

static inline void e10k_eiac_rtxq_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eiac_rtxq_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_eiac_t _regval = 0xffff & (((e10k_eiac_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x810)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x810, _regval);
    // No shadow register to write to
}

static inline void e10k_eiac_tcp_timer_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eiac_tcp_timer_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_eiac_t _regval = 0x40000000 & (((e10k_eiac_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x810)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x810, _regval);
    // No shadow register to write to
}

/*
 * Register eiam: Extended Interrupt Auto Mask Enable Register
 * Type: e10k.eiam (Implicit type of Extended Interrupt Auto Mask Enable Register register)
 *   cause	(size 31, offset 0, init 0):	RW	Auto Mask
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_eiam_t e10k_eiam_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eiam_t e10k_eiam_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x890));
}

static inline e10k_eiam_t e10k_eiam_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eiam_t e10k_eiam_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x890));
}

static inline void e10k_eiam_rawwr(__DN(t) *_dev, e10k_eiam_t _regval) __attribute__ ((always_inline));
static inline void e10k_eiam_rawwr(__DN(t) *_dev, e10k_eiam_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x890, _regval);
}

static inline void e10k_eiam_wr(__DN(t) *_dev, e10k_eiam_t _regval) __attribute__ ((always_inline));
static inline void e10k_eiam_wr(__DN(t) *_dev, e10k_eiam_t _regval)
{
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x890)));
    mackerel_write_addr_32(_dev->base, 0x890, _regval);
}

static inline int e10k_eiam_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eiam_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eiam_t _regval = mackerel_read_addr_32(_dev->base, 0x890);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eiam (Extended Interrupt Auto Mask Enable Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Auto Mask)\n", e10k_eiam_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint32_t e10k_eiam_cause_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_eiam_cause_rdf(__DN(t) *_dev)
{
    e10k_eiam_t _regval = mackerel_read_addr_32(_dev->base, 0x890);
    return(e10k_eiam_cause_extract(_regval));
}

static inline void e10k_eiam_cause_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eiam_cause_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_eiam_t _regval = 0x7fffffff & (((e10k_eiam_t )(_fieldval)) << 0);
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x890)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x890, _regval);
    // No shadow register to write to
}

/*
 * Register array eicsn: Extended Interrupt Cause Set Registers
 * Type: e10k.eicsn (Implicit type of Extended Interrupt Cause Set Registers register array)
 *   cause	(size 32, offset 0, init 0):	WO	Interrupt Cause Set
 */
static const size_t e10k_eicsn_length = 2;
static inline e10k_eicsn_t e10k_eicsn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eicsn_t e10k_eicsn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa90 + (_i * (32 / 8))));
}

static inline e10k_eicsn_t e10k_eicsn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eicsn_t e10k_eicsn_rd(__DN(t) *_dev, int _i)
{
    return((_dev->eicsn_shadow)[_i]);
}

static inline void e10k_eicsn_rawwr(__DN(t) *_dev, int _i, e10k_eicsn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eicsn_rawwr(__DN(t) *_dev, int _i, e10k_eicsn_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa90 + (_i * (32 / 8)), _regval);
}

static inline void e10k_eicsn_wr(__DN(t) *_dev, int _i, e10k_eicsn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eicsn_wr(__DN(t) *_dev, int _i, e10k_eicsn_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa90 + (_i * (32 / 8)), _regval);
}

static inline int e10k_eicsn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_eicsn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eicsn_t _regval = (_dev->eicsn_shadow)[_i];
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "eicsn", _i, "Extended Interrupt Cause Set Registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Cause Set)\n", e10k_eicsn_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_eicsn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eicsn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_eicsn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_eicsn_cause_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_eicsn_cause_rd_shadow(__DN(t) *_dev, int _i)
{
    return(e10k_eicsn_cause_extract((_dev->eicsn_shadow)[_i]));
}

static inline void e10k_eicsn_cause_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eicsn_cause_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_eicsn_t _regval = 0xffffffff & (((e10k_eicsn_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa90 + (_i * (32 / 8)), _regval);
    (_dev->eicsn_shadow)[_i] = _regval;
}

/*
 * Register array eimsn: Extended Interrupt Mask Set/Read Registers
 * Type: e10k.eimsn (Implicit type of Extended Interrupt Mask Set/Read Registers register array)
 *   cause	(size 32, offset 0, init 0):	RWS	Interrupt Enable
 */
static const size_t e10k_eimsn_length = 2;
static inline e10k_eimsn_t e10k_eimsn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eimsn_t e10k_eimsn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xaa0 + (_i * (32 / 8))));
}

static inline e10k_eimsn_t e10k_eimsn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eimsn_t e10k_eimsn_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xaa0 + (_i * (32 / 8))));
}

static inline void e10k_eimsn_rawwr(__DN(t) *_dev, int _i, e10k_eimsn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eimsn_rawwr(__DN(t) *_dev, int _i, e10k_eimsn_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xaa0 + (_i * (32 / 8)), _regval);
}

static inline void e10k_eimsn_wr(__DN(t) *_dev, int _i, e10k_eimsn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eimsn_wr(__DN(t) *_dev, int _i, e10k_eimsn_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xaa0 + (_i * (32 / 8)), _regval);
}

static inline int e10k_eimsn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_eimsn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eimsn_t _regval = mackerel_read_addr_32(_dev->base, 0xaa0 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "eimsn", _i, "Extended Interrupt Mask Set/Read Registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Enable)\n", e10k_eimsn_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_eimsn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eimsn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_eimsn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_eimsn_cause_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_eimsn_cause_rdf(__DN(t) *_dev, int _i)
{
    e10k_eimsn_t _regval = mackerel_read_addr_32(_dev->base, 0xaa0 + (_i * (32 / 8)));
    return(e10k_eimsn_cause_extract(_regval));
}

static inline void e10k_eimsn_cause_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eimsn_cause_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_eimsn_t _regval = 0xffffffff & (((e10k_eimsn_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xaa0 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array eimcn: Extended Interrupt Mask Clear Registers
 * Type: e10k.eimcn (Implicit type of Extended Interrupt Mask Clear Registers register array)
 *   cause	(size 32, offset 0, init 0):	WO	Interrupt Mask
 */
static const size_t e10k_eimcn_length = 2;
static inline e10k_eimcn_t e10k_eimcn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eimcn_t e10k_eimcn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xab0 + (_i * (32 / 8))));
}

static inline e10k_eimcn_t e10k_eimcn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eimcn_t e10k_eimcn_rd(__DN(t) *_dev, int _i)
{
    return((_dev->eimcn_shadow)[_i]);
}

static inline void e10k_eimcn_rawwr(__DN(t) *_dev, int _i, e10k_eimcn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eimcn_rawwr(__DN(t) *_dev, int _i, e10k_eimcn_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xab0 + (_i * (32 / 8)), _regval);
}

static inline void e10k_eimcn_wr(__DN(t) *_dev, int _i, e10k_eimcn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eimcn_wr(__DN(t) *_dev, int _i, e10k_eimcn_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xab0 + (_i * (32 / 8)), _regval);
}

static inline int e10k_eimcn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_eimcn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eimcn_t _regval = (_dev->eimcn_shadow)[_i];
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "eimcn", _i, "Extended Interrupt Mask Clear Registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Interrupt Mask)\n", e10k_eimcn_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_eimcn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eimcn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_eimcn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_eimcn_cause_rd_shadow(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_eimcn_cause_rd_shadow(__DN(t) *_dev, int _i)
{
    return(e10k_eimcn_cause_extract((_dev->eimcn_shadow)[_i]));
}

static inline void e10k_eimcn_cause_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eimcn_cause_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_eimcn_t _regval = 0xffffffff & (((e10k_eimcn_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xab0 + (_i * (32 / 8)), _regval);
    (_dev->eimcn_shadow)[_i] = _regval;
}

/*
 * Register array eiamn: Extended Interrupt Auto Mask Enable registers
 * Type: e10k.eiamn (Implicit type of Extended Interrupt Auto Mask Enable registers register array)
 *   cause	(size 32, offset 0, init 0):	RW	Auto Mask
 */
static const size_t e10k_eiamn_length = 2;
static inline e10k_eiamn_t e10k_eiamn_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eiamn_t e10k_eiamn_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xad0 + (_i * (32 / 8))));
}

static inline e10k_eiamn_t e10k_eiamn_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eiamn_t e10k_eiamn_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xad0 + (_i * (32 / 8))));
}

static inline void e10k_eiamn_rawwr(__DN(t) *_dev, int _i, e10k_eiamn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eiamn_rawwr(__DN(t) *_dev, int _i, e10k_eiamn_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xad0 + (_i * (32 / 8)), _regval);
}

static inline void e10k_eiamn_wr(__DN(t) *_dev, int _i, e10k_eiamn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eiamn_wr(__DN(t) *_dev, int _i, e10k_eiamn_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xad0 + (_i * (32 / 8)), _regval);
}

static inline int e10k_eiamn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_eiamn_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eiamn_t _regval = mackerel_read_addr_32(_dev->base, 0xad0 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "eiamn", _i, "Extended Interrupt Auto Mask Enable registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cause =\t%" PRIx32 "\t(Auto Mask)\n", e10k_eiamn_cause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_eiamn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eiamn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 2; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_eiamn_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_eiamn_cause_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_eiamn_cause_rdf(__DN(t) *_dev, int _i)
{
    e10k_eiamn_t _regval = mackerel_read_addr_32(_dev->base, 0xad0 + (_i * (32 / 8)));
    return(e10k_eiamn_cause_extract(_regval));
}

static inline void e10k_eiamn_cause_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eiamn_cause_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_eiamn_t _regval = 0xffffffff & (((e10k_eiamn_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xad0 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register eitrsel: MSIX to EITR Select
 * Type: e10k.eitrsel (Implicit type of MSIX to EITR Select register)
 *   vfselect	(size 32, offset 0, init 0):	RW	VFSelect
 */
static inline e10k_eitrsel_t e10k_eitrsel_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eitrsel_t e10k_eitrsel_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x894));
}

static inline e10k_eitrsel_t e10k_eitrsel_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_eitrsel_t e10k_eitrsel_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x894));
}

static inline void e10k_eitrsel_rawwr(__DN(t) *_dev, e10k_eitrsel_t _regval) __attribute__ ((always_inline));
static inline void e10k_eitrsel_rawwr(__DN(t) *_dev, e10k_eitrsel_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x894, _regval);
}

static inline void e10k_eitrsel_wr(__DN(t) *_dev, e10k_eitrsel_t _regval) __attribute__ ((always_inline));
static inline void e10k_eitrsel_wr(__DN(t) *_dev, e10k_eitrsel_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x894, _regval);
}

static inline int e10k_eitrsel_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eitrsel_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eitrsel_t _regval = mackerel_read_addr_32(_dev->base, 0x894);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register eitrsel (MSIX to EITR Select): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vfselect =\t%" PRIx32 "\t(VFSelect)\n", e10k_eitrsel_vfselect_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_eitrsel_vfselect_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_eitrsel_vfselect_rdf(__DN(t) *_dev)
{
    e10k_eitrsel_t _regval = mackerel_read_addr_32(_dev->base, 0x894);
    return(e10k_eitrsel_vfselect_extract(_regval));
}

static inline void e10k_eitrsel_vfselect_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitrsel_vfselect_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_eitrsel_t _regval = 0xffffffff & (((e10k_eitrsel_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x894, _regval);
    // No shadow register to write to
}

/*
 * Register array eitr_l: Extended Interrupt Throttle Registers #0-#23
 * Type: e10k.eitrn (Extended Interrupt Throttle Register Type)
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   itr_int	(size 9, offset 3, init 0):	RW	Minimum inter-interrupt interval
 *   _anon12	(size 3, offset 12, init 0):	RSVD	_
 *   lli_mod	(size 1, offset 15, init 0):	RW	LLI Moderation
 *   lli_credit	(size 5, offset 16, init 0):	RW	LLI Credit
 *   itr_count	(size 7, offset 21, init 0):	RW	ITR Counter
 *   _anon28	(size 3, offset 28, init 0):	RSVD	_
 *   cnt_wdis	(size 1, offset 31, init 0):	RW	CNT_WDIS
 */
static const size_t e10k_eitr_l_length = 24;
static inline e10k_eitrn_t e10k_eitr_l_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitr_l_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8))));
}

static inline e10k_eitrn_t e10k_eitr_l_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitr_l_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8))));
}

static inline void e10k_eitr_l_rawwr(__DN(t) *_dev, int _i, e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eitr_l_rawwr(__DN(t) *_dev, int _i, e10k_eitrn_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
}

static inline void e10k_eitr_l_wr(__DN(t) *_dev, int _i, e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eitr_l_wr(__DN(t) *_dev, int _i, e10k_eitrn_t _regval)
{
    _regval = (_regval & 0x8fff8ff8);
    // No MB1 fields present
    _regval = (_regval | (0x70007007 & mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
}

static inline int e10k_eitr_l_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_eitr_l_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "eitr_l", _i, "Extended Interrupt Throttle Registers #0-#23");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itr_int =\t%" PRIx16 "\t(Minimum inter-interrupt interval)\n", e10k_eitrn_itr_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli_mod =\t%" PRIx8 "\t(LLI Moderation)\n", e10k_eitrn_lli_mod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli_credit =\t%" PRIx8 "\t(LLI Credit)\n", e10k_eitrn_lli_credit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itr_count =\t%" PRIx8 "\t(ITR Counter)\n", e10k_eitrn_itr_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cnt_wdis =\t%" PRIx8 "\t(CNT_WDIS)\n", e10k_eitrn_cnt_wdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_eitr_l_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eitr_l_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 24; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_eitr_l_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_eitr_l_itr_int_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_eitr_l_itr_int_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)));
    return(e10k_eitrn_itr_int_extract(_regval));
}

static inline uint8_t e10k_eitr_l_lli_mod_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_eitr_l_lli_mod_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)));
    return(e10k_eitrn_lli_mod_extract(_regval));
}

static inline uint8_t e10k_eitr_l_lli_credit_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_eitr_l_lli_credit_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)));
    return(e10k_eitrn_lli_credit_extract(_regval));
}

static inline uint8_t e10k_eitr_l_itr_count_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_eitr_l_itr_count_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)));
    return(e10k_eitrn_itr_count_extract(_regval));
}

static inline uint8_t e10k_eitr_l_cnt_wdis_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_eitr_l_cnt_wdis_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)));
    return(e10k_eitrn_cnt_wdis_extract(_regval));
}

static inline void e10k_eitr_l_itr_int_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_l_itr_int_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_eitrn_t _regval = 0xff8 & (((e10k_eitrn_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffff007 & mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_eitr_l_lli_mod_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_l_lli_mod_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_eitrn_t _regval = 0x8000 & (((e10k_eitrn_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_eitr_l_lli_credit_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_l_lli_credit_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_eitrn_t _regval = 0x1f0000 & (((e10k_eitrn_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffe0ffff & mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_eitr_l_itr_count_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_l_itr_count_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_eitrn_t _regval = 0xfe00000 & (((e10k_eitrn_t )(_fieldval)) << 21);
    _regval = (_regval | (0xf01fffff & mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_eitr_l_cnt_wdis_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_l_cnt_wdis_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_eitrn_t _regval = 0x80000000 & (((e10k_eitrn_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x820 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x820 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array eitr_h: Extended Interrupt Throttle Registers #24-#128
 * Type: e10k.eitrn (Extended Interrupt Throttle Register Type)
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   itr_int	(size 9, offset 3, init 0):	RW	Minimum inter-interrupt interval
 *   _anon12	(size 3, offset 12, init 0):	RSVD	_
 *   lli_mod	(size 1, offset 15, init 0):	RW	LLI Moderation
 *   lli_credit	(size 5, offset 16, init 0):	RW	LLI Credit
 *   itr_count	(size 7, offset 21, init 0):	RW	ITR Counter
 *   _anon28	(size 3, offset 28, init 0):	RSVD	_
 *   cnt_wdis	(size 1, offset 31, init 0):	RW	CNT_WDIS
 */
static const size_t e10k_eitr_h_length = 104;
static inline e10k_eitrn_t e10k_eitr_h_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitr_h_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8))));
}

static inline e10k_eitrn_t e10k_eitr_h_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_eitrn_t e10k_eitr_h_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8))));
}

static inline void e10k_eitr_h_rawwr(__DN(t) *_dev, int _i, e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eitr_h_rawwr(__DN(t) *_dev, int _i, e10k_eitrn_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)), _regval);
}

static inline void e10k_eitr_h_wr(__DN(t) *_dev, int _i, e10k_eitrn_t _regval) __attribute__ ((always_inline));
static inline void e10k_eitr_h_wr(__DN(t) *_dev, int _i, e10k_eitrn_t _regval)
{
    _regval = (_regval & 0x8fff8ff8);
    // No MB1 fields present
    _regval = (_regval | (0x70007007 & mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)), _regval);
}

static inline int e10k_eitr_h_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_eitr_h_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "eitr_h", _i, "Extended Interrupt Throttle Registers #24-#128");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itr_int =\t%" PRIx16 "\t(Minimum inter-interrupt interval)\n", e10k_eitrn_itr_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli_mod =\t%" PRIx8 "\t(LLI Moderation)\n", e10k_eitrn_lli_mod_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli_credit =\t%" PRIx8 "\t(LLI Credit)\n", e10k_eitrn_lli_credit_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " itr_count =\t%" PRIx8 "\t(ITR Counter)\n", e10k_eitrn_itr_count_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cnt_wdis =\t%" PRIx8 "\t(CNT_WDIS)\n", e10k_eitrn_cnt_wdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_eitr_h_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_eitr_h_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 104; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_eitr_h_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_eitr_h_itr_int_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_eitr_h_itr_int_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)));
    return(e10k_eitrn_itr_int_extract(_regval));
}

static inline uint8_t e10k_eitr_h_lli_mod_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_eitr_h_lli_mod_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)));
    return(e10k_eitrn_lli_mod_extract(_regval));
}

static inline uint8_t e10k_eitr_h_lli_credit_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_eitr_h_lli_credit_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)));
    return(e10k_eitrn_lli_credit_extract(_regval));
}

static inline uint8_t e10k_eitr_h_itr_count_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_eitr_h_itr_count_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)));
    return(e10k_eitrn_itr_count_extract(_regval));
}

static inline uint8_t e10k_eitr_h_cnt_wdis_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_eitr_h_cnt_wdis_rdf(__DN(t) *_dev, int _i)
{
    e10k_eitrn_t _regval = mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)));
    return(e10k_eitrn_cnt_wdis_extract(_regval));
}

static inline void e10k_eitr_h_itr_int_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_h_itr_int_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_eitrn_t _regval = 0xff8 & (((e10k_eitrn_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffff007 & mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_eitr_h_lli_mod_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_h_lli_mod_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_eitrn_t _regval = 0x8000 & (((e10k_eitrn_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_eitr_h_lli_credit_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_h_lli_credit_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_eitrn_t _regval = 0x1f0000 & (((e10k_eitrn_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffe0ffff & mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_eitr_h_itr_count_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_h_itr_count_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_eitrn_t _regval = 0xfe00000 & (((e10k_eitrn_t )(_fieldval)) << 21);
    _regval = (_regval | (0xf01fffff & mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_eitr_h_cnt_wdis_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_eitr_h_cnt_wdis_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_eitrn_t _regval = 0x80000000 & (((e10k_eitrn_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x12300 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array l34timir: L3 L4 Tuples Immediate Interrupt Rx
 * Type: e10k.l34timir (Implicit type of L3 L4 Tuples Immediate Interrupt Rx register array)
 *   _anon0	(size 12, offset 0, init 0):	MBZ	_
 *   size_bp	(size 1, offset 12, init 0):	RW	Size Bypass
 *   _anon13	(size 6, offset 13, init 0):	MBZ	_
 *   _anon19	(size 1, offset 19, init 1):	MB1	_
 *   lli	(size 1, offset 20, init 0):	RW	Low Latency Interrupt
 *   rx_queue	(size 7, offset 21, init 0):	RW	Rx Queue
 *   _anon28	(size 4, offset 28, init 0):	MBZ	_
 */
static const size_t e10k_l34timir_length = 128;
static inline e10k_l34timir_t e10k_l34timir_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_l34timir_t e10k_l34timir_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8))));
}

static inline e10k_l34timir_t e10k_l34timir_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_l34timir_t e10k_l34timir_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8))));
}

static inline void e10k_l34timir_rawwr(__DN(t) *_dev, int _i, e10k_l34timir_t _regval) __attribute__ ((always_inline));
static inline void e10k_l34timir_rawwr(__DN(t) *_dev, int _i, e10k_l34timir_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)), _regval);
}

static inline void e10k_l34timir_wr(__DN(t) *_dev, int _i, e10k_l34timir_t _regval) __attribute__ ((always_inline));
static inline void e10k_l34timir_wr(__DN(t) *_dev, int _i, e10k_l34timir_t _regval)
{
    _regval = (_regval & 0xff81000);
    _regval = (_regval | 0x80000);
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)), _regval);
}

static inline int e10k_l34timir_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_l34timir_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_l34timir_t _regval = mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "l34timir", _i, "L3 L4 Tuples Immediate Interrupt Rx");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size_bp =\t%" PRIx8 "\t(Size Bypass)\n", e10k_l34timir_size_bp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli =\t%" PRIx8 "\t(Low Latency Interrupt)\n", e10k_l34timir_lli_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_queue =\t%" PRIx8 "\t(Rx Queue)\n", e10k_l34timir_rx_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline int e10k_l34timir_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_l34timir_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_l34timir_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_l34timir_size_bp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_l34timir_size_bp_rdf(__DN(t) *_dev, int _i)
{
    e10k_l34timir_t _regval = mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)));
    return(e10k_l34timir_size_bp_extract(_regval));
}

static inline uint8_t e10k_l34timir_lli_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_l34timir_lli_rdf(__DN(t) *_dev, int _i)
{
    e10k_l34timir_t _regval = mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)));
    return(e10k_l34timir_lli_extract(_regval));
}

static inline uint8_t e10k_l34timir_rx_queue_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_l34timir_rx_queue_rdf(__DN(t) *_dev, int _i)
{
    e10k_l34timir_t _regval = mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)));
    return(e10k_l34timir_rx_queue_extract(_regval));
}

static inline void e10k_l34timir_size_bp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_l34timir_size_bp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_l34timir_t _regval = 0x1000 & (((e10k_l34timir_t )(_fieldval)) << 12);
    _regval = (_regval | (0xff00000 & mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xff81000);
    _regval = (_regval | 0x80000);
    mackerel_write_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_l34timir_lli_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_l34timir_lli_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_l34timir_t _regval = 0x100000 & (((e10k_l34timir_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfe01000 & mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xff81000);
    _regval = (_regval | 0x80000);
    mackerel_write_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_l34timir_rx_queue_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_l34timir_rx_queue_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_l34timir_t _regval = 0xfe00000 & (((e10k_l34timir_t )(_fieldval)) << 21);
    _regval = (_regval | (0x101000 & mackerel_read_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xff81000);
    _regval = (_regval | 0x80000);
    mackerel_write_addr_32(_dev->base, 0xe800 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register llithresh: LLI Size Threshol
 * Type: e10k.llithresh (Implicit type of LLI Size Threshol register)
 *   sz_thresh	(size 12, offset 0, init 0):	RW	Size Threshold
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
static inline e10k_llithresh_t e10k_llithresh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_llithresh_t e10k_llithresh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec90));
}

static inline e10k_llithresh_t e10k_llithresh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_llithresh_t e10k_llithresh_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec90));
}

static inline void e10k_llithresh_rawwr(__DN(t) *_dev, e10k_llithresh_t _regval) __attribute__ ((always_inline));
static inline void e10k_llithresh_rawwr(__DN(t) *_dev, e10k_llithresh_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xec90, _regval);
}

static inline void e10k_llithresh_wr(__DN(t) *_dev, e10k_llithresh_t _regval) __attribute__ ((always_inline));
static inline void e10k_llithresh_wr(__DN(t) *_dev, e10k_llithresh_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0xec90)));
    mackerel_write_addr_32(_dev->base, 0xec90, _regval);
}

static inline int e10k_llithresh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_llithresh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_llithresh_t _regval = mackerel_read_addr_32(_dev->base, 0xec90);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register llithresh (LLI Size Threshol): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sz_thresh =\t%" PRIx16 "\t(Size Threshold)\n", e10k_llithresh_sz_thresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline uint16_t e10k_llithresh_sz_thresh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_llithresh_sz_thresh_rdf(__DN(t) *_dev)
{
    e10k_llithresh_t _regval = mackerel_read_addr_32(_dev->base, 0xec90);
    return(e10k_llithresh_sz_thresh_extract(_regval));
}

static inline void e10k_llithresh_sz_thresh_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_llithresh_sz_thresh_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_llithresh_t _regval = 0xfff & (((e10k_llithresh_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0xec90)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec90, _regval);
    // No shadow register to write to
}

/*
 * Register imirvp: Immediate Interrupt Rx VLAN Priority Register
 * Type: e10k.imirvp (Implicit type of Immediate Interrupt Rx VLAN Priority Register register)
 *   vlan_pri	(size 3, offset 0, init 0):	RW	VLAN Priority
 *   vlan_pri_en	(size 1, offset 3, init 0):	RW	VLAN Priority Enable
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static inline e10k_imirvp_t e10k_imirvp_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_imirvp_t e10k_imirvp_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec60));
}

static inline e10k_imirvp_t e10k_imirvp_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_imirvp_t e10k_imirvp_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec60));
}

static inline void e10k_imirvp_rawwr(__DN(t) *_dev, e10k_imirvp_t _regval) __attribute__ ((always_inline));
static inline void e10k_imirvp_rawwr(__DN(t) *_dev, e10k_imirvp_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xec60, _regval);
}

static inline void e10k_imirvp_wr(__DN(t) *_dev, e10k_imirvp_t _regval) __attribute__ ((always_inline));
static inline void e10k_imirvp_wr(__DN(t) *_dev, e10k_imirvp_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0xec60)));
    mackerel_write_addr_32(_dev->base, 0xec60, _regval);
}

static inline int e10k_imirvp_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_imirvp_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_imirvp_t _regval = mackerel_read_addr_32(_dev->base, 0xec60);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register imirvp (Immediate Interrupt Rx VLAN Priority Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan_pri =\t%" PRIx8 "\t(VLAN Priority)\n", e10k_imirvp_vlan_pri_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan_pri_en =\t%" PRIx8 "\t(VLAN Priority Enable)\n", e10k_imirvp_vlan_pri_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t e10k_imirvp_vlan_pri_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_imirvp_vlan_pri_rdf(__DN(t) *_dev)
{
    e10k_imirvp_t _regval = mackerel_read_addr_32(_dev->base, 0xec60);
    return(e10k_imirvp_vlan_pri_extract(_regval));
}

static inline uint8_t e10k_imirvp_vlan_pri_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_imirvp_vlan_pri_en_rdf(__DN(t) *_dev)
{
    e10k_imirvp_t _regval = mackerel_read_addr_32(_dev->base, 0xec60);
    return(e10k_imirvp_vlan_pri_en_extract(_regval));
}

static inline void e10k_imirvp_vlan_pri_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_imirvp_vlan_pri_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_imirvp_t _regval = 0x7 & (((e10k_imirvp_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0xec60)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec60, _regval);
    // No shadow register to write to
}

static inline void e10k_imirvp_vlan_pri_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_imirvp_vlan_pri_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_imirvp_t _regval = 0x8 & (((e10k_imirvp_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0xec60)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec60, _regval);
    // No shadow register to write to
}

/*
 * Register array ivar: Interrupt Vector Allocation Registers
 * Type: e10k.ivar (Implicit type of Interrupt Vector Allocation Registers register array)
 *   i_alloc0	(size 6, offset 0, init 0):	RW	The interrupt allocation for Rx queue 2n
 *   _anon6	(size 1, offset 6, init 0):	RSVD	_
 *   i_allocval0	(size 1, offset 7, init 0):	RW	Interrupt allocation 0 valid
 *   i_alloc1	(size 6, offset 8, init 0):	RW	The interrupt allocation for Tx queue 2n
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   i_allocval1	(size 1, offset 15, init 0):	RW	Interrupt allocation 1 valid
 *   i_alloc2	(size 6, offset 16, init 0):	RW	The interrupt allocation for Rx queue 2n+1
 *   _anon22	(size 1, offset 22, init 0):	RSVD	_
 *   i_allocval2	(size 1, offset 23, init 0):	RW	Interrupt allocation 2 valid
 *   i_alloc3	(size 6, offset 24, init 0):	RW	The interrupt allocation for Tx queue 2n+1
 *   _anon30	(size 1, offset 30, init 0):	RSVD	_
 *   i_allocval3	(size 1, offset 31, init 0):	RW	Interrupt allocation 3 valid
 */
static const size_t e10k_ivar_length = 64;
static inline e10k_ivar_t e10k_ivar_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8))));
}

static inline e10k_ivar_t e10k_ivar_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_ivar_t e10k_ivar_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8))));
}

static inline void e10k_ivar_rawwr(__DN(t) *_dev, int _i, e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline void e10k_ivar_rawwr(__DN(t) *_dev, int _i, e10k_ivar_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
}

static inline void e10k_ivar_wr(__DN(t) *_dev, int _i, e10k_ivar_t _regval) __attribute__ ((always_inline));
static inline void e10k_ivar_wr(__DN(t) *_dev, int _i, e10k_ivar_t _regval)
{
    _regval = (_regval & 0xbfbfbfbf);
    // No MB1 fields present
    _regval = (_regval | (0x40404040 & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
}

static inline int e10k_ivar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_ivar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ivar", _i, "Interrupt Vector Allocation Registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc0 =\t%" PRIx8 "\t(The interrupt allocation for Rx queue 2n)\n", e10k_ivar_i_alloc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval0 =\t%" PRIx8 "\t(Interrupt allocation 0 valid)\n", e10k_ivar_i_allocval0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc1 =\t%" PRIx8 "\t(The interrupt allocation for Tx queue 2n)\n", e10k_ivar_i_alloc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval1 =\t%" PRIx8 "\t(Interrupt allocation 1 valid)\n", e10k_ivar_i_allocval1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc2 =\t%" PRIx8 "\t(The interrupt allocation for Rx queue 2n+1)\n", e10k_ivar_i_alloc2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval2 =\t%" PRIx8 "\t(Interrupt allocation 2 valid)\n", e10k_ivar_i_allocval2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc3 =\t%" PRIx8 "\t(The interrupt allocation for Tx queue 2n+1)\n", e10k_ivar_i_alloc3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval3 =\t%" PRIx8 "\t(Interrupt allocation 3 valid)\n", e10k_ivar_i_allocval3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_ivar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_ivar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_ivar_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_ivar_i_alloc0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_alloc0_rdf(__DN(t) *_dev, int _i)
{
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    return(e10k_ivar_i_alloc0_extract(_regval));
}

static inline uint8_t e10k_ivar_i_allocval0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_allocval0_rdf(__DN(t) *_dev, int _i)
{
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    return(e10k_ivar_i_allocval0_extract(_regval));
}

static inline uint8_t e10k_ivar_i_alloc1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_alloc1_rdf(__DN(t) *_dev, int _i)
{
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    return(e10k_ivar_i_alloc1_extract(_regval));
}

static inline uint8_t e10k_ivar_i_allocval1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_allocval1_rdf(__DN(t) *_dev, int _i)
{
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    return(e10k_ivar_i_allocval1_extract(_regval));
}

static inline uint8_t e10k_ivar_i_alloc2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_alloc2_rdf(__DN(t) *_dev, int _i)
{
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    return(e10k_ivar_i_alloc2_extract(_regval));
}

static inline uint8_t e10k_ivar_i_allocval2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_allocval2_rdf(__DN(t) *_dev, int _i)
{
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    return(e10k_ivar_i_allocval2_extract(_regval));
}

static inline uint8_t e10k_ivar_i_alloc3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_alloc3_rdf(__DN(t) *_dev, int _i)
{
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    return(e10k_ivar_i_alloc3_extract(_regval));
}

static inline uint8_t e10k_ivar_i_allocval3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_i_allocval3_rdf(__DN(t) *_dev, int _i)
{
    e10k_ivar_t _regval = mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)));
    return(e10k_ivar_i_allocval3_extract(_regval));
}

static inline void e10k_ivar_i_alloc0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_i_alloc0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ivar_t _regval = 0x3f & (((e10k_ivar_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffffc0 & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_i_allocval0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_i_allocval0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ivar_t _regval = 0x80 & (((e10k_ivar_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_i_alloc1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_i_alloc1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ivar_t _regval = 0x3f00 & (((e10k_ivar_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffffc0ff & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_i_allocval1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_i_allocval1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ivar_t _regval = 0x8000 & (((e10k_ivar_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_i_alloc2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_i_alloc2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ivar_t _regval = 0x3f0000 & (((e10k_ivar_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffc0ffff & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_i_allocval2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_i_allocval2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ivar_t _regval = 0x800000 & (((e10k_ivar_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_i_alloc3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_i_alloc3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ivar_t _regval = 0x3f000000 & (((e10k_ivar_t )(_fieldval)) << 24);
    _regval = (_regval | (0xc0ffffff & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_i_allocval3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_i_allocval3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ivar_t _regval = 0x80000000 & (((e10k_ivar_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x900 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x900 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register ivar_misc: Miscellaneous Interrupt Vector Allocation
 * Type: e10k.ivar_misc (Implicit type of Miscellaneous Interrupt Vector Allocation register)
 *   i_alloc0	(size 7, offset 0, init 0):	RW	MSI-X vector assigned to the TCP timer interrupt
 *   i_allocval0	(size 1, offset 7, init 0):	RW	Interrupt allocation 0 valid
 *   i_alloc1	(size 7, offset 8, init 0):	RW	MSI-X vector assigned to the other interrupt cause
 *   i_allocval1	(size 1, offset 15, init 0):	RW	Interrupt allocation 1 valid
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_ivar_misc_t e10k_ivar_misc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ivar_misc_t e10k_ivar_misc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa00));
}

static inline e10k_ivar_misc_t e10k_ivar_misc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_ivar_misc_t e10k_ivar_misc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xa00));
}

static inline void e10k_ivar_misc_rawwr(__DN(t) *_dev, e10k_ivar_misc_t _regval) __attribute__ ((always_inline));
static inline void e10k_ivar_misc_rawwr(__DN(t) *_dev, e10k_ivar_misc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa00, _regval);
}

static inline void e10k_ivar_misc_wr(__DN(t) *_dev, e10k_ivar_misc_t _regval) __attribute__ ((always_inline));
static inline void e10k_ivar_misc_wr(__DN(t) *_dev, e10k_ivar_misc_t _regval)
{
    _regval = (_regval & 0xffff);
    // No MB1 fields present
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xa00)));
    mackerel_write_addr_32(_dev->base, 0xa00, _regval);
}

static inline int e10k_ivar_misc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_ivar_misc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_ivar_misc_t _regval = mackerel_read_addr_32(_dev->base, 0xa00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ivar_misc (Miscellaneous Interrupt Vector Allocation): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc0 =\t%" PRIx8 "\t(MSI-X vector assigned to the TCP timer interrupt)\n", e10k_ivar_misc_i_alloc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval0 =\t%" PRIx8 "\t(Interrupt allocation 0 valid)\n", e10k_ivar_misc_i_allocval0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_alloc1 =\t%" PRIx8 "\t(MSI-X vector assigned to the other interrupt cause)\n", e10k_ivar_misc_i_alloc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " i_allocval1 =\t%" PRIx8 "\t(Interrupt allocation 1 valid)\n", e10k_ivar_misc_i_allocval1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e10k_ivar_misc_i_alloc0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_misc_i_alloc0_rdf(__DN(t) *_dev)
{
    e10k_ivar_misc_t _regval = mackerel_read_addr_32(_dev->base, 0xa00);
    return(e10k_ivar_misc_i_alloc0_extract(_regval));
}

static inline uint8_t e10k_ivar_misc_i_allocval0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_misc_i_allocval0_rdf(__DN(t) *_dev)
{
    e10k_ivar_misc_t _regval = mackerel_read_addr_32(_dev->base, 0xa00);
    return(e10k_ivar_misc_i_allocval0_extract(_regval));
}

static inline uint8_t e10k_ivar_misc_i_alloc1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_misc_i_alloc1_rdf(__DN(t) *_dev)
{
    e10k_ivar_misc_t _regval = mackerel_read_addr_32(_dev->base, 0xa00);
    return(e10k_ivar_misc_i_alloc1_extract(_regval));
}

static inline uint8_t e10k_ivar_misc_i_allocval1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_ivar_misc_i_allocval1_rdf(__DN(t) *_dev)
{
    e10k_ivar_misc_t _regval = mackerel_read_addr_32(_dev->base, 0xa00);
    return(e10k_ivar_misc_i_allocval1_extract(_regval));
}

static inline void e10k_ivar_misc_i_alloc0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_misc_i_alloc0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ivar_misc_t _regval = 0x7f & (((e10k_ivar_misc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff80 & mackerel_read_addr_32(_dev->base, 0xa00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa00, _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_misc_i_allocval0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_misc_i_allocval0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ivar_misc_t _regval = 0x80 & (((e10k_ivar_misc_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0xa00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa00, _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_misc_i_alloc1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_misc_i_alloc1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ivar_misc_t _regval = 0x7f00 & (((e10k_ivar_misc_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff80ff & mackerel_read_addr_32(_dev->base, 0xa00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa00, _regval);
    // No shadow register to write to
}

static inline void e10k_ivar_misc_i_allocval1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ivar_misc_i_allocval1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_ivar_misc_t _regval = 0x8000 & (((e10k_ivar_misc_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0xa00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa00, _regval);
    // No shadow register to write to
}

/*
 * Register gpie: General Purpose Interrupt Enable
 * Type: e10k.gpie (Implicit type of General Purpose Interrupt Enable register)
 *   spd0_gpien	(size 1, offset 0, init 0):	RW	General Purpose Interrupt Detection Enable for SDP0
 *   spd1_gpien	(size 1, offset 1, init 0):	RW	General Purpose Interrupt Detection Enable for SDP1
 *   spd2_gpien	(size 1, offset 2, init 0):	RW	General Purpose Interrupt Detection Enable for SDP2
 *   spd3_gpien	(size 1, offset 3, init 0):	RW	General Purpose Interrupt Detection Enable for SDP3
 *   msix	(size 1, offset 4, init 0):	RW	MSI-X Mode enable
 *   ocd	(size 1, offset 5, init 0):	RW	Other Clear Disable
 *   eimen	(size 1, offset 6, init 0):	RW	EICS Immediate Interrupt Enable
 *   ll_int	(size 4, offset 7, init 0):	RW	Low latency Credits Increment Rate
 *   rsc_delay	(size 3, offset 11, init 0):	RW	RSC Delay
 *   vt_mode	(size 2, offset 14, init 0):	RW	VT_Mode
 *   _anon16	(size 14, offset 16, init 0):	RSVD	_
 *   eiame	(size 1, offset 30, init 0):	RW	Extended Interrupt Auto Mask Enable
 *   pba_sup	(size 1, offset 31, init 0):	RW	BA Support
 */
static inline e10k_gpie_t e10k_gpie_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x898));
}

static inline e10k_gpie_t e10k_gpie_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_gpie_t e10k_gpie_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x898));
}

static inline void e10k_gpie_rawwr(__DN(t) *_dev, e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline void e10k_gpie_rawwr(__DN(t) *_dev, e10k_gpie_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
}

static inline void e10k_gpie_wr(__DN(t) *_dev, e10k_gpie_t _regval) __attribute__ ((always_inline));
static inline void e10k_gpie_wr(__DN(t) *_dev, e10k_gpie_t _regval)
{
    _regval = (_regval & 0xc000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x3fff0000 & mackerel_read_addr_32(_dev->base, 0x898)));
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
}

static inline int e10k_gpie_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gpie_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gpie (General Purpose Interrupt Enable): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd0_gpien =\t%" PRIx8 "\t(General Purpose Interrupt Detection Enable for SDP0)\n", e10k_gpie_spd0_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd1_gpien =\t%" PRIx8 "\t(General Purpose Interrupt Detection Enable for SDP1)\n", e10k_gpie_spd1_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd2_gpien =\t%" PRIx8 "\t(General Purpose Interrupt Detection Enable for SDP2)\n", e10k_gpie_spd2_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " spd3_gpien =\t%" PRIx8 "\t(General Purpose Interrupt Detection Enable for SDP3)\n", e10k_gpie_spd3_gpien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msix =\t%" PRIx8 "\t(MSI-X Mode enable)\n", e10k_gpie_msix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ocd =\t%" PRIx8 "\t(Other Clear Disable)\n", e10k_gpie_ocd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eimen =\t%" PRIx8 "\t(EICS Immediate Interrupt Enable)\n", e10k_gpie_eimen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ll_int =\t%" PRIx8 "\t(Low latency Credits Increment Rate)\n", e10k_gpie_ll_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_delay =\t%" PRIx8 "\t(RSC Delay)\n", e10k_gpie_rsc_delay_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vt_mode =\t%" PRIx8 "\t(VT_Mode)\n", e10k_gpie_vt_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eiame =\t%" PRIx8 "\t(Extended Interrupt Auto Mask Enable)\n", e10k_gpie_eiame_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pba_sup =\t%" PRIx8 "\t(BA Support)\n", e10k_gpie_pba_sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_gpie_spd0_gpien_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_spd0_gpien_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_spd0_gpien_extract(_regval));
}

static inline uint8_t e10k_gpie_spd1_gpien_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_spd1_gpien_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_spd1_gpien_extract(_regval));
}

static inline uint8_t e10k_gpie_spd2_gpien_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_spd2_gpien_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_spd2_gpien_extract(_regval));
}

static inline uint8_t e10k_gpie_spd3_gpien_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_spd3_gpien_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_spd3_gpien_extract(_regval));
}

static inline uint8_t e10k_gpie_msix_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_msix_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_msix_extract(_regval));
}

static inline uint8_t e10k_gpie_ocd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_ocd_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_ocd_extract(_regval));
}

static inline uint8_t e10k_gpie_eimen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_eimen_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_eimen_extract(_regval));
}

static inline uint8_t e10k_gpie_ll_int_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_ll_int_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_ll_int_extract(_regval));
}

static inline uint8_t e10k_gpie_rsc_delay_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_rsc_delay_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_rsc_delay_extract(_regval));
}

static inline uint8_t e10k_gpie_vt_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_vt_mode_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_vt_mode_extract(_regval));
}

static inline uint8_t e10k_gpie_eiame_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_eiame_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_eiame_extract(_regval));
}

static inline uint8_t e10k_gpie_pba_sup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_gpie_pba_sup_rdf(__DN(t) *_dev)
{
    e10k_gpie_t _regval = mackerel_read_addr_32(_dev->base, 0x898);
    return(e10k_gpie_pba_sup_extract(_regval));
}

static inline void e10k_gpie_spd0_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_spd0_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x1 & (((e10k_gpie_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_spd1_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_spd1_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x2 & (((e10k_gpie_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_spd2_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_spd2_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x4 & (((e10k_gpie_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_spd3_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_spd3_gpien_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x8 & (((e10k_gpie_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_msix_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_msix_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x10 & (((e10k_gpie_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_ocd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_ocd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x20 & (((e10k_gpie_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_eimen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_eimen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x40 & (((e10k_gpie_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_ll_int_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_ll_int_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x780 & (((e10k_gpie_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfffff87f & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_rsc_delay_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_rsc_delay_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x3800 & (((e10k_gpie_t )(_fieldval)) << 11);
    _regval = (_regval | (0xffffc7ff & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_vt_mode_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_vt_mode_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0xc000 & (((e10k_gpie_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffff3fff & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_eiame_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_eiame_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x40000000 & (((e10k_gpie_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

static inline void e10k_gpie_pba_sup_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_gpie_pba_sup_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_gpie_t _regval = 0x80000000 & (((e10k_gpie_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x898)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x898, _regval);
    // No shadow register to write to
}

/*
 * Register array pbacl: MSI-X PBA Clear
 * Type: e10k.pbacl (Implicit type of MSI-X PBA Clear register array)
 *   penbitclr	(size 32, offset 0, init 0):	RWC	MSI-X Pending Bits Clear
 */
static const size_t e10k_pbacl_length = 8;
static inline e10k_pbacl_t e10k_pbacl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_pbacl_t e10k_pbacl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x110c0 + (_i * (32 / 8))));
}

static inline e10k_pbacl_t e10k_pbacl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_pbacl_t e10k_pbacl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x110c0 + (_i * (32 / 8))));
}

static inline void e10k_pbacl_rawwr(__DN(t) *_dev, int _i, e10k_pbacl_t _regval) __attribute__ ((always_inline));
static inline void e10k_pbacl_rawwr(__DN(t) *_dev, int _i, e10k_pbacl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x110c0 + (_i * (32 / 8)), _regval);
}

static inline void e10k_pbacl_wr(__DN(t) *_dev, int _i, e10k_pbacl_t _regval) __attribute__ ((always_inline));
static inline void e10k_pbacl_wr(__DN(t) *_dev, int _i, e10k_pbacl_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x110c0 + (_i * (32 / 8)), _regval);
}

static inline int e10k_pbacl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_pbacl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pbacl_t _regval = mackerel_read_addr_32(_dev->base, 0x110c0 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "pbacl", _i, "MSI-X PBA Clear");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " penbitclr =\t%" PRIx32 "\t(MSI-X Pending Bits Clear)\n", e10k_pbacl_penbitclr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_pbacl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pbacl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_pbacl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_pbacl_penbitclr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_pbacl_penbitclr_rdf(__DN(t) *_dev, int _i)
{
    e10k_pbacl_t _regval = mackerel_read_addr_32(_dev->base, 0x110c0 + (_i * (32 / 8)));
    return(e10k_pbacl_penbitclr_extract(_regval));
}

static inline void e10k_pbacl_penbitclr_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pbacl_penbitclr_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_pbacl_t _regval = 0xffffffff & (((e10k_pbacl_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x110c0 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register fctrl: Filter Control Register
 * Type: e10k.fctrl (Implicit type of Filter Control Register register)
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   sbp	(size 1, offset 1, init 0):	RW	Store Bad Packets
 *   _anon2	(size 6, offset 2, init 0):	RSVD	_
 *   mpe	(size 1, offset 8, init 0):	RW	Multicast Promiscuous Enable
 *   upe	(size 1, offset 9, init 0):	RW	Unicast Promiscuous Enable
 *   bam	(size 1, offset 10, init 0):	RW	Broadcast Accept Mode
 *   _anon11	(size 21, offset 11, init 0):	RSVD	_
 */
static inline e10k_fctrl_t e10k_fctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fctrl_t e10k_fctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5080));
}

static inline e10k_fctrl_t e10k_fctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fctrl_t e10k_fctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5080));
}

static inline void e10k_fctrl_rawwr(__DN(t) *_dev, e10k_fctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_fctrl_rawwr(__DN(t) *_dev, e10k_fctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5080, _regval);
}

static inline void e10k_fctrl_wr(__DN(t) *_dev, e10k_fctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_fctrl_wr(__DN(t) *_dev, e10k_fctrl_t _regval)
{
    _regval = (_regval & 0x702);
    // No MB1 fields present
    _regval = (_regval | (0xfffff8fd & mackerel_read_addr_32(_dev->base, 0x5080)));
    mackerel_write_addr_32(_dev->base, 0x5080, _regval);
}

static inline int e10k_fctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5080);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fctrl (Filter Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sbp =\t%" PRIx8 "\t(Store Bad Packets)\n", e10k_fctrl_sbp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mpe =\t%" PRIx8 "\t(Multicast Promiscuous Enable)\n", e10k_fctrl_mpe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " upe =\t%" PRIx8 "\t(Unicast Promiscuous Enable)\n", e10k_fctrl_upe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bam =\t%" PRIx8 "\t(Broadcast Accept Mode)\n", e10k_fctrl_bam_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    return(_r);
}

static inline uint8_t e10k_fctrl_sbp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fctrl_sbp_rdf(__DN(t) *_dev)
{
    e10k_fctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5080);
    return(e10k_fctrl_sbp_extract(_regval));
}

static inline uint8_t e10k_fctrl_mpe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fctrl_mpe_rdf(__DN(t) *_dev)
{
    e10k_fctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5080);
    return(e10k_fctrl_mpe_extract(_regval));
}

static inline uint8_t e10k_fctrl_upe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fctrl_upe_rdf(__DN(t) *_dev)
{
    e10k_fctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5080);
    return(e10k_fctrl_upe_extract(_regval));
}

static inline uint8_t e10k_fctrl_bam_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fctrl_bam_rdf(__DN(t) *_dev)
{
    e10k_fctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5080);
    return(e10k_fctrl_bam_extract(_regval));
}

static inline void e10k_fctrl_sbp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fctrl_sbp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fctrl_t _regval = 0x2 & (((e10k_fctrl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x5080)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5080, _regval);
    // No shadow register to write to
}

static inline void e10k_fctrl_mpe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fctrl_mpe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fctrl_t _regval = 0x100 & (((e10k_fctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0x5080)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5080, _regval);
    // No shadow register to write to
}

static inline void e10k_fctrl_upe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fctrl_upe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fctrl_t _regval = 0x200 & (((e10k_fctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x5080)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5080, _regval);
    // No shadow register to write to
}

static inline void e10k_fctrl_bam_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fctrl_bam_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fctrl_t _regval = 0x400 & (((e10k_fctrl_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x5080)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5080, _regval);
    // No shadow register to write to
}

/*
 * Register vlnctrl: VLAN Control Register
 * Type: e10k.vlnctrl (Implicit type of VLAN Control Register register)
 *   vet	(size 16, offset 0, init 0):	RW	VLAN Ether Type
 *   _anon16	(size 12, offset 16, init 0):	RSVD	_
 *   cfi	(size 1, offset 28, init 0):	RW	Canonical Form Indicator Bit Value
 *   cfien	(size 1, offset 29, init 0):	RW	Canonical Form Indicator Enable
 *   vfe	(size 1, offset 30, init 0):	RW	VLAN Filter Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_vlnctrl_t e10k_vlnctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vlnctrl_t e10k_vlnctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5088));
}

static inline e10k_vlnctrl_t e10k_vlnctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_vlnctrl_t e10k_vlnctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5088));
}

static inline void e10k_vlnctrl_rawwr(__DN(t) *_dev, e10k_vlnctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vlnctrl_rawwr(__DN(t) *_dev, e10k_vlnctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5088, _regval);
}

static inline void e10k_vlnctrl_wr(__DN(t) *_dev, e10k_vlnctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_vlnctrl_wr(__DN(t) *_dev, e10k_vlnctrl_t _regval)
{
    _regval = (_regval & 0x7000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x8fff0000 & mackerel_read_addr_32(_dev->base, 0x5088)));
    mackerel_write_addr_32(_dev->base, 0x5088, _regval);
}

static inline int e10k_vlnctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vlnctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vlnctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5088);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register vlnctrl (VLAN Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vet =\t%" PRIx16 "\t(VLAN Ether Type)\n", e10k_vlnctrl_vet_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfi =\t%" PRIx8 "\t(Canonical Form Indicator Bit Value)\n", e10k_vlnctrl_cfi_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfien =\t%" PRIx8 "\t(Canonical Form Indicator Enable)\n", e10k_vlnctrl_cfien_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vfe =\t%" PRIx8 "\t(VLAN Filter Enable)\n", e10k_vlnctrl_vfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint16_t e10k_vlnctrl_vet_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_vlnctrl_vet_rdf(__DN(t) *_dev)
{
    e10k_vlnctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5088);
    return(e10k_vlnctrl_vet_extract(_regval));
}

static inline uint8_t e10k_vlnctrl_cfi_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vlnctrl_cfi_rdf(__DN(t) *_dev)
{
    e10k_vlnctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5088);
    return(e10k_vlnctrl_cfi_extract(_regval));
}

static inline uint8_t e10k_vlnctrl_cfien_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vlnctrl_cfien_rdf(__DN(t) *_dev)
{
    e10k_vlnctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5088);
    return(e10k_vlnctrl_cfien_extract(_regval));
}

static inline uint8_t e10k_vlnctrl_vfe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_vlnctrl_vfe_rdf(__DN(t) *_dev)
{
    e10k_vlnctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5088);
    return(e10k_vlnctrl_vfe_extract(_regval));
}

static inline void e10k_vlnctrl_vet_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vlnctrl_vet_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_vlnctrl_t _regval = 0xffff & (((e10k_vlnctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x5088)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5088, _regval);
    // No shadow register to write to
}

static inline void e10k_vlnctrl_cfi_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vlnctrl_cfi_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vlnctrl_t _regval = 0x10000000 & (((e10k_vlnctrl_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0x5088)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5088, _regval);
    // No shadow register to write to
}

static inline void e10k_vlnctrl_cfien_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vlnctrl_cfien_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vlnctrl_t _regval = 0x20000000 & (((e10k_vlnctrl_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0x5088)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5088, _regval);
    // No shadow register to write to
}

static inline void e10k_vlnctrl_vfe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vlnctrl_vfe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_vlnctrl_t _regval = 0x40000000 & (((e10k_vlnctrl_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x5088)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5088, _regval);
    // No shadow register to write to
}

/*
 * Register mcstctrl: Multicast Control Register
 * Type: e10k.mcstctrl (Implicit type of Multicast Control Register register)
 *   mo	(size 2, offset 0, init 0):	RW	Multicast Offset
 *   mfe	(size 1, offset 2, init 0):	RW	Multicast Filter Enable
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_mcstctrl_t e10k_mcstctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mcstctrl_t e10k_mcstctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5090));
}

static inline e10k_mcstctrl_t e10k_mcstctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mcstctrl_t e10k_mcstctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5090));
}

static inline void e10k_mcstctrl_rawwr(__DN(t) *_dev, e10k_mcstctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_mcstctrl_rawwr(__DN(t) *_dev, e10k_mcstctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5090, _regval);
}

static inline void e10k_mcstctrl_wr(__DN(t) *_dev, e10k_mcstctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_mcstctrl_wr(__DN(t) *_dev, e10k_mcstctrl_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x5090)));
    mackerel_write_addr_32(_dev->base, 0x5090, _regval);
}

static inline int e10k_mcstctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mcstctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mcstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5090);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mcstctrl (Multicast Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mo =\t%" PRIx8 "\t(Multicast Offset)\n", e10k_mcstctrl_mo_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mfe =\t%" PRIx8 "\t(Multicast Filter Enable)\n", e10k_mcstctrl_mfe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_mcstctrl_mo_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mcstctrl_mo_rdf(__DN(t) *_dev)
{
    e10k_mcstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5090);
    return(e10k_mcstctrl_mo_extract(_regval));
}

static inline uint8_t e10k_mcstctrl_mfe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mcstctrl_mfe_rdf(__DN(t) *_dev)
{
    e10k_mcstctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x5090);
    return(e10k_mcstctrl_mfe_extract(_regval));
}

static inline void e10k_mcstctrl_mo_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mcstctrl_mo_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mcstctrl_t _regval = 0x3 & (((e10k_mcstctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x5090)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5090, _regval);
    // No shadow register to write to
}

static inline void e10k_mcstctrl_mfe_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mcstctrl_mfe_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mcstctrl_t _regval = 0x4 & (((e10k_mcstctrl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x5090)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5090, _regval);
    // No shadow register to write to
}

/*
 * Register array psrtype: Packet Split Receive Type Register
 * Type: e10k.psrtype (Implicit type of Packet Split Receive Type Register register array)
 *   _anon0	(size 1, offset 0, init 0):	MBZ	_
 *   split_nfs	(size 1, offset 1, init 0):	RW	Split received NFS packets after NFS header
 *   _anon2	(size 2, offset 2, init 0):	MBZ	_
 *   split_tcp	(size 1, offset 4, init 0):	RW	Split received TCP packets after TCP header
 *   split_udp	(size 1, offset 5, init 0):	RW	Split received UDP packets after UDP header
 *   _anon6	(size 2, offset 6, init 0):	MBZ	_
 *   split_ip4	(size 1, offset 8, init 0):	RW	Split received IPv4 packets after IPv4 header
 *   split_ip6	(size 1, offset 9, init 0):	RW	Split received IPv6 packets after IPv6 header
 *   _anon10	(size 2, offset 10, init 0):	MBZ	_
 *   split_l2	(size 1, offset 12, init 0):	RW	Split received L2 packets after L2 header
 *   _anon13	(size 16, offset 13, init 0):	MBZ	_
 *   rqpl	(size 3, offset 29, init 0):	RW	Number of bits to use for RSS redirection
 */
static const size_t e10k_psrtype_length = 64;
static inline e10k_psrtype_t e10k_psrtype_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8))));
}

static inline e10k_psrtype_t e10k_psrtype_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_psrtype_t e10k_psrtype_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8))));
}

static inline void e10k_psrtype_rawwr(__DN(t) *_dev, int _i, e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline void e10k_psrtype_rawwr(__DN(t) *_dev, int _i, e10k_psrtype_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
}

static inline void e10k_psrtype_wr(__DN(t) *_dev, int _i, e10k_psrtype_t _regval) __attribute__ ((always_inline));
static inline void e10k_psrtype_wr(__DN(t) *_dev, int _i, e10k_psrtype_t _regval)
{
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
}

static inline int e10k_psrtype_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_psrtype_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_psrtype_t _regval = mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "psrtype", _i, "Packet Split Receive Type Register");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_nfs =\t%" PRIx8 "\t(Split received NFS packets after NFS header)\n", e10k_psrtype_split_nfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_tcp =\t%" PRIx8 "\t(Split received TCP packets after TCP header)\n", e10k_psrtype_split_tcp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_udp =\t%" PRIx8 "\t(Split received UDP packets after UDP header)\n", e10k_psrtype_split_udp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_ip4 =\t%" PRIx8 "\t(Split received IPv4 packets after IPv4 header)\n", e10k_psrtype_split_ip4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_ip6 =\t%" PRIx8 "\t(Split received IPv6 packets after IPv6 header)\n", e10k_psrtype_split_ip6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " split_l2 =\t%" PRIx8 "\t(Split received L2 packets after L2 header)\n", e10k_psrtype_split_l2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqpl =\t%" PRIx8 "\t(Number of bits to use for RSS redirection)\n", e10k_psrtype_rqpl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_psrtype_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_psrtype_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_psrtype_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_psrtype_split_nfs_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_nfs_rdf(__DN(t) *_dev, int _i)
{
    e10k_psrtype_t _regval = mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)));
    return(e10k_psrtype_split_nfs_extract(_regval));
}

static inline uint8_t e10k_psrtype_split_tcp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_tcp_rdf(__DN(t) *_dev, int _i)
{
    e10k_psrtype_t _regval = mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)));
    return(e10k_psrtype_split_tcp_extract(_regval));
}

static inline uint8_t e10k_psrtype_split_udp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_udp_rdf(__DN(t) *_dev, int _i)
{
    e10k_psrtype_t _regval = mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)));
    return(e10k_psrtype_split_udp_extract(_regval));
}

static inline uint8_t e10k_psrtype_split_ip4_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_ip4_rdf(__DN(t) *_dev, int _i)
{
    e10k_psrtype_t _regval = mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)));
    return(e10k_psrtype_split_ip4_extract(_regval));
}

static inline uint8_t e10k_psrtype_split_ip6_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_ip6_rdf(__DN(t) *_dev, int _i)
{
    e10k_psrtype_t _regval = mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)));
    return(e10k_psrtype_split_ip6_extract(_regval));
}

static inline uint8_t e10k_psrtype_split_l2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_split_l2_rdf(__DN(t) *_dev, int _i)
{
    e10k_psrtype_t _regval = mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)));
    return(e10k_psrtype_split_l2_extract(_regval));
}

static inline uint8_t e10k_psrtype_rqpl_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_psrtype_rqpl_rdf(__DN(t) *_dev, int _i)
{
    e10k_psrtype_t _regval = mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)));
    return(e10k_psrtype_rqpl_extract(_regval));
}

static inline void e10k_psrtype_split_nfs_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_psrtype_split_nfs_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_psrtype_t _regval = 0x2 & (((e10k_psrtype_t )(_fieldval)) << 1);
    _regval = (_regval | (0xe0001330 & mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_psrtype_split_tcp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_psrtype_split_tcp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_psrtype_t _regval = 0x10 & (((e10k_psrtype_t )(_fieldval)) << 4);
    _regval = (_regval | (0xe0001322 & mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_psrtype_split_udp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_psrtype_split_udp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_psrtype_t _regval = 0x20 & (((e10k_psrtype_t )(_fieldval)) << 5);
    _regval = (_regval | (0xe0001312 & mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_psrtype_split_ip4_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_psrtype_split_ip4_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_psrtype_t _regval = 0x100 & (((e10k_psrtype_t )(_fieldval)) << 8);
    _regval = (_regval | (0xe0001232 & mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_psrtype_split_ip6_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_psrtype_split_ip6_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_psrtype_t _regval = 0x200 & (((e10k_psrtype_t )(_fieldval)) << 9);
    _regval = (_regval | (0xe0001132 & mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_psrtype_split_l2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_psrtype_split_l2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_psrtype_t _regval = 0x1000 & (((e10k_psrtype_t )(_fieldval)) << 12);
    _regval = (_regval | (0xe0000332 & mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_psrtype_rqpl_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_psrtype_rqpl_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_psrtype_t _regval = 0xe0000000 & (((e10k_psrtype_t )(_fieldval)) << 29);
    _regval = (_regval | (0x1332 & mackerel_read_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xe0001332);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xea00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register rxcsum: Receive Checksum Control
 * Type: e10k.rxcsum (Implicit type of Receive Checksum Control register)
 *   _anon0	(size 12, offset 0, init 0):	RSVD	_
 *   ippcse	(size 1, offset 12, init 0):	RW	IP Payload Checksum Enable
 *   pscd	(size 1, offset 13, init 0):	RW	RSS/Fragment Checksum Status Selection
 *   _anon14	(size 18, offset 14, init 0):	RSVD	_
 */
static inline e10k_rxcsum_t e10k_rxcsum_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rxcsum_t e10k_rxcsum_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5000));
}

static inline e10k_rxcsum_t e10k_rxcsum_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rxcsum_t e10k_rxcsum_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5000));
}

static inline void e10k_rxcsum_rawwr(__DN(t) *_dev, e10k_rxcsum_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxcsum_rawwr(__DN(t) *_dev, e10k_rxcsum_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
}

static inline void e10k_rxcsum_wr(__DN(t) *_dev, e10k_rxcsum_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxcsum_wr(__DN(t) *_dev, e10k_rxcsum_t _regval)
{
    _regval = (_regval & 0x3000);
    // No MB1 fields present
    _regval = (_regval | (0xffffcfff & mackerel_read_addr_32(_dev->base, 0x5000)));
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
}

static inline int e10k_rxcsum_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxcsum_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rxcsum_t _regval = mackerel_read_addr_32(_dev->base, 0x5000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxcsum (Receive Checksum Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ippcse =\t%" PRIx8 "\t(IP Payload Checksum Enable)\n", e10k_rxcsum_ippcse_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pscd =\t%" PRIx8 "\t(RSS/Fragment Checksum Status Selection)\n", e10k_rxcsum_pscd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint8_t e10k_rxcsum_ippcse_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxcsum_ippcse_rdf(__DN(t) *_dev)
{
    e10k_rxcsum_t _regval = mackerel_read_addr_32(_dev->base, 0x5000);
    return(e10k_rxcsum_ippcse_extract(_regval));
}

static inline uint8_t e10k_rxcsum_pscd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxcsum_pscd_rdf(__DN(t) *_dev)
{
    e10k_rxcsum_t _regval = mackerel_read_addr_32(_dev->base, 0x5000);
    return(e10k_rxcsum_pscd_extract(_regval));
}

static inline void e10k_rxcsum_ippcse_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxcsum_ippcse_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rxcsum_t _regval = 0x1000 & (((e10k_rxcsum_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x5000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
    // No shadow register to write to
}

static inline void e10k_rxcsum_pscd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxcsum_pscd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rxcsum_t _regval = 0x2000 & (((e10k_rxcsum_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x5000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5000, _regval);
    // No shadow register to write to
}

/*
 * Register rfctl: Receive Filter Control Register
 * Type: e10k.rfctl (Implicit type of Receive Filter Control Register register)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rsc_dis	(size 1, offset 5, init 0):	RW	RSC Disable
 *   nfsw_dis	(size 1, offset 6, init 0):	RW	Disable filtering of NFS write request headers
 *   nfsr_dis	(size 1, offset 7, init 0):	RW	Disable filtering of NFS read reply headers
 *   nfs_ver	(size 2, offset 8, init 0):	RW	NFS version recognized by the hardware
 *   ipv6_dis	(size 1, offset 10, init 0):	RW	Disable IPv6 packet filtering
 *   _anon11	(size 1, offset 11, init 0):	MBZ	_
 *   _anon12	(size 2, offset 12, init 0):	RSVD	_
 *   ipfrsp_dis	(size 1, offset 14, init 0):	RW	IP Fragment Split Disable
 *   _anon15	(size 3, offset 15, init 0):	RSVD	_
 *   _anon18	(size 14, offset 18, init 0):	MBZ	_
 */
static inline e10k_rfctl_t e10k_rfctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rfctl_t e10k_rfctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5008));
}

static inline e10k_rfctl_t e10k_rfctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rfctl_t e10k_rfctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5008));
}

static inline void e10k_rfctl_rawwr(__DN(t) *_dev, e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rfctl_rawwr(__DN(t) *_dev, e10k_rfctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
}

static inline void e10k_rfctl_wr(__DN(t) *_dev, e10k_rfctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rfctl_wr(__DN(t) *_dev, e10k_rfctl_t _regval)
{
    _regval = (_regval & 0x47e0);
    // No MB1 fields present
    _regval = (_regval | (0x3b01f & mackerel_read_addr_32(_dev->base, 0x5008)));
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
}

static inline int e10k_rfctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rfctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rfctl (Receive Filter Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_dis =\t%" PRIx8 "\t(RSC Disable)\n", e10k_rfctl_rsc_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfsw_dis =\t%" PRIx8 "\t(Disable filtering of NFS write request headers)\n", e10k_rfctl_nfsw_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfsr_dis =\t%" PRIx8 "\t(Disable filtering of NFS read reply headers)\n", e10k_rfctl_nfsr_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nfs_ver =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_nfs_version_prtval(_s + _r, _avail, e10k_rfctl_nfs_ver_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(NFS version recognized by the hardware)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6_dis =\t%" PRIx8 "\t(Disable IPv6 packet filtering)\n", e10k_rfctl_ipv6_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipfrsp_dis =\t%" PRIx8 "\t(IP Fragment Split Disable)\n", e10k_rfctl_ipfrsp_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    // _anon18 is anonymous
    return(_r);
}

static inline uint8_t e10k_rfctl_rsc_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_rsc_dis_rdf(__DN(t) *_dev)
{
    e10k_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e10k_rfctl_rsc_dis_extract(_regval));
}

static inline uint8_t e10k_rfctl_nfsw_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_nfsw_dis_rdf(__DN(t) *_dev)
{
    e10k_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e10k_rfctl_nfsw_dis_extract(_regval));
}

static inline uint8_t e10k_rfctl_nfsr_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_nfsr_dis_rdf(__DN(t) *_dev)
{
    e10k_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e10k_rfctl_nfsr_dis_extract(_regval));
}

static inline e10k_nfs_version_t e10k_rfctl_nfs_ver_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_nfs_version_t e10k_rfctl_nfs_ver_rdf(__DN(t) *_dev)
{
    e10k_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e10k_rfctl_nfs_ver_extract(_regval));
}

static inline uint8_t e10k_rfctl_ipv6_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_ipv6_dis_rdf(__DN(t) *_dev)
{
    e10k_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e10k_rfctl_ipv6_dis_extract(_regval));
}

static inline uint8_t e10k_rfctl_ipfrsp_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rfctl_ipfrsp_dis_rdf(__DN(t) *_dev)
{
    e10k_rfctl_t _regval = mackerel_read_addr_32(_dev->base, 0x5008);
    return(e10k_rfctl_ipfrsp_dis_extract(_regval));
}

static inline void e10k_rfctl_rsc_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rfctl_rsc_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rfctl_t _regval = 0x20 & (((e10k_rfctl_t )(_fieldval)) << 5);
    _regval = (_regval | (0x3f7df & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0x3f7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e10k_rfctl_nfsw_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rfctl_nfsw_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rfctl_t _regval = 0x40 & (((e10k_rfctl_t )(_fieldval)) << 6);
    _regval = (_regval | (0x3f7bf & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0x3f7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e10k_rfctl_nfsr_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rfctl_nfsr_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rfctl_t _regval = 0x80 & (((e10k_rfctl_t )(_fieldval)) << 7);
    _regval = (_regval | (0x3f77f & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0x3f7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e10k_rfctl_nfs_ver_wrf(__DN(t) *_dev, e10k_nfs_version_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rfctl_nfs_ver_wrf(__DN(t) *_dev, e10k_nfs_version_t _fieldval)
{
    e10k_rfctl_t _regval = 0x300 & (((e10k_rfctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0x3f4ff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0x3f7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e10k_rfctl_ipv6_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rfctl_ipv6_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rfctl_t _regval = 0x400 & (((e10k_rfctl_t )(_fieldval)) << 10);
    _regval = (_regval | (0x3f3ff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0x3f7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

static inline void e10k_rfctl_ipfrsp_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rfctl_ipfrsp_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rfctl_t _regval = 0x4000 & (((e10k_rfctl_t )(_fieldval)) << 14);
    _regval = (_regval | (0x3b7ff & mackerel_read_addr_32(_dev->base, 0x5008)));
    // No read of register shadow required
    _regval = (_regval & 0x3f7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5008, _regval);
    // No shadow register to write to
}

/*
 * Register array mta: Multicast Table Array
 * Type: e10k.mta (Implicit type of Multicast Table Array register array)
 *   bit_vec	(size 32, offset 0, init 0):	RW	Bit Vector
 */
static const size_t e10k_mta_length = 128;
static inline e10k_mta_t e10k_mta_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_mta_t e10k_mta_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5200 + (_i * (32 / 8))));
}

static inline e10k_mta_t e10k_mta_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_mta_t e10k_mta_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5200 + (_i * (32 / 8))));
}

static inline void e10k_mta_rawwr(__DN(t) *_dev, int _i, e10k_mta_t _regval) __attribute__ ((always_inline));
static inline void e10k_mta_rawwr(__DN(t) *_dev, int _i, e10k_mta_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5200 + (_i * (32 / 8)), _regval);
}

static inline void e10k_mta_wr(__DN(t) *_dev, int _i, e10k_mta_t _regval) __attribute__ ((always_inline));
static inline void e10k_mta_wr(__DN(t) *_dev, int _i, e10k_mta_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5200 + (_i * (32 / 8)), _regval);
}

static inline int e10k_mta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_mta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mta_t _regval = mackerel_read_addr_32(_dev->base, 0x5200 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mta", _i, "Multicast Table Array");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bit_vec =\t%" PRIx32 "\t(Bit Vector)\n", e10k_mta_bit_vec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_mta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_mta_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_mta_bit_vec_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_mta_bit_vec_rdf(__DN(t) *_dev, int _i)
{
    e10k_mta_t _regval = mackerel_read_addr_32(_dev->base, 0x5200 + (_i * (32 / 8)));
    return(e10k_mta_bit_vec_extract(_regval));
}

static inline void e10k_mta_bit_vec_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mta_bit_vec_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_mta_t _regval = 0xffffffff & (((e10k_mta_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5200 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array ral: Receive Address Low
 * Type: e10k.ral (Implicit type of Receive Address Low register array)
 *   ral	(size 32, offset 0, init 0):	RW	Receive Address Low
 */
static const size_t e10k_ral_length = 128;
static inline e10k_ral_t e10k_ral_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_ral_t e10k_ral_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa200 + (_i * 8)));
}

static inline e10k_ral_t e10k_ral_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_ral_t e10k_ral_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa200 + (_i * 8)));
}

static inline void e10k_ral_rawwr(__DN(t) *_dev, int _i, e10k_ral_t _regval) __attribute__ ((always_inline));
static inline void e10k_ral_rawwr(__DN(t) *_dev, int _i, e10k_ral_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa200 + (_i * 8), _regval);
}

static inline void e10k_ral_wr(__DN(t) *_dev, int _i, e10k_ral_t _regval) __attribute__ ((always_inline));
static inline void e10k_ral_wr(__DN(t) *_dev, int _i, e10k_ral_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa200 + (_i * 8), _regval);
}

static inline int e10k_ral_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_ral_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_ral_t _regval = mackerel_read_addr_32(_dev->base, 0xa200 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ral", _i, "Receive Address Low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ral =\t%" PRIx32 "\t(Receive Address Low)\n", e10k_ral_ral_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_ral_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_ral_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_ral_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_ral_ral_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_ral_ral_rdf(__DN(t) *_dev, int _i)
{
    e10k_ral_t _regval = mackerel_read_addr_32(_dev->base, 0xa200 + (_i * 8));
    return(e10k_ral_ral_extract(_regval));
}

static inline void e10k_ral_ral_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ral_ral_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_ral_t _regval = 0xffffffff & (((e10k_ral_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa200 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register array rah: Receive Address High
 * Type: e10k.rah (Implicit type of Receive Address High register array)
 *   rah	(size 16, offset 0, init 0):	RW	Receive Address High
 *   _anon16	(size 15, offset 16, init 0):	RSVD	_
 *   av	(size 1, offset 31, init 0):	RW	Address Valid
 */
static const size_t e10k_rah_length = 128;
static inline e10k_rah_t e10k_rah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rah_t e10k_rah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa204 + (_i * 8)));
}

static inline e10k_rah_t e10k_rah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rah_t e10k_rah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa204 + (_i * 8)));
}

static inline void e10k_rah_rawwr(__DN(t) *_dev, int _i, e10k_rah_t _regval) __attribute__ ((always_inline));
static inline void e10k_rah_rawwr(__DN(t) *_dev, int _i, e10k_rah_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa204 + (_i * 8), _regval);
}

static inline void e10k_rah_wr(__DN(t) *_dev, int _i, e10k_rah_t _regval) __attribute__ ((always_inline));
static inline void e10k_rah_wr(__DN(t) *_dev, int _i, e10k_rah_t _regval)
{
    _regval = (_regval & 0x8000ffff);
    // No MB1 fields present
    _regval = (_regval | (0x7fff0000 & mackerel_read_addr_32(_dev->base, 0xa204 + (_i * 8))));
    mackerel_write_addr_32(_dev->base, 0xa204 + (_i * 8), _regval);
}

static inline int e10k_rah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rah_t _regval = mackerel_read_addr_32(_dev->base, 0xa204 + (_i * 8));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rah", _i, "Receive Address High");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rah =\t%" PRIx16 "\t(Receive Address High)\n", e10k_rah_rah_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " av =\t%" PRIx8 "\t(Address Valid)\n", e10k_rah_av_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_rah_rah_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_rah_rah_rdf(__DN(t) *_dev, int _i)
{
    e10k_rah_t _regval = mackerel_read_addr_32(_dev->base, 0xa204 + (_i * 8));
    return(e10k_rah_rah_extract(_regval));
}

static inline uint8_t e10k_rah_av_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rah_av_rdf(__DN(t) *_dev, int _i)
{
    e10k_rah_t _regval = mackerel_read_addr_32(_dev->base, 0xa204 + (_i * 8));
    return(e10k_rah_av_extract(_regval));
}

static inline void e10k_rah_rah_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rah_rah_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_rah_t _regval = 0xffff & (((e10k_rah_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xa204 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa204 + (_i * 8), _regval);
    // No shadow register to write to
}

static inline void e10k_rah_av_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rah_av_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rah_t _regval = 0x80000000 & (((e10k_rah_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xa204 + (_i * 8))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa204 + (_i * 8), _regval);
    // No shadow register to write to
}

/*
 * Register array mpsar: MAC Pool Select Array
 * Type: e10k.mpsar (Implicit type of MAC Pool Select Array register array)
 *   pool_ena	(size 32, offset 0, init 0):	RW	Pool Enable Bit Array
 */
static const size_t e10k_mpsar_length = 256;
static inline e10k_mpsar_t e10k_mpsar_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_mpsar_t e10k_mpsar_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa600 + (_i * (32 / 8))));
}

static inline e10k_mpsar_t e10k_mpsar_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_mpsar_t e10k_mpsar_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa600 + (_i * (32 / 8))));
}

static inline void e10k_mpsar_rawwr(__DN(t) *_dev, int _i, e10k_mpsar_t _regval) __attribute__ ((always_inline));
static inline void e10k_mpsar_rawwr(__DN(t) *_dev, int _i, e10k_mpsar_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa600 + (_i * (32 / 8)), _regval);
}

static inline void e10k_mpsar_wr(__DN(t) *_dev, int _i, e10k_mpsar_t _regval) __attribute__ ((always_inline));
static inline void e10k_mpsar_wr(__DN(t) *_dev, int _i, e10k_mpsar_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa600 + (_i * (32 / 8)), _regval);
}

static inline int e10k_mpsar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_mpsar_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mpsar_t _regval = mackerel_read_addr_32(_dev->base, 0xa600 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mpsar", _i, "MAC Pool Select Array");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool_ena =\t%" PRIx32 "\t(Pool Enable Bit Array)\n", e10k_mpsar_pool_ena_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_mpsar_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mpsar_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 256; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_mpsar_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_mpsar_pool_ena_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_mpsar_pool_ena_rdf(__DN(t) *_dev, int _i)
{
    e10k_mpsar_t _regval = mackerel_read_addr_32(_dev->base, 0xa600 + (_i * (32 / 8)));
    return(e10k_mpsar_pool_ena_extract(_regval));
}

static inline void e10k_mpsar_pool_ena_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mpsar_pool_ena_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_mpsar_t _regval = 0xffffffff & (((e10k_mpsar_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array vfta: VLAN Filter Table Array
 * Type: e10k.vfta (Implicit type of VLAN Filter Table Array register array)
 *   vlan_flt	(size 32, offset 0, init 0):	RW	VLAN Filter
 */
static const size_t e10k_vfta_length = 128;
static inline e10k_vfta_t e10k_vfta_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vfta_t e10k_vfta_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa000 + (_i * (32 / 8))));
}

static inline e10k_vfta_t e10k_vfta_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_vfta_t e10k_vfta_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xa000 + (_i * (32 / 8))));
}

static inline void e10k_vfta_rawwr(__DN(t) *_dev, int _i, e10k_vfta_t _regval) __attribute__ ((always_inline));
static inline void e10k_vfta_rawwr(__DN(t) *_dev, int _i, e10k_vfta_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xa000 + (_i * (32 / 8)), _regval);
}

static inline void e10k_vfta_wr(__DN(t) *_dev, int _i, e10k_vfta_t _regval) __attribute__ ((always_inline));
static inline void e10k_vfta_wr(__DN(t) *_dev, int _i, e10k_vfta_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xa000 + (_i * (32 / 8)), _regval);
}

static inline int e10k_vfta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_vfta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_vfta_t _regval = mackerel_read_addr_32(_dev->base, 0xa000 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "vfta", _i, "VLAN Filter Table Array");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan_flt =\t%" PRIx32 "\t(VLAN Filter)\n", e10k_vfta_vlan_flt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_vfta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_vfta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_vfta_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_vfta_vlan_flt_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_vfta_vlan_flt_rdf(__DN(t) *_dev, int _i)
{
    e10k_vfta_t _regval = mackerel_read_addr_32(_dev->base, 0xa000 + (_i * (32 / 8)));
    return(e10k_vfta_vlan_flt_extract(_regval));
}

static inline void e10k_vfta_vlan_flt_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_vfta_vlan_flt_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_vfta_t _regval = 0xffffffff & (((e10k_vfta_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xa000 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register mrqc: Multiple Receive Queues Command Register
 * Type: e10k.mrqc (Implicit type of Multiple Receive Queues Command Register register)
 *   mrque	(size 4, offset 0, init 0):	RW	Multiple Receive Queues Enable
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   en_tcpip4	(size 1, offset 16, init 0):	RW	Enable TcpIPv4 hash function
 *   en_ip4	(size 1, offset 17, init 0):	RW	Enable IPv4 hash function
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   en_ip6	(size 1, offset 20, init 0):	RW	Enable IPv6 hash function
 *   en_tcpip6	(size 1, offset 21, init 0):	RW	Enable TcpIPv6 hash function
 *   en_udp4	(size 1, offset 22, init 0):	RW	Enable UdpIPV4
 *   en_udp6	(size 1, offset 23, init 0):	RW	Enable UdpIPV6
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline e10k_mrqc_t e10k_mrqc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec80));
}

static inline e10k_mrqc_t e10k_mrqc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mrqc_t e10k_mrqc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec80));
}

static inline void e10k_mrqc_rawwr(__DN(t) *_dev, e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline void e10k_mrqc_rawwr(__DN(t) *_dev, e10k_mrqc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
}

static inline void e10k_mrqc_wr(__DN(t) *_dev, e10k_mrqc_t _regval) __attribute__ ((always_inline));
static inline void e10k_mrqc_wr(__DN(t) *_dev, e10k_mrqc_t _regval)
{
    _regval = (_regval & 0xf3000f);
    // No MB1 fields present
    _regval = (_regval | (0xff0cfff0 & mackerel_read_addr_32(_dev->base, 0xec80)));
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
}

static inline int e10k_mrqc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mrqc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mrqc_t _regval = mackerel_read_addr_32(_dev->base, 0xec80);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mrqc (Multiple Receive Queues Command Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mrque =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mrq_mode_prtval(_s + _r, _avail, e10k_mrqc_mrque_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Multiple Receive Queues Enable)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_tcpip4 =\t%" PRIx8 "\t(Enable TcpIPv4 hash function)\n", e10k_mrqc_en_tcpip4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_ip4 =\t%" PRIx8 "\t(Enable IPv4 hash function)\n", e10k_mrqc_en_ip4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_ip6 =\t%" PRIx8 "\t(Enable IPv6 hash function)\n", e10k_mrqc_en_ip6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_tcpip6 =\t%" PRIx8 "\t(Enable TcpIPv6 hash function)\n", e10k_mrqc_en_tcpip6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_udp4 =\t%" PRIx8 "\t(Enable UdpIPV4)\n", e10k_mrqc_en_udp4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_udp6 =\t%" PRIx8 "\t(Enable UdpIPV6)\n", e10k_mrqc_en_udp6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline e10k_mrq_mode_t e10k_mrqc_mrque_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mrq_mode_t e10k_mrqc_mrque_rdf(__DN(t) *_dev)
{
    e10k_mrqc_t _regval = mackerel_read_addr_32(_dev->base, 0xec80);
    return(e10k_mrqc_mrque_extract(_regval));
}

static inline uint8_t e10k_mrqc_en_tcpip4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_tcpip4_rdf(__DN(t) *_dev)
{
    e10k_mrqc_t _regval = mackerel_read_addr_32(_dev->base, 0xec80);
    return(e10k_mrqc_en_tcpip4_extract(_regval));
}

static inline uint8_t e10k_mrqc_en_ip4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_ip4_rdf(__DN(t) *_dev)
{
    e10k_mrqc_t _regval = mackerel_read_addr_32(_dev->base, 0xec80);
    return(e10k_mrqc_en_ip4_extract(_regval));
}

static inline uint8_t e10k_mrqc_en_ip6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_ip6_rdf(__DN(t) *_dev)
{
    e10k_mrqc_t _regval = mackerel_read_addr_32(_dev->base, 0xec80);
    return(e10k_mrqc_en_ip6_extract(_regval));
}

static inline uint8_t e10k_mrqc_en_tcpip6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_tcpip6_rdf(__DN(t) *_dev)
{
    e10k_mrqc_t _regval = mackerel_read_addr_32(_dev->base, 0xec80);
    return(e10k_mrqc_en_tcpip6_extract(_regval));
}

static inline uint8_t e10k_mrqc_en_udp4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_udp4_rdf(__DN(t) *_dev)
{
    e10k_mrqc_t _regval = mackerel_read_addr_32(_dev->base, 0xec80);
    return(e10k_mrqc_en_udp4_extract(_regval));
}

static inline uint8_t e10k_mrqc_en_udp6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mrqc_en_udp6_rdf(__DN(t) *_dev)
{
    e10k_mrqc_t _regval = mackerel_read_addr_32(_dev->base, 0xec80);
    return(e10k_mrqc_en_udp6_extract(_regval));
}

static inline void e10k_mrqc_mrque_wrf(__DN(t) *_dev, e10k_mrq_mode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mrqc_mrque_wrf(__DN(t) *_dev, e10k_mrq_mode_t _fieldval)
{
    e10k_mrqc_t _regval = 0xf & (((e10k_mrqc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0xec80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
    // No shadow register to write to
}

static inline void e10k_mrqc_en_tcpip4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mrqc_en_tcpip4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mrqc_t _regval = 0x10000 & (((e10k_mrqc_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0xec80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
    // No shadow register to write to
}

static inline void e10k_mrqc_en_ip4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mrqc_en_ip4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mrqc_t _regval = 0x20000 & (((e10k_mrqc_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0xec80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
    // No shadow register to write to
}

static inline void e10k_mrqc_en_ip6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mrqc_en_ip6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mrqc_t _regval = 0x100000 & (((e10k_mrqc_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffefffff & mackerel_read_addr_32(_dev->base, 0xec80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
    // No shadow register to write to
}

static inline void e10k_mrqc_en_tcpip6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mrqc_en_tcpip6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mrqc_t _regval = 0x200000 & (((e10k_mrqc_t )(_fieldval)) << 21);
    _regval = (_regval | (0xffdfffff & mackerel_read_addr_32(_dev->base, 0xec80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
    // No shadow register to write to
}

static inline void e10k_mrqc_en_udp4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mrqc_en_udp4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mrqc_t _regval = 0x400000 & (((e10k_mrqc_t )(_fieldval)) << 22);
    _regval = (_regval | (0xffbfffff & mackerel_read_addr_32(_dev->base, 0xec80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
    // No shadow register to write to
}

static inline void e10k_mrqc_en_udp6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mrqc_en_udp6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mrqc_t _regval = 0x800000 & (((e10k_mrqc_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0xec80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec80, _regval);
    // No shadow register to write to
}

/*
 * Register rqtc: RSS Queues Per Traffic Class Register
 * Type: e10k.rqtc (Implicit type of RSS Queues Per Traffic Class Register register)
 *   rqtc0	(size 3, offset 0, init 0):	RW	Number of bits to use for RSS redirection TC0
 *   _anon3	(size 1, offset 3, init 0):	RSVD	_
 *   rqtc1	(size 3, offset 4, init 0):	RW	Number of bits to use for RSS redirection TC1
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   rqtc2	(size 3, offset 8, init 0):	RW	Number of bits to use for RSS redirection TC2
 *   _anon11	(size 1, offset 11, init 0):	RSVD	_
 *   rqtc3	(size 3, offset 12, init 0):	RW	Number of bits to use for RSS redirection TC3
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   rqtc4	(size 3, offset 16, init 0):	RW	Number of bits to use for RSS redirection TC4
 *   _anon19	(size 1, offset 19, init 0):	RSVD	_
 *   rqtc5	(size 3, offset 20, init 0):	RW	Number of bits to use for RSS redirection TC5
 *   _anon23	(size 1, offset 23, init 0):	RSVD	_
 *   rqtc6	(size 3, offset 24, init 0):	RW	Number of bits to use for RSS redirection TC6
 *   _anon27	(size 1, offset 27, init 0):	RSVD	_
 *   rqtc7	(size 3, offset 28, init 0):	RW	Number of bits to use for RSS redirection TC7
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_rqtc_t e10k_rqtc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec70));
}

static inline e10k_rqtc_t e10k_rqtc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rqtc_t e10k_rqtc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec70));
}

static inline void e10k_rqtc_rawwr(__DN(t) *_dev, e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rawwr(__DN(t) *_dev, e10k_rqtc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
}

static inline void e10k_rqtc_wr(__DN(t) *_dev, e10k_rqtc_t _regval) __attribute__ ((always_inline));
static inline void e10k_rqtc_wr(__DN(t) *_dev, e10k_rqtc_t _regval)
{
    _regval = (_regval & 0x77777777);
    // No MB1 fields present
    _regval = (_regval | (0x88888888 & mackerel_read_addr_32(_dev->base, 0xec70)));
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
}

static inline int e10k_rqtc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rqtc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rqtc (RSS Queues Per Traffic Class Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc0 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC0)\n", e10k_rqtc_rqtc0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc1 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC1)\n", e10k_rqtc_rqtc1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc2 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC2)\n", e10k_rqtc_rqtc2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc3 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC3)\n", e10k_rqtc_rqtc3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc4 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC4)\n", e10k_rqtc_rqtc4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc5 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC5)\n", e10k_rqtc_rqtc5_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc6 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC6)\n", e10k_rqtc_rqtc6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rqtc7 =\t%" PRIx8 "\t(Number of bits to use for RSS redirection TC7)\n", e10k_rqtc_rqtc7_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t e10k_rqtc_rqtc0_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc0_rdf(__DN(t) *_dev)
{
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    return(e10k_rqtc_rqtc0_extract(_regval));
}

static inline uint8_t e10k_rqtc_rqtc1_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc1_rdf(__DN(t) *_dev)
{
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    return(e10k_rqtc_rqtc1_extract(_regval));
}

static inline uint8_t e10k_rqtc_rqtc2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc2_rdf(__DN(t) *_dev)
{
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    return(e10k_rqtc_rqtc2_extract(_regval));
}

static inline uint8_t e10k_rqtc_rqtc3_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc3_rdf(__DN(t) *_dev)
{
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    return(e10k_rqtc_rqtc3_extract(_regval));
}

static inline uint8_t e10k_rqtc_rqtc4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc4_rdf(__DN(t) *_dev)
{
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    return(e10k_rqtc_rqtc4_extract(_regval));
}

static inline uint8_t e10k_rqtc_rqtc5_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc5_rdf(__DN(t) *_dev)
{
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    return(e10k_rqtc_rqtc5_extract(_regval));
}

static inline uint8_t e10k_rqtc_rqtc6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc6_rdf(__DN(t) *_dev)
{
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    return(e10k_rqtc_rqtc6_extract(_regval));
}

static inline uint8_t e10k_rqtc_rqtc7_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rqtc_rqtc7_rdf(__DN(t) *_dev)
{
    e10k_rqtc_t _regval = mackerel_read_addr_32(_dev->base, 0xec70);
    return(e10k_rqtc_rqtc7_extract(_regval));
}

static inline void e10k_rqtc_rqtc0_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rqtc0_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rqtc_t _regval = 0x7 & (((e10k_rqtc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0xec70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
    // No shadow register to write to
}

static inline void e10k_rqtc_rqtc1_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rqtc1_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rqtc_t _regval = 0x70 & (((e10k_rqtc_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffff8f & mackerel_read_addr_32(_dev->base, 0xec70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
    // No shadow register to write to
}

static inline void e10k_rqtc_rqtc2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rqtc2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rqtc_t _regval = 0x700 & (((e10k_rqtc_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff8ff & mackerel_read_addr_32(_dev->base, 0xec70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
    // No shadow register to write to
}

static inline void e10k_rqtc_rqtc3_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rqtc3_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rqtc_t _regval = 0x7000 & (((e10k_rqtc_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffff8fff & mackerel_read_addr_32(_dev->base, 0xec70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
    // No shadow register to write to
}

static inline void e10k_rqtc_rqtc4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rqtc4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rqtc_t _regval = 0x70000 & (((e10k_rqtc_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff8ffff & mackerel_read_addr_32(_dev->base, 0xec70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
    // No shadow register to write to
}

static inline void e10k_rqtc_rqtc5_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rqtc5_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rqtc_t _regval = 0x700000 & (((e10k_rqtc_t )(_fieldval)) << 20);
    _regval = (_regval | (0xff8fffff & mackerel_read_addr_32(_dev->base, 0xec70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
    // No shadow register to write to
}

static inline void e10k_rqtc_rqtc6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rqtc6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rqtc_t _regval = 0x7000000 & (((e10k_rqtc_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf8ffffff & mackerel_read_addr_32(_dev->base, 0xec70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
    // No shadow register to write to
}

static inline void e10k_rqtc_rqtc7_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rqtc_rqtc7_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rqtc_t _regval = 0x70000000 & (((e10k_rqtc_t )(_fieldval)) << 28);
    _regval = (_regval | (0x8fffffff & mackerel_read_addr_32(_dev->base, 0xec70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec70, _regval);
    // No shadow register to write to
}

/*
 * Register array rssrk: RSS Random Key Register
 * Type: e10k.rssrk (Implicit type of RSS Random Key Register register array)
 *   key	(size 32, offset 0, init 0):	RW	RSS Key Word n (bytes 4*n to 4*n+3) of the RSS random key
 */
static const size_t e10k_rssrk_length = 10;
static inline e10k_rssrk_t e10k_rssrk_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rssrk_t e10k_rssrk_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xeb80 + (_i * (32 / 8))));
}

static inline e10k_rssrk_t e10k_rssrk_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rssrk_t e10k_rssrk_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xeb80 + (_i * (32 / 8))));
}

static inline void e10k_rssrk_rawwr(__DN(t) *_dev, int _i, e10k_rssrk_t _regval) __attribute__ ((always_inline));
static inline void e10k_rssrk_rawwr(__DN(t) *_dev, int _i, e10k_rssrk_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xeb80 + (_i * (32 / 8)), _regval);
}

static inline void e10k_rssrk_wr(__DN(t) *_dev, int _i, e10k_rssrk_t _regval) __attribute__ ((always_inline));
static inline void e10k_rssrk_wr(__DN(t) *_dev, int _i, e10k_rssrk_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xeb80 + (_i * (32 / 8)), _regval);
}

static inline int e10k_rssrk_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rssrk_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rssrk_t _regval = mackerel_read_addr_32(_dev->base, 0xeb80 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rssrk", _i, "RSS Random Key Register");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " key =\t%" PRIx32 "\t(RSS Key Word n (bytes 4*n to 4*n+3) of the RSS random key)\n", e10k_rssrk_key_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rssrk_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rssrk_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 10; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rssrk_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_rssrk_key_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rssrk_key_rdf(__DN(t) *_dev, int _i)
{
    e10k_rssrk_t _regval = mackerel_read_addr_32(_dev->base, 0xeb80 + (_i * (32 / 8)));
    return(e10k_rssrk_key_extract(_regval));
}

static inline void e10k_rssrk_key_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rssrk_key_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_rssrk_t _regval = 0xffffffff & (((e10k_rssrk_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xeb80 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array reta: Redirection Table
 * Type: e10k.reta (Implicit type of Redirection Table register array)
 *   entry0	(size 4, offset 0, init 0):	RW	RSS output index for hash value 4n+0
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   entry1	(size 4, offset 8, init 0):	RW	RSS output index for hash value 4n+1
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   entry2	(size 4, offset 16, init 0):	RW	RSS output index for hash value 4n+2
 *   _anon20	(size 4, offset 20, init 0):	RSVD	_
 *   entry3	(size 4, offset 24, init 0):	RW	RSS output index for hash value 4n+3
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static const size_t e10k_reta_length = 32;
static inline e10k_reta_t e10k_reta_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_reta_t e10k_reta_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8))));
}

static inline e10k_reta_t e10k_reta_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_reta_t e10k_reta_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8))));
}

static inline void e10k_reta_rawwr(__DN(t) *_dev, int _i, e10k_reta_t _regval) __attribute__ ((always_inline));
static inline void e10k_reta_rawwr(__DN(t) *_dev, int _i, e10k_reta_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)), _regval);
}

static inline void e10k_reta_wr(__DN(t) *_dev, int _i, e10k_reta_t _regval) __attribute__ ((always_inline));
static inline void e10k_reta_wr(__DN(t) *_dev, int _i, e10k_reta_t _regval)
{
    _regval = (_regval & 0xf0f0f0f);
    // No MB1 fields present
    _regval = (_regval | (0xf0f0f0f0 & mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)), _regval);
}

static inline int e10k_reta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_reta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_reta_t _regval = mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "reta", _i, "Redirection Table");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry0 =\t%" PRIx8 "\t(RSS output index for hash value 4n+0)\n", e10k_reta_entry0_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry1 =\t%" PRIx8 "\t(RSS output index for hash value 4n+1)\n", e10k_reta_entry1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry2 =\t%" PRIx8 "\t(RSS output index for hash value 4n+2)\n", e10k_reta_entry2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " entry3 =\t%" PRIx8 "\t(RSS output index for hash value 4n+3)\n", e10k_reta_entry3_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline int e10k_reta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_reta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 32; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_reta_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_reta_entry0_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_reta_entry0_rdf(__DN(t) *_dev, int _i)
{
    e10k_reta_t _regval = mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)));
    return(e10k_reta_entry0_extract(_regval));
}

static inline uint8_t e10k_reta_entry1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_reta_entry1_rdf(__DN(t) *_dev, int _i)
{
    e10k_reta_t _regval = mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)));
    return(e10k_reta_entry1_extract(_regval));
}

static inline uint8_t e10k_reta_entry2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_reta_entry2_rdf(__DN(t) *_dev, int _i)
{
    e10k_reta_t _regval = mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)));
    return(e10k_reta_entry2_extract(_regval));
}

static inline uint8_t e10k_reta_entry3_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_reta_entry3_rdf(__DN(t) *_dev, int _i)
{
    e10k_reta_t _regval = mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)));
    return(e10k_reta_entry3_extract(_regval));
}

static inline void e10k_reta_entry0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_reta_entry0_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_reta_t _regval = 0xf & (((e10k_reta_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_reta_entry1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_reta_entry1_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_reta_t _regval = 0xf00 & (((e10k_reta_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff0ff & mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_reta_entry2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_reta_entry2_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_reta_t _regval = 0xf0000 & (((e10k_reta_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_reta_entry3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_reta_entry3_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_reta_t _regval = 0xf000000 & (((e10k_reta_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf0ffffff & mackerel_read_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xeb00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array saqf: Source Address Queue Filter
 * Type: e10k.saqf (Implicit type of Source Address Queue Filter register array)
 *   src_addr	(size 32, offset 0, init 0):	RW	IP Source Address
 */
static const size_t e10k_saqf_length = 128;
static inline e10k_saqf_t e10k_saqf_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_saqf_t e10k_saqf_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe000 + (_i * (32 / 8))));
}

static inline e10k_saqf_t e10k_saqf_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_saqf_t e10k_saqf_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe000 + (_i * (32 / 8))));
}

static inline void e10k_saqf_rawwr(__DN(t) *_dev, int _i, e10k_saqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_saqf_rawwr(__DN(t) *_dev, int _i, e10k_saqf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe000 + (_i * (32 / 8)), _regval);
}

static inline void e10k_saqf_wr(__DN(t) *_dev, int _i, e10k_saqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_saqf_wr(__DN(t) *_dev, int _i, e10k_saqf_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe000 + (_i * (32 / 8)), _regval);
}

static inline int e10k_saqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_saqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_saqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe000 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "saqf", _i, "Source Address Queue Filter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " src_addr =\t%" PRIx32 "\t(IP Source Address)\n", e10k_saqf_src_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_saqf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_saqf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_saqf_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_saqf_src_addr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_saqf_src_addr_rdf(__DN(t) *_dev, int _i)
{
    e10k_saqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe000 + (_i * (32 / 8)));
    return(e10k_saqf_src_addr_extract(_regval));
}

static inline void e10k_saqf_src_addr_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_saqf_src_addr_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_saqf_t _regval = 0xffffffff & (((e10k_saqf_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe000 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array daqf: Destination Address Queue Filter
 * Type: e10k.daqf (Implicit type of Destination Address Queue Filter register array)
 *   dst_addr	(size 32, offset 0, init 0):	RW	IP Destination Address
 */
static const size_t e10k_daqf_length = 128;
static inline e10k_daqf_t e10k_daqf_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_daqf_t e10k_daqf_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe200 + (_i * (32 / 8))));
}

static inline e10k_daqf_t e10k_daqf_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_daqf_t e10k_daqf_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe200 + (_i * (32 / 8))));
}

static inline void e10k_daqf_rawwr(__DN(t) *_dev, int _i, e10k_daqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_daqf_rawwr(__DN(t) *_dev, int _i, e10k_daqf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe200 + (_i * (32 / 8)), _regval);
}

static inline void e10k_daqf_wr(__DN(t) *_dev, int _i, e10k_daqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_daqf_wr(__DN(t) *_dev, int _i, e10k_daqf_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe200 + (_i * (32 / 8)), _regval);
}

static inline int e10k_daqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_daqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_daqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe200 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "daqf", _i, "Destination Address Queue Filter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_addr =\t%" PRIx32 "\t(IP Destination Address)\n", e10k_daqf_dst_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_daqf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_daqf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_daqf_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_daqf_dst_addr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_daqf_dst_addr_rdf(__DN(t) *_dev, int _i)
{
    e10k_daqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe200 + (_i * (32 / 8)));
    return(e10k_daqf_dst_addr_extract(_regval));
}

static inline void e10k_daqf_dst_addr_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_daqf_dst_addr_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_daqf_t _regval = 0xffffffff & (((e10k_daqf_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe200 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array sdpqf: Source Destination Port Queue Filter
 * Type: e10k.sdpqf (Implicit type of Source Destination Port Queue Filter register array)
 *   src_port	(size 16, offset 0, init 0):	RW	TCP/UDP Source Port
 *   dst_port	(size 16, offset 16, init 0):	RW	TCP/UDP Destination Port
 */
static const size_t e10k_sdpqf_length = 128;
static inline e10k_sdpqf_t e10k_sdpqf_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_sdpqf_t e10k_sdpqf_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe400 + (_i * (32 / 8))));
}

static inline e10k_sdpqf_t e10k_sdpqf_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_sdpqf_t e10k_sdpqf_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe400 + (_i * (32 / 8))));
}

static inline void e10k_sdpqf_rawwr(__DN(t) *_dev, int _i, e10k_sdpqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_sdpqf_rawwr(__DN(t) *_dev, int _i, e10k_sdpqf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)), _regval);
}

static inline void e10k_sdpqf_wr(__DN(t) *_dev, int _i, e10k_sdpqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_sdpqf_wr(__DN(t) *_dev, int _i, e10k_sdpqf_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)), _regval);
}

static inline int e10k_sdpqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_sdpqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_sdpqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "sdpqf", _i, "Source Destination Port Queue Filter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " src_port =\t%" PRIx16 "\t(TCP/UDP Source Port)\n", e10k_sdpqf_src_port_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dst_port =\t%" PRIx16 "\t(TCP/UDP Destination Port)\n", e10k_sdpqf_dst_port_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_sdpqf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_sdpqf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_sdpqf_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_sdpqf_src_port_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_sdpqf_src_port_rdf(__DN(t) *_dev, int _i)
{
    e10k_sdpqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)));
    return(e10k_sdpqf_src_port_extract(_regval));
}

static inline uint16_t e10k_sdpqf_dst_port_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_sdpqf_dst_port_rdf(__DN(t) *_dev, int _i)
{
    e10k_sdpqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)));
    return(e10k_sdpqf_dst_port_extract(_regval));
}

static inline void e10k_sdpqf_src_port_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sdpqf_src_port_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_sdpqf_t _regval = 0xffff & (((e10k_sdpqf_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_sdpqf_dst_port_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sdpqf_dst_port_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_sdpqf_t _regval = 0xffff0000 & (((e10k_sdpqf_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe400 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array ftqf: Five tuple Queue Filter
 * Type: e10k.ftqf (Implicit type of Five tuple Queue Filter register array)
 *   protocol	(size 2, offset 0, init 0):	RW	IP L4 protocol
 *   priority	(size 3, offset 2, init 0):	RW	Priority value in case more than one 5-tuple filter matches
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   pool	(size 6, offset 8, init 0):	RW	The pool Index of the pool associated with this filter
 *   _anon14	(size 11, offset 14, init 0):	MBZ	_
 *   m_srcaddr	(size 1, offset 25, init 0):	RW	Mask source address comparison
 *   m_dstaddr	(size 1, offset 26, init 0):	RW	Mask destination address comparison
 *   m_srcport	(size 1, offset 27, init 0):	RW	Mask source port comparison
 *   m_dstport	(size 1, offset 28, init 0):	RW	Mask destination port comparison
 *   m_protocol	(size 1, offset 29, init 0):	RW	Mask protocol comparison
 *   pool_mask	(size 1, offset 30, init 0):	RW	Mask bit for the Pool field
 *   queue_en	(size 1, offset 31, init 0):	RW	Queue Enable
 */
static const size_t e10k_ftqf_length = 128;
static inline e10k_ftqf_t e10k_ftqf_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8))));
}

static inline e10k_ftqf_t e10k_ftqf_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_ftqf_t e10k_ftqf_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8))));
}

static inline void e10k_ftqf_rawwr(__DN(t) *_dev, int _i, e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_ftqf_rawwr(__DN(t) *_dev, int _i, e10k_ftqf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
}

static inline void e10k_ftqf_wr(__DN(t) *_dev, int _i, e10k_ftqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_ftqf_wr(__DN(t) *_dev, int _i, e10k_ftqf_t _regval)
{
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
}

static inline int e10k_ftqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_ftqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "ftqf", _i, "Five tuple Queue Filter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " protocol =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_l4_proto_prtval(_s + _r, _avail, e10k_ftqf_protocol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(IP L4 protocol)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " priority =\t%" PRIx8 "\t(Priority value in case more than one 5-tuple filter matches)\n", e10k_ftqf_priority_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool =\t%" PRIx8 "\t(The pool Index of the pool associated with this filter)\n", e10k_ftqf_pool_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_srcaddr =\t%" PRIx8 "\t(Mask source address comparison)\n", e10k_ftqf_m_srcaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_dstaddr =\t%" PRIx8 "\t(Mask destination address comparison)\n", e10k_ftqf_m_dstaddr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_srcport =\t%" PRIx8 "\t(Mask source port comparison)\n", e10k_ftqf_m_srcport_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_dstport =\t%" PRIx8 "\t(Mask destination port comparison)\n", e10k_ftqf_m_dstport_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " m_protocol =\t%" PRIx8 "\t(Mask protocol comparison)\n", e10k_ftqf_m_protocol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool_mask =\t%" PRIx8 "\t(Mask bit for the Pool field)\n", e10k_ftqf_pool_mask_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_en =\t%" PRIx8 "\t(Queue Enable)\n", e10k_ftqf_queue_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_ftqf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_ftqf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_ftqf_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline e10k_l4_proto_t e10k_ftqf_protocol_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_l4_proto_t e10k_ftqf_protocol_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_protocol_extract(_regval));
}

static inline uint8_t e10k_ftqf_priority_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_priority_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_priority_extract(_regval));
}

static inline uint8_t e10k_ftqf_pool_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_pool_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_pool_extract(_regval));
}

static inline uint8_t e10k_ftqf_m_srcaddr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_srcaddr_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_m_srcaddr_extract(_regval));
}

static inline uint8_t e10k_ftqf_m_dstaddr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_dstaddr_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_m_dstaddr_extract(_regval));
}

static inline uint8_t e10k_ftqf_m_srcport_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_srcport_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_m_srcport_extract(_regval));
}

static inline uint8_t e10k_ftqf_m_dstport_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_dstport_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_m_dstport_extract(_regval));
}

static inline uint8_t e10k_ftqf_m_protocol_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_m_protocol_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_m_protocol_extract(_regval));
}

static inline uint8_t e10k_ftqf_pool_mask_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_pool_mask_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_pool_mask_extract(_regval));
}

static inline uint8_t e10k_ftqf_queue_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_ftqf_queue_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_ftqf_t _regval = mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)));
    return(e10k_ftqf_queue_en_extract(_regval));
}

static inline void e10k_ftqf_protocol_wrf(__DN(t) *_dev, int _i, e10k_l4_proto_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_protocol_wrf(__DN(t) *_dev, int _i, e10k_l4_proto_t _fieldval)
{
    e10k_ftqf_t _regval = 0x3 & (((e10k_ftqf_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfe003f1c & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_priority_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_priority_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x1c & (((e10k_ftqf_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfe003f03 & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_pool_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_pool_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x3f00 & (((e10k_ftqf_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfe00001f & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_m_srcaddr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_m_srcaddr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x2000000 & (((e10k_ftqf_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfc003f1f & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_m_dstaddr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_m_dstaddr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x4000000 & (((e10k_ftqf_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfa003f1f & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_m_srcport_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_m_srcport_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x8000000 & (((e10k_ftqf_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf6003f1f & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_m_dstport_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_m_dstport_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x10000000 & (((e10k_ftqf_t )(_fieldval)) << 28);
    _regval = (_regval | (0xee003f1f & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_m_protocol_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_m_protocol_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x20000000 & (((e10k_ftqf_t )(_fieldval)) << 29);
    _regval = (_regval | (0xde003f1f & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_pool_mask_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_pool_mask_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x40000000 & (((e10k_ftqf_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbe003f1f & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_ftqf_queue_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_ftqf_queue_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_ftqf_t _regval = 0x80000000 & (((e10k_ftqf_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7e003f1f & mackerel_read_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)))));
    // No read of register shadow required
    _regval = (_regval & 0xfe003f1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xe600 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register synqf: SYN Packet Queue Filter
 * Type: e10k.synqf (Implicit type of SYN Packet Queue Filter register)
 *   queue_en	(size 1, offset 0, init 0):	RW	Queue Enable
 *   rx_queue	(size 7, offset 1, init 0):	RW	Identifies an Rx queue associated with SYN packets
 *   _anon8	(size 23, offset 8, init 0):	RSVD	_
 *   synqfp	(size 1, offset 31, init 0):	RW	Defines the priority between SYNQF and 5-tuples filter
 */
static inline e10k_synqf_t e10k_synqf_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_synqf_t e10k_synqf_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec30));
}

static inline e10k_synqf_t e10k_synqf_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_synqf_t e10k_synqf_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xec30));
}

static inline void e10k_synqf_rawwr(__DN(t) *_dev, e10k_synqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_synqf_rawwr(__DN(t) *_dev, e10k_synqf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xec30, _regval);
}

static inline void e10k_synqf_wr(__DN(t) *_dev, e10k_synqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_synqf_wr(__DN(t) *_dev, e10k_synqf_t _regval)
{
    _regval = (_regval & 0x800000ff);
    // No MB1 fields present
    _regval = (_regval | (0x7fffff00 & mackerel_read_addr_32(_dev->base, 0xec30)));
    mackerel_write_addr_32(_dev->base, 0xec30, _regval);
}

static inline int e10k_synqf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_synqf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_synqf_t _regval = mackerel_read_addr_32(_dev->base, 0xec30);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register synqf (SYN Packet Queue Filter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_en =\t%" PRIx8 "\t(Queue Enable)\n", e10k_synqf_queue_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_queue =\t%" PRIx8 "\t(Identifies an Rx queue associated with SYN packets)\n", e10k_synqf_rx_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " synqfp =\t%" PRIx8 "\t(Defines the priority between SYNQF and 5-tuples filter)\n", e10k_synqf_synqfp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_synqf_queue_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_synqf_queue_en_rdf(__DN(t) *_dev)
{
    e10k_synqf_t _regval = mackerel_read_addr_32(_dev->base, 0xec30);
    return(e10k_synqf_queue_en_extract(_regval));
}

static inline uint8_t e10k_synqf_rx_queue_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_synqf_rx_queue_rdf(__DN(t) *_dev)
{
    e10k_synqf_t _regval = mackerel_read_addr_32(_dev->base, 0xec30);
    return(e10k_synqf_rx_queue_extract(_regval));
}

static inline uint8_t e10k_synqf_synqfp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_synqf_synqfp_rdf(__DN(t) *_dev)
{
    e10k_synqf_t _regval = mackerel_read_addr_32(_dev->base, 0xec30);
    return(e10k_synqf_synqfp_extract(_regval));
}

static inline void e10k_synqf_queue_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_synqf_queue_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_synqf_t _regval = 0x1 & (((e10k_synqf_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xec30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec30, _regval);
    // No shadow register to write to
}

static inline void e10k_synqf_rx_queue_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_synqf_rx_queue_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_synqf_t _regval = 0xfe & (((e10k_synqf_t )(_fieldval)) << 1);
    _regval = (_regval | (0xffffff01 & mackerel_read_addr_32(_dev->base, 0xec30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec30, _regval);
    // No shadow register to write to
}

static inline void e10k_synqf_synqfp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_synqf_synqfp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_synqf_t _regval = 0x80000000 & (((e10k_synqf_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xec30)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec30, _regval);
    // No shadow register to write to
}

/*
 * Register array etqf: EType Queue Filter
 * Type: e10k.etqf (Implicit type of EType Queue Filter register array)
 *   etype	(size 16, offset 0, init 0):	RW	Identifies the protocol running on top of IEEE 802
 *   uprio	(size 3, offset 16, init 0):	RW	User Priority
 *   uprio_en	(size 1, offset 19, init 0):	RW	User Priority Enable
 *   pool	(size 6, offset 20, init 0):	RW	Determines the target pool for the packet
 *   pool_en	(size 1, offset 26, init 0):	RW	Pool Enable
 *   fcoe	(size 1, offset 27, init 0):	RW	FCoE
 *   _anon28	(size 2, offset 28, init 0):	RSVD	_
 *   timestamp	(size 1, offset 30, init 0):	RW	IEEE 1588 time stamp
 *   filter_en	(size 1, offset 31, init 0):	RW	Filter Enable
 */
static const size_t e10k_etqf_length = 8;
static inline e10k_etqf_t e10k_etqf_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8))));
}

static inline e10k_etqf_t e10k_etqf_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_etqf_t e10k_etqf_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8))));
}

static inline void e10k_etqf_rawwr(__DN(t) *_dev, int _i, e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_etqf_rawwr(__DN(t) *_dev, int _i, e10k_etqf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
}

static inline void e10k_etqf_wr(__DN(t) *_dev, int _i, e10k_etqf_t _regval) __attribute__ ((always_inline));
static inline void e10k_etqf_wr(__DN(t) *_dev, int _i, e10k_etqf_t _regval)
{
    _regval = (_regval & 0xcfffffff);
    // No MB1 fields present
    _regval = (_regval | (0x30000000 & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
}

static inline int e10k_etqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_etqf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "etqf", _i, "EType Queue Filter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " etype =\t%" PRIx16 "\t(Identifies the protocol running on top of IEEE 802)\n", e10k_etqf_etype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uprio =\t%" PRIx8 "\t(User Priority)\n", e10k_etqf_uprio_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " uprio_en =\t%" PRIx8 "\t(User Priority Enable)\n", e10k_etqf_uprio_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool =\t%" PRIx8 "\t(Determines the target pool for the packet)\n", e10k_etqf_pool_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool_en =\t%" PRIx8 "\t(Pool Enable)\n", e10k_etqf_pool_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcoe =\t%" PRIx8 "\t(FCoE)\n", e10k_etqf_fcoe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " timestamp =\t%" PRIx8 "\t(IEEE 1588 time stamp)\n", e10k_etqf_timestamp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " filter_en =\t%" PRIx8 "\t(Filter Enable)\n", e10k_etqf_filter_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_etqf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_etqf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_etqf_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_etqf_etype_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_etqf_etype_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    return(e10k_etqf_etype_extract(_regval));
}

static inline uint8_t e10k_etqf_uprio_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_uprio_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    return(e10k_etqf_uprio_extract(_regval));
}

static inline uint8_t e10k_etqf_uprio_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_uprio_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    return(e10k_etqf_uprio_en_extract(_regval));
}

static inline uint8_t e10k_etqf_pool_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_pool_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    return(e10k_etqf_pool_extract(_regval));
}

static inline uint8_t e10k_etqf_pool_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_pool_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    return(e10k_etqf_pool_en_extract(_regval));
}

static inline uint8_t e10k_etqf_fcoe_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_fcoe_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    return(e10k_etqf_fcoe_extract(_regval));
}

static inline uint8_t e10k_etqf_timestamp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_timestamp_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    return(e10k_etqf_timestamp_extract(_regval));
}

static inline uint8_t e10k_etqf_filter_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqf_filter_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqf_t _regval = mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)));
    return(e10k_etqf_filter_en_extract(_regval));
}

static inline void e10k_etqf_etype_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqf_etype_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_etqf_t _regval = 0xffff & (((e10k_etqf_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqf_uprio_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqf_uprio_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqf_t _regval = 0x70000 & (((e10k_etqf_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff8ffff & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqf_uprio_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqf_uprio_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqf_t _regval = 0x80000 & (((e10k_etqf_t )(_fieldval)) << 19);
    _regval = (_regval | (0xfff7ffff & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqf_pool_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqf_pool_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqf_t _regval = 0x3f00000 & (((e10k_etqf_t )(_fieldval)) << 20);
    _regval = (_regval | (0xfc0fffff & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqf_pool_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqf_pool_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqf_t _regval = 0x4000000 & (((e10k_etqf_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqf_fcoe_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqf_fcoe_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqf_t _regval = 0x8000000 & (((e10k_etqf_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7ffffff & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqf_timestamp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqf_timestamp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqf_t _regval = 0x40000000 & (((e10k_etqf_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqf_filter_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqf_filter_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqf_t _regval = 0x80000000 & (((e10k_etqf_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5128 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array etqs: EType Queue Select
 * Type: e10k.etqs (Implicit type of EType Queue Select register array)
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   rx_queue	(size 7, offset 16, init 0):	RW	Identifies the Rx queue associated with this EType
 *   _anon23	(size 6, offset 23, init 0):	RSVD	_
 *   lli	(size 1, offset 29, init 0):	RW	When set, packets that match this filter generate a LLI
 *   _anon30	(size 1, offset 30, init 0):	RSVD	_
 *   queue_en	(size 1, offset 31, init 0):	RW	Queue Enable
 */
static const size_t e10k_etqs_length = 8;
static inline e10k_etqs_t e10k_etqs_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_etqs_t e10k_etqs_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8))));
}

static inline e10k_etqs_t e10k_etqs_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_etqs_t e10k_etqs_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8))));
}

static inline void e10k_etqs_rawwr(__DN(t) *_dev, int _i, e10k_etqs_t _regval) __attribute__ ((always_inline));
static inline void e10k_etqs_rawwr(__DN(t) *_dev, int _i, e10k_etqs_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)), _regval);
}

static inline void e10k_etqs_wr(__DN(t) *_dev, int _i, e10k_etqs_t _regval) __attribute__ ((always_inline));
static inline void e10k_etqs_wr(__DN(t) *_dev, int _i, e10k_etqs_t _regval)
{
    _regval = (_regval & 0xa07f0000);
    // No MB1 fields present
    _regval = (_regval | (0x5f80ffff & mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)), _regval);
}

static inline int e10k_etqs_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_etqs_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_etqs_t _regval = mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "etqs", _i, "EType Queue Select");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_queue =\t%" PRIx8 "\t(Identifies the Rx queue associated with this EType)\n", e10k_etqs_rx_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lli =\t%" PRIx8 "\t(When set, packets that match this filter generate a LLI)\n", e10k_etqs_lli_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_en =\t%" PRIx8 "\t(Queue Enable)\n", e10k_etqs_queue_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_etqs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_etqs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_etqs_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_etqs_rx_queue_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqs_rx_queue_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqs_t _regval = mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)));
    return(e10k_etqs_rx_queue_extract(_regval));
}

static inline uint8_t e10k_etqs_lli_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqs_lli_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqs_t _regval = mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)));
    return(e10k_etqs_lli_extract(_regval));
}

static inline uint8_t e10k_etqs_queue_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_etqs_queue_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_etqs_t _regval = mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)));
    return(e10k_etqs_queue_en_extract(_regval));
}

static inline void e10k_etqs_rx_queue_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqs_rx_queue_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqs_t _regval = 0x7f0000 & (((e10k_etqs_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff80ffff & mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqs_lli_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqs_lli_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqs_t _regval = 0x20000000 & (((e10k_etqs_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_etqs_queue_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_etqs_queue_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_etqs_t _regval = 0x80000000 & (((e10k_etqs_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xec00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register rxfeccerr0: Rx Filter ECC Err Insertion 0
 * Type: e10k.rxfeccerr0 (Implicit type of Rx Filter ECC Err Insertion 0 register)
 *   _anon0	(size 9, offset 0, init 0):	RSVD	_
 *   eccflt_en	(size 1, offset 9, init 0):	RW	Filter ECC Error indication Enablement
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
static inline e10k_rxfeccerr0_t e10k_rxfeccerr0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rxfeccerr0_t e10k_rxfeccerr0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x51b8));
}

static inline e10k_rxfeccerr0_t e10k_rxfeccerr0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rxfeccerr0_t e10k_rxfeccerr0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x51b8));
}

static inline void e10k_rxfeccerr0_rawwr(__DN(t) *_dev, e10k_rxfeccerr0_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxfeccerr0_rawwr(__DN(t) *_dev, e10k_rxfeccerr0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x51b8, _regval);
}

static inline void e10k_rxfeccerr0_wr(__DN(t) *_dev, e10k_rxfeccerr0_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxfeccerr0_wr(__DN(t) *_dev, e10k_rxfeccerr0_t _regval)
{
    _regval = (_regval & 0x200);
    // No MB1 fields present
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x51b8)));
    mackerel_write_addr_32(_dev->base, 0x51b8, _regval);
}

static inline int e10k_rxfeccerr0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxfeccerr0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rxfeccerr0_t _regval = mackerel_read_addr_32(_dev->base, 0x51b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxfeccerr0 (Rx Filter ECC Err Insertion 0): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eccflt_en =\t%" PRIx8 "\t(Filter ECC Error indication Enablement)\n", e10k_rxfeccerr0_eccflt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline uint8_t e10k_rxfeccerr0_eccflt_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxfeccerr0_eccflt_en_rdf(__DN(t) *_dev)
{
    e10k_rxfeccerr0_t _regval = mackerel_read_addr_32(_dev->base, 0x51b8);
    return(e10k_rxfeccerr0_eccflt_en_extract(_regval));
}

static inline void e10k_rxfeccerr0_eccflt_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxfeccerr0_eccflt_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rxfeccerr0_t _regval = 0x200 & (((e10k_rxfeccerr0_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x51b8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x51b8, _regval);
    // No shadow register to write to
}

/*
 * Register array rdbal_1: Receive Descriptor Base Address Low (#0-#63)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdbal_1_length = 64;
static inline uint32_t e10k_rdbal_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdbal_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1000 + (_i * 64)));
}

static inline uint32_t e10k_rdbal_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdbal_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1000 + (_i * 64)));
}

static inline void e10k_rdbal_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdbal_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1000 + (_i * 64), _regval);
}

static inline void e10k_rdbal_1_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdbal_1_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1000 + (_i * 64), _regval);
}

static inline int e10k_rdbal_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdbal_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1000 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdbal_1", _i, "Receive Descriptor Base Address Low (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdbal_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdbal_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdbal_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdbal_2: Receive Descriptor Base Address Low (#64-#127)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdbal_2_length = 64;
static inline uint32_t e10k_rdbal_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdbal_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd000 + (_i * 64)));
}

static inline uint32_t e10k_rdbal_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdbal_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd000 + (_i * 64)));
}

static inline void e10k_rdbal_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdbal_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd000 + (_i * 64), _regval);
}

static inline void e10k_rdbal_2_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdbal_2_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xd000 + (_i * 64), _regval);
}

static inline int e10k_rdbal_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdbal_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0xd000 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdbal_2", _i, "Receive Descriptor Base Address Low (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdbal_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdbal_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdbal_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdbah_1: Receive Descriptor Base Address High (#0-#63)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdbah_1_length = 64;
static inline uint32_t e10k_rdbah_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdbah_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1004 + (_i * 64)));
}

static inline uint32_t e10k_rdbah_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdbah_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1004 + (_i * 64)));
}

static inline void e10k_rdbah_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdbah_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1004 + (_i * 64), _regval);
}

static inline void e10k_rdbah_1_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdbah_1_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1004 + (_i * 64), _regval);
}

static inline int e10k_rdbah_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdbah_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1004 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdbah_1", _i, "Receive Descriptor Base Address High (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdbah_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdbah_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdbah_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdbah_2: Receive Descriptor Base Address High (#64-#127)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdbah_2_length = 64;
static inline uint32_t e10k_rdbah_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdbah_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd004 + (_i * 64)));
}

static inline uint32_t e10k_rdbah_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdbah_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd004 + (_i * 64)));
}

static inline void e10k_rdbah_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdbah_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd004 + (_i * 64), _regval);
}

static inline void e10k_rdbah_2_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdbah_2_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xd004 + (_i * 64), _regval);
}

static inline int e10k_rdbah_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdbah_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0xd004 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdbah_2", _i, "Receive Descriptor Base Address High (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdbah_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdbah_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdbah_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdlen_1: Receive Descriptor Length (#0-#63)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdlen_1_length = 64;
static inline uint32_t e10k_rdlen_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdlen_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1008 + (_i * 64)));
}

static inline uint32_t e10k_rdlen_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdlen_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1008 + (_i * 64)));
}

static inline void e10k_rdlen_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdlen_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1008 + (_i * 64), _regval);
}

static inline void e10k_rdlen_1_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdlen_1_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1008 + (_i * 64), _regval);
}

static inline int e10k_rdlen_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdlen_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1008 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdlen_1", _i, "Receive Descriptor Length (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdlen_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdlen_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdlen_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdlen_2: Receive Descriptor Length (#64-#127)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdlen_2_length = 64;
static inline uint32_t e10k_rdlen_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdlen_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd008 + (_i * 64)));
}

static inline uint32_t e10k_rdlen_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdlen_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd008 + (_i * 64)));
}

static inline void e10k_rdlen_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdlen_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd008 + (_i * 64), _regval);
}

static inline void e10k_rdlen_2_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdlen_2_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xd008 + (_i * 64), _regval);
}

static inline int e10k_rdlen_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdlen_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0xd008 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdlen_2", _i, "Receive Descriptor Length (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdlen_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdlen_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdlen_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdh_1: Receive Descriptor Head (#0-#63)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdh_1_length = 64;
static inline uint32_t e10k_rdh_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdh_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1010 + (_i * 64)));
}

static inline uint32_t e10k_rdh_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdh_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1010 + (_i * 64)));
}

static inline void e10k_rdh_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdh_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1010 + (_i * 64), _regval);
}

static inline void e10k_rdh_1_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdh_1_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1010 + (_i * 64), _regval);
}

static inline int e10k_rdh_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdh_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1010 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdh_1", _i, "Receive Descriptor Head (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdh_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdh_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdh_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdh_2: Receive Descriptor Head (#64-#127)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdh_2_length = 64;
static inline uint32_t e10k_rdh_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdh_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd010 + (_i * 64)));
}

static inline uint32_t e10k_rdh_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdh_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd010 + (_i * 64)));
}

static inline void e10k_rdh_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdh_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd010 + (_i * 64), _regval);
}

static inline void e10k_rdh_2_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdh_2_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xd010 + (_i * 64), _regval);
}

static inline int e10k_rdh_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdh_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0xd010 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdh_2", _i, "Receive Descriptor Head (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdh_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdh_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdh_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdt_1: Receive Descriptor Tail (#0-#63)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdt_1_length = 64;
static inline uint32_t e10k_rdt_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdt_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1018 + (_i * 64)));
}

static inline uint32_t e10k_rdt_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdt_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1018 + (_i * 64)));
}

static inline void e10k_rdt_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdt_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1018 + (_i * 64), _regval);
}

static inline void e10k_rdt_1_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdt_1_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x1018 + (_i * 64), _regval);
}

static inline int e10k_rdt_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdt_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1018 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdt_1", _i, "Receive Descriptor Tail (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdt_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdt_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdt_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rdt_2: Receive Descriptor Tail (#64-#127)
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rdt_2_length = 64;
static inline uint32_t e10k_rdt_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdt_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd018 + (_i * 64)));
}

static inline uint32_t e10k_rdt_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rdt_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd018 + (_i * 64)));
}

static inline void e10k_rdt_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdt_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd018 + (_i * 64), _regval);
}

static inline void e10k_rdt_2_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdt_2_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xd018 + (_i * 64), _regval);
}

static inline int e10k_rdt_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rdt_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0xd018 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rdt_2", _i, "Receive Descriptor Tail (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rdt_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdt_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rdt_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array rxdctl_1: Receive Descriptor Tail (#0-#63)
 * Type: e10k.rxdctl (Receive Descriptor Control)
 *   _anon0	(size 25, offset 0, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	RW	Receive Queue Enable
 *   _anon26	(size 4, offset 26, init 0):	RSVD	_
 *   vme	(size 1, offset 30, init 0):	RW	VLAN Mode Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static const size_t e10k_rxdctl_1_length = 64;
static inline e10k_rxdctl_t e10k_rxdctl_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rxdctl_t e10k_rxdctl_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64)));
}

static inline e10k_rxdctl_t e10k_rxdctl_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rxdctl_t e10k_rxdctl_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64)));
}

static inline void e10k_rxdctl_1_rawwr(__DN(t) *_dev, int _i, e10k_rxdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxdctl_1_rawwr(__DN(t) *_dev, int _i, e10k_rxdctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1028 + (_i * 64), _regval);
}

static inline void e10k_rxdctl_1_wr(__DN(t) *_dev, int _i, e10k_rxdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxdctl_1_wr(__DN(t) *_dev, int _i, e10k_rxdctl_t _regval)
{
    _regval = (_regval & 0x42000000);
    // No MB1 fields present
    _regval = (_regval | (0xbdffffff & mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x1028 + (_i * 64), _regval);
}

static inline int e10k_rxdctl_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rxdctl_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rxdctl_1", _i, "Receive Descriptor Tail (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Receive Queue Enable)\n", e10k_rxdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN Mode Enable)\n", e10k_rxdctl_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline int e10k_rxdctl_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxdctl_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rxdctl_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_rxdctl_1_enable_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rxdctl_1_enable_rdf(__DN(t) *_dev, int _i)
{
    e10k_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64));
    return(e10k_rxdctl_enable_extract(_regval));
}

static inline uint8_t e10k_rxdctl_1_vme_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rxdctl_1_vme_rdf(__DN(t) *_dev, int _i)
{
    e10k_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64));
    return(e10k_rxdctl_vme_extract(_regval));
}

static inline void e10k_rxdctl_1_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxdctl_1_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rxdctl_t _regval = 0x2000000 & (((e10k_rxdctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_rxdctl_1_vme_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxdctl_1_vme_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rxdctl_t _regval = 0x40000000 & (((e10k_rxdctl_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x1028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1028 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array rxdctl_2: Receive Descriptor Tail (#64-#127)
 * Type: e10k.rxdctl (Receive Descriptor Control)
 *   _anon0	(size 25, offset 0, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	RW	Receive Queue Enable
 *   _anon26	(size 4, offset 26, init 0):	RSVD	_
 *   vme	(size 1, offset 30, init 0):	RW	VLAN Mode Enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static const size_t e10k_rxdctl_2_length = 64;
static inline e10k_rxdctl_t e10k_rxdctl_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rxdctl_t e10k_rxdctl_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd028 + (_i * 64)));
}

static inline e10k_rxdctl_t e10k_rxdctl_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rxdctl_t e10k_rxdctl_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd028 + (_i * 64)));
}

static inline void e10k_rxdctl_2_rawwr(__DN(t) *_dev, int _i, e10k_rxdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxdctl_2_rawwr(__DN(t) *_dev, int _i, e10k_rxdctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd028 + (_i * 64), _regval);
}

static inline void e10k_rxdctl_2_wr(__DN(t) *_dev, int _i, e10k_rxdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxdctl_2_wr(__DN(t) *_dev, int _i, e10k_rxdctl_t _regval)
{
    _regval = (_regval & 0x42000000);
    // No MB1 fields present
    _regval = (_regval | (0xbdffffff & mackerel_read_addr_32(_dev->base, 0xd028 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xd028 + (_i * 64), _regval);
}

static inline int e10k_rxdctl_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rxdctl_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd028 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rxdctl_2", _i, "Receive Descriptor Tail (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Receive Queue Enable)\n", e10k_rxdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vme =\t%" PRIx8 "\t(VLAN Mode Enable)\n", e10k_rxdctl_vme_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline int e10k_rxdctl_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxdctl_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rxdctl_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_rxdctl_2_enable_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rxdctl_2_enable_rdf(__DN(t) *_dev, int _i)
{
    e10k_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd028 + (_i * 64));
    return(e10k_rxdctl_enable_extract(_regval));
}

static inline uint8_t e10k_rxdctl_2_vme_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rxdctl_2_vme_rdf(__DN(t) *_dev, int _i)
{
    e10k_rxdctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd028 + (_i * 64));
    return(e10k_rxdctl_vme_extract(_regval));
}

static inline void e10k_rxdctl_2_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxdctl_2_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rxdctl_t _regval = 0x2000000 & (((e10k_rxdctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0xd028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_rxdctl_2_vme_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxdctl_2_vme_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rxdctl_t _regval = 0x40000000 & (((e10k_rxdctl_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0xd028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd028 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array srrctl_1: Split Receive Control Registers (#0-#63)
 * Type: e10k.srrctl (Split Receive Control Registers)
 *   bsz_pkt	(size 5, offset 0, init 0):	RW	Receive Buffer Size for Packet Buffer
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   bsz_hdr	(size 6, offset 8, init 0):	RW	Receive Buffer Size for Header Buffer
 *   _anon14	(size 8, offset 14, init 0):	RSVD	_
 *   rdmts	(size 3, offset 22, init 0):	RW	Receive Descriptor Minimum Threshold Size
 *   desctype	(size 3, offset 25, init 0):	RW	Define the descriptor type
 *   drop_en	(size 1, offset 28, init 0):	RW	Drop Enabled
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
static const size_t e10k_srrctl_1_length = 64;
static inline e10k_srrctl_t e10k_srrctl_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64)));
}

static inline e10k_srrctl_t e10k_srrctl_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64)));
}

static inline void e10k_srrctl_1_rawwr(__DN(t) *_dev, int _i, e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_srrctl_1_rawwr(__DN(t) *_dev, int _i, e10k_srrctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
}

static inline void e10k_srrctl_1_wr(__DN(t) *_dev, int _i, e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_srrctl_1_wr(__DN(t) *_dev, int _i, e10k_srrctl_t _regval)
{
    _regval = (_regval & 0x1fc03f1f);
    // No MB1 fields present
    _regval = (_regval | (0xe03fc000 & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
}

static inline int e10k_srrctl_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_srrctl_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "srrctl_1", _i, "Split Receive Control Registers (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_pkt =\t%" PRIx8 "\t(Receive Buffer Size for Packet Buffer)\n", e10k_srrctl_bsz_pkt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_hdr =\t%" PRIx8 "\t(Receive Buffer Size for Header Buffer)\n", e10k_srrctl_bsz_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdmts =\t%" PRIx8 "\t(Receive Descriptor Minimum Threshold Size)\n", e10k_srrctl_rdmts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desctype =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rx_desctype_prtval(_s + _r, _avail, e10k_srrctl_desctype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Define the descriptor type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop_en =\t%" PRIx8 "\t(Drop Enabled)\n", e10k_srrctl_drop_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline int e10k_srrctl_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_srrctl_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_srrctl_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_srrctl_1_bsz_pkt_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_1_bsz_pkt_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_srrctl_bsz_pkt_extract(_regval));
}

static inline uint8_t e10k_srrctl_1_bsz_hdr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_1_bsz_hdr_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_srrctl_bsz_hdr_extract(_regval));
}

static inline uint8_t e10k_srrctl_1_rdmts_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_1_rdmts_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_srrctl_rdmts_extract(_regval));
}

static inline e10k_rx_desctype_t e10k_srrctl_1_desctype_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rx_desctype_t e10k_srrctl_1_desctype_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_srrctl_desctype_extract(_regval));
}

static inline uint8_t e10k_srrctl_1_drop_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_1_drop_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64));
    return(e10k_srrctl_drop_en_extract(_regval));
}

static inline void e10k_srrctl_1_bsz_pkt_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_1_bsz_pkt_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_srrctl_t _regval = 0x1f & (((e10k_srrctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_srrctl_1_bsz_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_1_bsz_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_srrctl_t _regval = 0x3f00 & (((e10k_srrctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffffc01f & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_srrctl_1_rdmts_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_1_rdmts_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_srrctl_t _regval = 0x1c00000 & (((e10k_srrctl_t )(_fieldval)) << 22);
    _regval = (_regval | (0xfe3fff1f & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_srrctl_1_desctype_wrf(__DN(t) *_dev, int _i, e10k_rx_desctype_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_1_desctype_wrf(__DN(t) *_dev, int _i, e10k_rx_desctype_t _fieldval)
{
    e10k_srrctl_t _regval = 0xe000000 & (((e10k_srrctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xf1ffff1f & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_srrctl_1_drop_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_1_drop_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_srrctl_t _regval = 0x10000000 & (((e10k_srrctl_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffff1f & mackerel_read_addr_32(_dev->base, 0x1014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x1014 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array srrctl_2: Split Receive Control Registers (#64-#127)
 * Type: e10k.srrctl (Split Receive Control Registers)
 *   bsz_pkt	(size 5, offset 0, init 0):	RW	Receive Buffer Size for Packet Buffer
 *   _anon5	(size 3, offset 5, init 0):	MBZ	_
 *   bsz_hdr	(size 6, offset 8, init 0):	RW	Receive Buffer Size for Header Buffer
 *   _anon14	(size 8, offset 14, init 0):	RSVD	_
 *   rdmts	(size 3, offset 22, init 0):	RW	Receive Descriptor Minimum Threshold Size
 *   desctype	(size 3, offset 25, init 0):	RW	Define the descriptor type
 *   drop_en	(size 1, offset 28, init 0):	RW	Drop Enabled
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
static const size_t e10k_srrctl_2_length = 64;
static inline e10k_srrctl_t e10k_srrctl_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64)));
}

static inline e10k_srrctl_t e10k_srrctl_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_srrctl_t e10k_srrctl_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64)));
}

static inline void e10k_srrctl_2_rawwr(__DN(t) *_dev, int _i, e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_srrctl_2_rawwr(__DN(t) *_dev, int _i, e10k_srrctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd014 + (_i * 64), _regval);
}

static inline void e10k_srrctl_2_wr(__DN(t) *_dev, int _i, e10k_srrctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_srrctl_2_wr(__DN(t) *_dev, int _i, e10k_srrctl_t _regval)
{
    _regval = (_regval & 0x1fc03f1f);
    // No MB1 fields present
    _regval = (_regval | (0xe03fc000 & mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xd014 + (_i * 64), _regval);
}

static inline int e10k_srrctl_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_srrctl_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "srrctl_2", _i, "Split Receive Control Registers (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_pkt =\t%" PRIx8 "\t(Receive Buffer Size for Packet Buffer)\n", e10k_srrctl_bsz_pkt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bsz_hdr =\t%" PRIx8 "\t(Receive Buffer Size for Header Buffer)\n", e10k_srrctl_bsz_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rdmts =\t%" PRIx8 "\t(Receive Descriptor Minimum Threshold Size)\n", e10k_srrctl_rdmts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " desctype =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rx_desctype_prtval(_s + _r, _avail, e10k_srrctl_desctype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Define the descriptor type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop_en =\t%" PRIx8 "\t(Drop Enabled)\n", e10k_srrctl_drop_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline int e10k_srrctl_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_srrctl_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_srrctl_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_srrctl_2_bsz_pkt_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_2_bsz_pkt_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64));
    return(e10k_srrctl_bsz_pkt_extract(_regval));
}

static inline uint8_t e10k_srrctl_2_bsz_hdr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_2_bsz_hdr_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64));
    return(e10k_srrctl_bsz_hdr_extract(_regval));
}

static inline uint8_t e10k_srrctl_2_rdmts_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_2_rdmts_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64));
    return(e10k_srrctl_rdmts_extract(_regval));
}

static inline e10k_rx_desctype_t e10k_srrctl_2_desctype_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rx_desctype_t e10k_srrctl_2_desctype_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64));
    return(e10k_srrctl_desctype_extract(_regval));
}

static inline uint8_t e10k_srrctl_2_drop_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_srrctl_2_drop_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_srrctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64));
    return(e10k_srrctl_drop_en_extract(_regval));
}

static inline void e10k_srrctl_2_bsz_pkt_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_2_bsz_pkt_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_srrctl_t _regval = 0x1f & (((e10k_srrctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_srrctl_2_bsz_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_2_bsz_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_srrctl_t _regval = 0x3f00 & (((e10k_srrctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffffc01f & mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_srrctl_2_rdmts_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_2_rdmts_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_srrctl_t _regval = 0x1c00000 & (((e10k_srrctl_t )(_fieldval)) << 22);
    _regval = (_regval | (0xfe3fff1f & mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_srrctl_2_desctype_wrf(__DN(t) *_dev, int _i, e10k_rx_desctype_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_2_desctype_wrf(__DN(t) *_dev, int _i, e10k_rx_desctype_t _fieldval)
{
    e10k_srrctl_t _regval = 0xe000000 & (((e10k_srrctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xf1ffff1f & mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd014 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_srrctl_2_drop_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_srrctl_2_drop_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_srrctl_t _regval = 0x10000000 & (((e10k_srrctl_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffff1f & mackerel_read_addr_32(_dev->base, 0xd014 + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xffffff1f);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd014 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register rdrxctl: Receive DMA Control Register
 * Type: e10k.rdrxctl (Implicit type of Receive DMA Control Register register)
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   crcstrip	(size 1, offset 1, init 0):	RW	Rx CRC Strip indication to the Rx DMA unit
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   dma_initok	(size 1, offset 3, init 0):	RO	DMA Init Done
 *   _anon4	(size 13, offset 4, init 0):	RSVD	_
 *   rscfrstsz	(size 5, offset 17, init 0):	MBZ	Defines a minimum packet size for a RSC packet
 *   _anon22	(size 3, offset 22, init 0):	RSVD	_
 *   rscackc	(size 1, offset 25, init 1):	MB1	RSC Coalescing on ACK Change
 *   fcoe_wrfix	(size 1, offset 26, init 1):	MB1	FCoE Write Exchange Fix
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static inline e10k_rdrxctl_t e10k_rdrxctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rdrxctl_t e10k_rdrxctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f00));
}

static inline e10k_rdrxctl_t e10k_rdrxctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rdrxctl_t e10k_rdrxctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f00));
}

static inline void e10k_rdrxctl_rawwr(__DN(t) *_dev, e10k_rdrxctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdrxctl_rawwr(__DN(t) *_dev, e10k_rdrxctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2f00, _regval);
}

static inline void e10k_rdrxctl_wr(__DN(t) *_dev, e10k_rdrxctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rdrxctl_wr(__DN(t) *_dev, e10k_rdrxctl_t _regval)
{
    _regval = (_regval & 0x600000a);
    _regval = (_regval | 0x6000000);
    _regval = (_regval | (0xf9c1fff5 & mackerel_read_addr_32(_dev->base, 0x2f00)));
    mackerel_write_addr_32(_dev->base, 0x2f00, _regval);
}

static inline int e10k_rdrxctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rdrxctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rdrxctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2f00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rdrxctl (Receive DMA Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crcstrip =\t%" PRIx8 "\t(Rx CRC Strip indication to the Rx DMA unit)\n", e10k_rdrxctl_crcstrip_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dma_initok =\t%" PRIx8 "\t(DMA Init Done)\n", e10k_rdrxctl_dma_initok_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rscfrstsz =\t%" PRIx8 "\t(Defines a minimum packet size for a RSC packet)\n", e10k_rdrxctl_rscfrstsz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon22 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rscackc =\t%" PRIx8 "\t(RSC Coalescing on ACK Change)\n", e10k_rdrxctl_rscackc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fcoe_wrfix =\t%" PRIx8 "\t(FCoE Write Exchange Fix)\n", e10k_rdrxctl_fcoe_wrfix_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline uint8_t e10k_rdrxctl_crcstrip_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rdrxctl_crcstrip_rdf(__DN(t) *_dev)
{
    e10k_rdrxctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2f00);
    return(e10k_rdrxctl_crcstrip_extract(_regval));
}

static inline uint8_t e10k_rdrxctl_dma_initok_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rdrxctl_dma_initok_rdf(__DN(t) *_dev)
{
    e10k_rdrxctl_t _regval = mackerel_read_addr_32(_dev->base, 0x2f00);
    return(e10k_rdrxctl_dma_initok_extract(_regval));
}

static inline void e10k_rdrxctl_crcstrip_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rdrxctl_crcstrip_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rdrxctl_t _regval = 0x2 & (((e10k_rdrxctl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xf9c1fff5 & mackerel_read_addr_32(_dev->base, 0x2f00)));
    // No read of register shadow required
    _regval = (_regval & 0xffc1ffff);
    _regval = (_regval | 0x6000000);
    mackerel_write_addr_32(_dev->base, 0x2f00, _regval);
    // No shadow register to write to
}

/*
 * Register array rxpbsize: Receive Packet Buffer Size
 * Type: e10k.rxpbsize (Implicit type of Receive Packet Buffer Size register array)
 *   _anon0	(size 10, offset 0, init 0):	RSVD	_
 *   size	(size 10, offset 10, init 0):	RW	Receive Packet Buffer Size for traffic class n
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static const size_t e10k_rxpbsize_length = 8;
static inline e10k_rxpbsize_t e10k_rxpbsize_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rxpbsize_t e10k_rxpbsize_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8))));
}

static inline e10k_rxpbsize_t e10k_rxpbsize_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rxpbsize_t e10k_rxpbsize_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8))));
}

static inline void e10k_rxpbsize_rawwr(__DN(t) *_dev, int _i, e10k_rxpbsize_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxpbsize_rawwr(__DN(t) *_dev, int _i, e10k_rxpbsize_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8)), _regval);
}

static inline void e10k_rxpbsize_wr(__DN(t) *_dev, int _i, e10k_rxpbsize_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxpbsize_wr(__DN(t) *_dev, int _i, e10k_rxpbsize_t _regval)
{
    _regval = (_regval & 0xffc00);
    // No MB1 fields present
    _regval = (_regval | (0xfff003ff & mackerel_read_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8)), _regval);
}

static inline int e10k_rxpbsize_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rxpbsize_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rxpbsize_t _regval = mackerel_read_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rxpbsize", _i, "Receive Packet Buffer Size");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Receive Packet Buffer Size for traffic class n)\n", e10k_rxpbsize_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline int e10k_rxpbsize_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxpbsize_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rxpbsize_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_rxpbsize_size_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_rxpbsize_size_rdf(__DN(t) *_dev, int _i)
{
    e10k_rxpbsize_t _regval = mackerel_read_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8)));
    return(e10k_rxpbsize_size_extract(_regval));
}

static inline void e10k_rxpbsize_size_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxpbsize_size_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_rxpbsize_t _regval = 0xffc00 & (((e10k_rxpbsize_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfff003ff & mackerel_read_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3c00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register rxctrl: Receive Control Register
 * Type: e10k.rxctrl (Implicit type of Receive Control Register register)
 *   rxen	(size 1, offset 0, init 0):	RW	Receive Enable
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
static inline e10k_rxctrl_t e10k_rxctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rxctrl_t e10k_rxctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3000));
}

static inline e10k_rxctrl_t e10k_rxctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rxctrl_t e10k_rxctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3000));
}

static inline void e10k_rxctrl_rawwr(__DN(t) *_dev, e10k_rxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxctrl_rawwr(__DN(t) *_dev, e10k_rxctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3000, _regval);
}

static inline void e10k_rxctrl_wr(__DN(t) *_dev, e10k_rxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxctrl_wr(__DN(t) *_dev, e10k_rxctrl_t _regval)
{
    _regval = (_regval & 0x1);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x3000)));
    mackerel_write_addr_32(_dev->base, 0x3000, _regval);
}

static inline int e10k_rxctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x3000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxctrl (Receive Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxen =\t%" PRIx8 "\t(Receive Enable)\n", e10k_rxctrl_rxen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t e10k_rxctrl_rxen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxctrl_rxen_rdf(__DN(t) *_dev)
{
    e10k_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x3000);
    return(e10k_rxctrl_rxen_extract(_regval));
}

static inline void e10k_rxctrl_rxen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rxctrl_rxen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rxctrl_t _regval = 0x1 & (((e10k_rxctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x3000)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3000, _regval);
    // No shadow register to write to
}

/*
 * Register rxmemwrap: Rx Packet Buffer Flush Detect
 * Type: e10k.rxmemwrap (Implicit type of Rx Packet Buffer Flush Detect register)
 *   tc0_wrap	(size 3, offset 0, init 0):	RO	Packet Buffer 0 Wrap Around Counter
 *   tc0_empty	(size 1, offset 3, init 0):	RO	Packet Buffer 0 Empty
 *   tc1_wrap	(size 3, offset 4, init 0):	RO	Packet Buffer 1 Wrap Around Counter
 *   tc1_empty	(size 1, offset 7, init 0):	RO	Packet Buffer 1 Empty
 *   tc2_wrap	(size 3, offset 8, init 0):	RO	Packet Buffer 2 Wrap Around Counter
 *   tc2_empty	(size 1, offset 11, init 0):	RO	Packet Buffer 2 Empty
 *   tc3_wrap	(size 3, offset 12, init 0):	RO	Packet Buffer 3 Wrap Around Counter
 *   tc3_empty	(size 1, offset 15, init 0):	RO	Packet Buffer 3 Empty
 *   tc4_wrap	(size 3, offset 16, init 0):	RO	Packet Buffer 4 Wrap Around Counter
 *   tc4_empty	(size 1, offset 19, init 0):	RO	Packet Buffer 4 Empty
 *   tc5_wrap	(size 3, offset 20, init 0):	RO	Packet Buffer 5 Wrap Around Counter
 *   tc5_empty	(size 1, offset 23, init 0):	RO	Packet Buffer 5 Empty
 *   tc6_wrap	(size 3, offset 24, init 0):	RO	Packet Buffer 6 Wrap Around Counter
 *   tc6_empty	(size 1, offset 27, init 0):	RO	Packet Buffer 6 Empty
 *   tc7_wrap	(size 3, offset 28, init 0):	RO	Packet Buffer 7 Wrap Around Counter
 *   tc7_empty	(size 1, offset 31, init 0):	RO	Packet Buffer 7 Empty
 */
static inline e10k_rxmemwrap_t e10k_rxmemwrap_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3190));
}

static inline e10k_rxmemwrap_t e10k_rxmemwrap_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rxmemwrap_t e10k_rxmemwrap_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3190));
}

static inline void e10k_rxmemwrap_rawwr(__DN(t) *_dev, e10k_rxmemwrap_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxmemwrap_rawwr(__DN(t) *_dev, e10k_rxmemwrap_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3190, _regval);
}

// Register rxmemwrap is not writeable
static inline int e10k_rxmemwrap_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxmemwrap_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxmemwrap (Rx Packet Buffer Flush Detect): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc0_wrap =\t%" PRIx8 "\t(Packet Buffer 0 Wrap Around Counter)\n", e10k_rxmemwrap_tc0_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc0_empty =\t%" PRIx8 "\t(Packet Buffer 0 Empty)\n", e10k_rxmemwrap_tc0_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc1_wrap =\t%" PRIx8 "\t(Packet Buffer 1 Wrap Around Counter)\n", e10k_rxmemwrap_tc1_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc1_empty =\t%" PRIx8 "\t(Packet Buffer 1 Empty)\n", e10k_rxmemwrap_tc1_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc2_wrap =\t%" PRIx8 "\t(Packet Buffer 2 Wrap Around Counter)\n", e10k_rxmemwrap_tc2_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc2_empty =\t%" PRIx8 "\t(Packet Buffer 2 Empty)\n", e10k_rxmemwrap_tc2_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc3_wrap =\t%" PRIx8 "\t(Packet Buffer 3 Wrap Around Counter)\n", e10k_rxmemwrap_tc3_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc3_empty =\t%" PRIx8 "\t(Packet Buffer 3 Empty)\n", e10k_rxmemwrap_tc3_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc4_wrap =\t%" PRIx8 "\t(Packet Buffer 4 Wrap Around Counter)\n", e10k_rxmemwrap_tc4_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc4_empty =\t%" PRIx8 "\t(Packet Buffer 4 Empty)\n", e10k_rxmemwrap_tc4_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc5_wrap =\t%" PRIx8 "\t(Packet Buffer 5 Wrap Around Counter)\n", e10k_rxmemwrap_tc5_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc5_empty =\t%" PRIx8 "\t(Packet Buffer 5 Empty)\n", e10k_rxmemwrap_tc5_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc6_wrap =\t%" PRIx8 "\t(Packet Buffer 6 Wrap Around Counter)\n", e10k_rxmemwrap_tc6_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc6_empty =\t%" PRIx8 "\t(Packet Buffer 6 Empty)\n", e10k_rxmemwrap_tc6_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc7_wrap =\t%" PRIx8 "\t(Packet Buffer 7 Wrap Around Counter)\n", e10k_rxmemwrap_tc7_wrap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tc7_empty =\t%" PRIx8 "\t(Packet Buffer 7 Empty)\n", e10k_rxmemwrap_tc7_empty_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_rxmemwrap_tc0_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc0_wrap_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc0_wrap_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc0_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc0_empty_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc0_empty_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc1_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc1_wrap_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc1_wrap_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc1_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc1_empty_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc1_empty_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc2_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc2_wrap_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc2_wrap_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc2_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc2_empty_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc2_empty_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc3_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc3_wrap_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc3_wrap_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc3_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc3_empty_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc3_empty_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc4_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc4_wrap_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc4_wrap_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc4_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc4_empty_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc4_empty_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc5_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc5_wrap_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc5_wrap_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc5_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc5_empty_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc5_empty_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc6_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc6_wrap_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc6_wrap_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc6_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc6_empty_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc6_empty_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc7_wrap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc7_wrap_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc7_wrap_extract(_regval));
}

static inline uint8_t e10k_rxmemwrap_tc7_empty_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rxmemwrap_tc7_empty_rdf(__DN(t) *_dev)
{
    e10k_rxmemwrap_t _regval = mackerel_read_addr_32(_dev->base, 0x3190);
    return(e10k_rxmemwrap_tc7_empty_extract(_regval));
}

/*
 * Register rscdbu: RSC Data Buffer Control Register
 * Type: e10k.rscdbu (Implicit type of RSC Data Buffer Control Register register)
 *   _anon0	(size 7, offset 0, init 0):	RSVD	_
 *   rscackdis	(size 1, offset 7, init 0):	RW	Disable RSC for ACK packets
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline e10k_rscdbu_t e10k_rscdbu_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rscdbu_t e10k_rscdbu_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3028));
}

static inline e10k_rscdbu_t e10k_rscdbu_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rscdbu_t e10k_rscdbu_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3028));
}

static inline void e10k_rscdbu_rawwr(__DN(t) *_dev, e10k_rscdbu_t _regval) __attribute__ ((always_inline));
static inline void e10k_rscdbu_rawwr(__DN(t) *_dev, e10k_rscdbu_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3028, _regval);
}

static inline void e10k_rscdbu_wr(__DN(t) *_dev, e10k_rscdbu_t _regval) __attribute__ ((always_inline));
static inline void e10k_rscdbu_wr(__DN(t) *_dev, e10k_rscdbu_t _regval)
{
    _regval = (_regval & 0x80);
    // No MB1 fields present
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x3028)));
    mackerel_write_addr_32(_dev->base, 0x3028, _regval);
}

static inline int e10k_rscdbu_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rscdbu_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rscdbu_t _regval = mackerel_read_addr_32(_dev->base, 0x3028);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rscdbu (RSC Data Buffer Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rscackdis =\t%" PRIx8 "\t(Disable RSC for ACK packets)\n", e10k_rscdbu_rscackdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t e10k_rscdbu_rscackdis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rscdbu_rscackdis_rdf(__DN(t) *_dev)
{
    e10k_rscdbu_t _regval = mackerel_read_addr_32(_dev->base, 0x3028);
    return(e10k_rscdbu_rscackdis_extract(_regval));
}

static inline void e10k_rscdbu_rscackdis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rscdbu_rscackdis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rscdbu_t _regval = 0x80 & (((e10k_rscdbu_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x3028)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3028, _regval);
    // No shadow register to write to
}

/*
 * Register array rscctl_1: RSC Control (#0-#63)
 * Type: e10k.rscctl (RSC Control)
 *   rsc_en	(size 1, offset 0, init 0):	RW	RSC Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   maxdesc	(size 2, offset 2, init 0):	RW	Maximum descriptors per Large receive
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static const size_t e10k_rscctl_1_length = 64;
static inline e10k_rscctl_t e10k_rscctl_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rscctl_t e10k_rscctl_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64)));
}

static inline e10k_rscctl_t e10k_rscctl_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rscctl_t e10k_rscctl_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64)));
}

static inline void e10k_rscctl_1_rawwr(__DN(t) *_dev, int _i, e10k_rscctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rscctl_1_rawwr(__DN(t) *_dev, int _i, e10k_rscctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x102c + (_i * 64), _regval);
}

static inline void e10k_rscctl_1_wr(__DN(t) *_dev, int _i, e10k_rscctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rscctl_1_wr(__DN(t) *_dev, int _i, e10k_rscctl_t _regval)
{
    _regval = (_regval & 0xd);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff2 & mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x102c + (_i * 64), _regval);
}

static inline int e10k_rscctl_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rscctl_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rscctl_1", _i, "RSC Control (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_en =\t%" PRIx8 "\t(RSC Enable)\n", e10k_rscctl_rsc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxdesc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rsc_maxdesc_prtval(_s + _r, _avail, e10k_rscctl_maxdesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Maximum descriptors per Large receive)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline int e10k_rscctl_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rscctl_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rscctl_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_rscctl_1_rsc_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rscctl_1_rsc_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64));
    return(e10k_rscctl_rsc_en_extract(_regval));
}

static inline e10k_rsc_maxdesc_t e10k_rscctl_1_maxdesc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rsc_maxdesc_t e10k_rscctl_1_maxdesc_rdf(__DN(t) *_dev, int _i)
{
    e10k_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64));
    return(e10k_rscctl_maxdesc_extract(_regval));
}

static inline void e10k_rscctl_1_rsc_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rscctl_1_rsc_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rscctl_t _regval = 0x1 & (((e10k_rscctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x102c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_rscctl_1_maxdesc_wrf(__DN(t) *_dev, int _i, e10k_rsc_maxdesc_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rscctl_1_maxdesc_wrf(__DN(t) *_dev, int _i, e10k_rsc_maxdesc_t _fieldval)
{
    e10k_rscctl_t _regval = 0xc & (((e10k_rscctl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff3 & mackerel_read_addr_32(_dev->base, 0x102c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x102c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array rscctl_2: RSC Control (#64-#127)
 * Type: e10k.rscctl (RSC Control)
 *   rsc_en	(size 1, offset 0, init 0):	RW	RSC Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   maxdesc	(size 2, offset 2, init 0):	RW	Maximum descriptors per Large receive
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static const size_t e10k_rscctl_2_length = 64;
static inline e10k_rscctl_t e10k_rscctl_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rscctl_t e10k_rscctl_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd02c + (_i * 64)));
}

static inline e10k_rscctl_t e10k_rscctl_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rscctl_t e10k_rscctl_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd02c + (_i * 64)));
}

static inline void e10k_rscctl_2_rawwr(__DN(t) *_dev, int _i, e10k_rscctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rscctl_2_rawwr(__DN(t) *_dev, int _i, e10k_rscctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd02c + (_i * 64), _regval);
}

static inline void e10k_rscctl_2_wr(__DN(t) *_dev, int _i, e10k_rscctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_rscctl_2_wr(__DN(t) *_dev, int _i, e10k_rscctl_t _regval)
{
    _regval = (_regval & 0xd);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff2 & mackerel_read_addr_32(_dev->base, 0xd02c + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xd02c + (_i * 64), _regval);
}

static inline int e10k_rscctl_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rscctl_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd02c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rscctl_2", _i, "RSC Control (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rsc_en =\t%" PRIx8 "\t(RSC Enable)\n", e10k_rscctl_rsc_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxdesc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rsc_maxdesc_prtval(_s + _r, _avail, e10k_rscctl_maxdesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Maximum descriptors per Large receive)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline int e10k_rscctl_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rscctl_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rscctl_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_rscctl_2_rsc_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rscctl_2_rsc_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd02c + (_i * 64));
    return(e10k_rscctl_rsc_en_extract(_regval));
}

static inline e10k_rsc_maxdesc_t e10k_rscctl_2_maxdesc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rsc_maxdesc_t e10k_rscctl_2_maxdesc_rdf(__DN(t) *_dev, int _i)
{
    e10k_rscctl_t _regval = mackerel_read_addr_32(_dev->base, 0xd02c + (_i * 64));
    return(e10k_rscctl_maxdesc_extract(_regval));
}

static inline void e10k_rscctl_2_rsc_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rscctl_2_rsc_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rscctl_t _regval = 0x1 & (((e10k_rscctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xd02c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd02c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_rscctl_2_maxdesc_wrf(__DN(t) *_dev, int _i, e10k_rsc_maxdesc_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rscctl_2_maxdesc_wrf(__DN(t) *_dev, int _i, e10k_rsc_maxdesc_t _fieldval)
{
    e10k_rscctl_t _regval = 0xc & (((e10k_rscctl_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff3 & mackerel_read_addr_32(_dev->base, 0xd02c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd02c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register dtxmxszrq: DMA Tx TCP Max Allow Size Requests
 * Type: e10k.dtxmxszrq (Implicit type of DMA Tx TCP Max Allow Size Requests register)
 *   max_bytes	(size 12, offset 0, init 0):	RW	Max allowed number of bytes requests
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
static inline e10k_dtxmxszrq_t e10k_dtxmxszrq_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dtxmxszrq_t e10k_dtxmxszrq_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8100));
}

static inline e10k_dtxmxszrq_t e10k_dtxmxszrq_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dtxmxszrq_t e10k_dtxmxszrq_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8100));
}

static inline void e10k_dtxmxszrq_rawwr(__DN(t) *_dev, e10k_dtxmxszrq_t _regval) __attribute__ ((always_inline));
static inline void e10k_dtxmxszrq_rawwr(__DN(t) *_dev, e10k_dtxmxszrq_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8100, _regval);
}

static inline void e10k_dtxmxszrq_wr(__DN(t) *_dev, e10k_dtxmxszrq_t _regval) __attribute__ ((always_inline));
static inline void e10k_dtxmxszrq_wr(__DN(t) *_dev, e10k_dtxmxszrq_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x8100)));
    mackerel_write_addr_32(_dev->base, 0x8100, _regval);
}

static inline int e10k_dtxmxszrq_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dtxmxszrq_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dtxmxszrq_t _regval = mackerel_read_addr_32(_dev->base, 0x8100);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dtxmxszrq (DMA Tx TCP Max Allow Size Requests): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max_bytes =\t%" PRIx16 "\t(Max allowed number of bytes requests)\n", e10k_dtxmxszrq_max_bytes_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline uint16_t e10k_dtxmxszrq_max_bytes_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_dtxmxszrq_max_bytes_rdf(__DN(t) *_dev)
{
    e10k_dtxmxszrq_t _regval = mackerel_read_addr_32(_dev->base, 0x8100);
    return(e10k_dtxmxszrq_max_bytes_extract(_regval));
}

static inline void e10k_dtxmxszrq_max_bytes_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dtxmxszrq_max_bytes_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_dtxmxszrq_t _regval = 0xfff & (((e10k_dtxmxszrq_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x8100)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8100, _regval);
    // No shadow register to write to
}

/*
 * Register dmatxctl: DMA Tx Control
 * Type: e10k.dmatxctl (Implicit type of DMA Tx Control register)
 *   txen	(size 1, offset 0, init 0):	RW	Transmit Enable
 *   _anon1	(size 2, offset 1, init 0):	RSVD	_
 *   gdv	(size 1, offset 3, init 0):	RW	Global Double VLAN Mode
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   vlet	(size 16, offset 16, init 0):	RW	VLAN Ether-Type
 */
static inline e10k_dmatxctl_t e10k_dmatxctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dmatxctl_t e10k_dmatxctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a80));
}

static inline e10k_dmatxctl_t e10k_dmatxctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dmatxctl_t e10k_dmatxctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a80));
}

static inline void e10k_dmatxctl_rawwr(__DN(t) *_dev, e10k_dmatxctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dmatxctl_rawwr(__DN(t) *_dev, e10k_dmatxctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4a80, _regval);
}

static inline void e10k_dmatxctl_wr(__DN(t) *_dev, e10k_dmatxctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dmatxctl_wr(__DN(t) *_dev, e10k_dmatxctl_t _regval)
{
    _regval = (_regval & 0xffff0009);
    // No MB1 fields present
    _regval = (_regval | (0xfff6 & mackerel_read_addr_32(_dev->base, 0x4a80)));
    mackerel_write_addr_32(_dev->base, 0x4a80, _regval);
}

static inline int e10k_dmatxctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dmatxctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dmatxctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4a80);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dmatxctl (DMA Tx Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txen =\t%" PRIx8 "\t(Transmit Enable)\n", e10k_dmatxctl_txen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gdv =\t%" PRIx8 "\t(Global Double VLAN Mode)\n", e10k_dmatxctl_gdv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlet =\t%" PRIx16 "\t(VLAN Ether-Type)\n", e10k_dmatxctl_vlet_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_dmatxctl_txen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_dmatxctl_txen_rdf(__DN(t) *_dev)
{
    e10k_dmatxctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4a80);
    return(e10k_dmatxctl_txen_extract(_regval));
}

static inline uint8_t e10k_dmatxctl_gdv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_dmatxctl_gdv_rdf(__DN(t) *_dev)
{
    e10k_dmatxctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4a80);
    return(e10k_dmatxctl_gdv_extract(_regval));
}

static inline uint16_t e10k_dmatxctl_vlet_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_dmatxctl_vlet_rdf(__DN(t) *_dev)
{
    e10k_dmatxctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4a80);
    return(e10k_dmatxctl_vlet_extract(_regval));
}

static inline void e10k_dmatxctl_txen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dmatxctl_txen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_dmatxctl_t _regval = 0x1 & (((e10k_dmatxctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x4a80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4a80, _regval);
    // No shadow register to write to
}

static inline void e10k_dmatxctl_gdv_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dmatxctl_gdv_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_dmatxctl_t _regval = 0x8 & (((e10k_dmatxctl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x4a80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4a80, _regval);
    // No shadow register to write to
}

static inline void e10k_dmatxctl_vlet_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dmatxctl_vlet_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_dmatxctl_t _regval = 0xffff0000 & (((e10k_dmatxctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x4a80)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4a80, _regval);
    // No shadow register to write to
}

/*
 * Register dtxtcpflgl: DMA Tx TCP Flags Control Low
 * Type: e10k.dtxtcpflgl (Implicit type of DMA Tx TCP Flags Control Low register)
 *   tcp_flgfsts	(size 12, offset 0, init 0):	RW	TCP Flags First Segment
 *   _anon12	(size 4, offset 12, init 0):	RSVD	_
 *   tcp_flgmdls	(size 12, offset 16, init 0):	RW	TCP Flags Middle Segments
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static inline e10k_dtxtcpflgl_t e10k_dtxtcpflgl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dtxtcpflgl_t e10k_dtxtcpflgl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a88));
}

static inline e10k_dtxtcpflgl_t e10k_dtxtcpflgl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dtxtcpflgl_t e10k_dtxtcpflgl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a88));
}

static inline void e10k_dtxtcpflgl_rawwr(__DN(t) *_dev, e10k_dtxtcpflgl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dtxtcpflgl_rawwr(__DN(t) *_dev, e10k_dtxtcpflgl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4a88, _regval);
}

static inline void e10k_dtxtcpflgl_wr(__DN(t) *_dev, e10k_dtxtcpflgl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dtxtcpflgl_wr(__DN(t) *_dev, e10k_dtxtcpflgl_t _regval)
{
    _regval = (_regval & 0xfff0fff);
    // No MB1 fields present
    _regval = (_regval | (0xf000f000 & mackerel_read_addr_32(_dev->base, 0x4a88)));
    mackerel_write_addr_32(_dev->base, 0x4a88, _regval);
}

static inline int e10k_dtxtcpflgl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dtxtcpflgl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dtxtcpflgl_t _regval = mackerel_read_addr_32(_dev->base, 0x4a88);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dtxtcpflgl (DMA Tx TCP Flags Control Low): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_flgfsts =\t%" PRIx16 "\t(TCP Flags First Segment)\n", e10k_dtxtcpflgl_tcp_flgfsts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_flgmdls =\t%" PRIx16 "\t(TCP Flags Middle Segments)\n", e10k_dtxtcpflgl_tcp_flgmdls_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline uint16_t e10k_dtxtcpflgl_tcp_flgfsts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_dtxtcpflgl_tcp_flgfsts_rdf(__DN(t) *_dev)
{
    e10k_dtxtcpflgl_t _regval = mackerel_read_addr_32(_dev->base, 0x4a88);
    return(e10k_dtxtcpflgl_tcp_flgfsts_extract(_regval));
}

static inline uint16_t e10k_dtxtcpflgl_tcp_flgmdls_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_dtxtcpflgl_tcp_flgmdls_rdf(__DN(t) *_dev)
{
    e10k_dtxtcpflgl_t _regval = mackerel_read_addr_32(_dev->base, 0x4a88);
    return(e10k_dtxtcpflgl_tcp_flgmdls_extract(_regval));
}

static inline void e10k_dtxtcpflgl_tcp_flgfsts_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dtxtcpflgl_tcp_flgfsts_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_dtxtcpflgl_t _regval = 0xfff & (((e10k_dtxtcpflgl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x4a88)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4a88, _regval);
    // No shadow register to write to
}

static inline void e10k_dtxtcpflgl_tcp_flgmdls_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dtxtcpflgl_tcp_flgmdls_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_dtxtcpflgl_t _regval = 0xfff0000 & (((e10k_dtxtcpflgl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xf000ffff & mackerel_read_addr_32(_dev->base, 0x4a88)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4a88, _regval);
    // No shadow register to write to
}

/*
 * Register dtxtcpflgh: DMA Tx TCP Flags Control High
 * Type: e10k.dtxtcpflgh (Implicit type of DMA Tx TCP Flags Control High register)
 *   tcp_flglsts	(size 12, offset 0, init 0):	RW	TCP Flags Last Segment
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
static inline e10k_dtxtcpflgh_t e10k_dtxtcpflgh_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dtxtcpflgh_t e10k_dtxtcpflgh_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a8c));
}

static inline e10k_dtxtcpflgh_t e10k_dtxtcpflgh_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dtxtcpflgh_t e10k_dtxtcpflgh_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4a8c));
}

static inline void e10k_dtxtcpflgh_rawwr(__DN(t) *_dev, e10k_dtxtcpflgh_t _regval) __attribute__ ((always_inline));
static inline void e10k_dtxtcpflgh_rawwr(__DN(t) *_dev, e10k_dtxtcpflgh_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4a8c, _regval);
}

static inline void e10k_dtxtcpflgh_wr(__DN(t) *_dev, e10k_dtxtcpflgh_t _regval) __attribute__ ((always_inline));
static inline void e10k_dtxtcpflgh_wr(__DN(t) *_dev, e10k_dtxtcpflgh_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x4a8c)));
    mackerel_write_addr_32(_dev->base, 0x4a8c, _regval);
}

static inline int e10k_dtxtcpflgh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dtxtcpflgh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dtxtcpflgh_t _regval = mackerel_read_addr_32(_dev->base, 0x4a8c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dtxtcpflgh (DMA Tx TCP Flags Control High): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcp_flglsts =\t%" PRIx16 "\t(TCP Flags Last Segment)\n", e10k_dtxtcpflgh_tcp_flglsts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline uint16_t e10k_dtxtcpflgh_tcp_flglsts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_dtxtcpflgh_tcp_flglsts_rdf(__DN(t) *_dev)
{
    e10k_dtxtcpflgh_t _regval = mackerel_read_addr_32(_dev->base, 0x4a8c);
    return(e10k_dtxtcpflgh_tcp_flglsts_extract(_regval));
}

static inline void e10k_dtxtcpflgh_tcp_flglsts_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dtxtcpflgh_tcp_flglsts_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_dtxtcpflgh_t _regval = 0xfff & (((e10k_dtxtcpflgh_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x4a8c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4a8c, _regval);
    // No shadow register to write to
}

/*
 * Register array tdbal: Transmit Descriptor Base Address Low
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_tdbal_length = 128;
static inline uint32_t e10k_tdbal_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdbal_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6000 + (_i * 64)));
}

static inline uint32_t e10k_tdbal_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdbal_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6000 + (_i * 64)));
}

static inline void e10k_tdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdbal_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6000 + (_i * 64), _regval);
}

static inline void e10k_tdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdbal_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6000 + (_i * 64), _regval);
}

static inline int e10k_tdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_tdbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6000 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdbal", _i, "Transmit Descriptor Base Address Low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_tdbal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tdbal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_tdbal_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array tdbah: Transmit Descriptor Base Address Low
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_tdbah_length = 128;
static inline uint32_t e10k_tdbah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdbah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6004 + (_i * 64)));
}

static inline uint32_t e10k_tdbah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdbah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6004 + (_i * 64)));
}

static inline void e10k_tdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdbah_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6004 + (_i * 64), _regval);
}

static inline void e10k_tdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdbah_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6004 + (_i * 64), _regval);
}

static inline int e10k_tdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_tdbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6004 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdbah", _i, "Transmit Descriptor Base Address Low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_tdbah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tdbah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_tdbah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array tdlen: Transmit Descriptor Length
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_tdlen_length = 128;
static inline uint32_t e10k_tdlen_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdlen_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6008 + (_i * 64)));
}

static inline uint32_t e10k_tdlen_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdlen_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6008 + (_i * 64)));
}

static inline void e10k_tdlen_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdlen_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6008 + (_i * 64), _regval);
}

static inline void e10k_tdlen_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdlen_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6008 + (_i * 64), _regval);
}

static inline int e10k_tdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_tdlen_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6008 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdlen", _i, "Transmit Descriptor Length");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_tdlen_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tdlen_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_tdlen_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array tdh: Transmit Descriptor Head
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_tdh_length = 128;
static inline uint32_t e10k_tdh_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdh_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6010 + (_i * 64)));
}

static inline uint32_t e10k_tdh_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdh_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6010 + (_i * 64)));
}

static inline void e10k_tdh_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdh_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6010 + (_i * 64), _regval);
}

static inline void e10k_tdh_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdh_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6010 + (_i * 64), _regval);
}

static inline int e10k_tdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_tdh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6010 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdh", _i, "Transmit Descriptor Head");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_tdh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tdh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_tdh_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array tdt: Transmit Descriptor Tail
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_tdt_length = 128;
static inline uint32_t e10k_tdt_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdt_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6018 + (_i * 64)));
}

static inline uint32_t e10k_tdt_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdt_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6018 + (_i * 64)));
}

static inline void e10k_tdt_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdt_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6018 + (_i * 64), _regval);
}

static inline void e10k_tdt_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdt_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x6018 + (_i * 64), _regval);
}

static inline int e10k_tdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_tdt_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x6018 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdt", _i, "Transmit Descriptor Tail");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_tdt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tdt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_tdt_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array txdctl: Transmit Descriptor Control
 * Type: e10k.txdctl (Implicit type of Transmit Descriptor Control register array)
 *   pthresh	(size 7, offset 0, init 0):	RW	Pre-Fetch Threshold
 *   _anon7	(size 1, offset 7, init 0):	RSVD	_
 *   hthresh	(size 7, offset 8, init 0):	RW	Host Threshold
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   wthresh	(size 7, offset 16, init 0):	RW	Write-Back Threshold
 *   _anon23	(size 2, offset 23, init 0):	RSVD	_
 *   enable	(size 1, offset 25, init 0):	RW	Transmit Queue Enable
 *   swflsh	(size 1, offset 26, init 0):	RW	Transmit Software Flush
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static const size_t e10k_txdctl_length = 128;
static inline e10k_txdctl_t e10k_txdctl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_txdctl_t e10k_txdctl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64)));
}

static inline e10k_txdctl_t e10k_txdctl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_txdctl_t e10k_txdctl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64)));
}

static inline void e10k_txdctl_rawwr(__DN(t) *_dev, int _i, e10k_txdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_txdctl_rawwr(__DN(t) *_dev, int _i, e10k_txdctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6028 + (_i * 64), _regval);
}

static inline void e10k_txdctl_wr(__DN(t) *_dev, int _i, e10k_txdctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_txdctl_wr(__DN(t) *_dev, int _i, e10k_txdctl_t _regval)
{
    _regval = (_regval & 0x67f7f7f);
    // No MB1 fields present
    _regval = (_regval | (0xf9808080 & mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x6028 + (_i * 64), _regval);
}

static inline int e10k_txdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_txdctl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "txdctl", _i, "Transmit Descriptor Control");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pthresh =\t%" PRIx8 "\t(Pre-Fetch Threshold)\n", e10k_txdctl_pthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hthresh =\t%" PRIx8 "\t(Host Threshold)\n", e10k_txdctl_hthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " wthresh =\t%" PRIx8 "\t(Write-Back Threshold)\n", e10k_txdctl_wthresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " enable =\t%" PRIx8 "\t(Transmit Queue Enable)\n", e10k_txdctl_enable_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " swflsh =\t%" PRIx8 "\t(Transmit Software Flush)\n", e10k_txdctl_swflsh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline int e10k_txdctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_txdctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_txdctl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_txdctl_pthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_pthresh_rdf(__DN(t) *_dev, int _i)
{
    e10k_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64));
    return(e10k_txdctl_pthresh_extract(_regval));
}

static inline uint8_t e10k_txdctl_hthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_hthresh_rdf(__DN(t) *_dev, int _i)
{
    e10k_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64));
    return(e10k_txdctl_hthresh_extract(_regval));
}

static inline uint8_t e10k_txdctl_wthresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_wthresh_rdf(__DN(t) *_dev, int _i)
{
    e10k_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64));
    return(e10k_txdctl_wthresh_extract(_regval));
}

static inline uint8_t e10k_txdctl_enable_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_enable_rdf(__DN(t) *_dev, int _i)
{
    e10k_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64));
    return(e10k_txdctl_enable_extract(_regval));
}

static inline uint8_t e10k_txdctl_swflsh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_txdctl_swflsh_rdf(__DN(t) *_dev, int _i)
{
    e10k_txdctl_t _regval = mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64));
    return(e10k_txdctl_swflsh_extract(_regval));
}

static inline void e10k_txdctl_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_txdctl_pthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_txdctl_t _regval = 0x7f & (((e10k_txdctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff80 & mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_txdctl_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_txdctl_hthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_txdctl_t _regval = 0x7f00 & (((e10k_txdctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff80ff & mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_txdctl_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_txdctl_wthresh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_txdctl_t _regval = 0x7f0000 & (((e10k_txdctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff80ffff & mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_txdctl_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_txdctl_enable_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_txdctl_t _regval = 0x2000000 & (((e10k_txdctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6028 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_txdctl_swflsh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_txdctl_swflsh_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_txdctl_t _regval = 0x4000000 & (((e10k_txdctl_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x6028 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6028 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array tdwbal: Tx Descriptor Completion Write Back Address Low
 * Type: e10k.tdwbal (Implicit type of Tx Descriptor Completion Write Back Address Low register array)
 *   headwb_en	(size 1, offset 0, init 0):	RW	Head Write-Back Enable
 *   _anon1	(size 1, offset 1, init 0):	RSVD	_
 *   headwb_low	(size 30, offset 2, init 0):	RW	Lowest 32 bits of the head write-back memory location
 */
static const size_t e10k_tdwbal_length = 128;
static inline e10k_tdwbal_t e10k_tdwbal_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_tdwbal_t e10k_tdwbal_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6038 + (_i * 64)));
}

static inline e10k_tdwbal_t e10k_tdwbal_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_tdwbal_t e10k_tdwbal_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x6038 + (_i * 64)));
}

static inline void e10k_tdwbal_rawwr(__DN(t) *_dev, int _i, e10k_tdwbal_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdwbal_rawwr(__DN(t) *_dev, int _i, e10k_tdwbal_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x6038 + (_i * 64), _regval);
}

static inline void e10k_tdwbal_wr(__DN(t) *_dev, int _i, e10k_tdwbal_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdwbal_wr(__DN(t) *_dev, int _i, e10k_tdwbal_t _regval)
{
    _regval = (_regval & 0xfffffffd);
    // No MB1 fields present
    _regval = (_regval | (0x2 & mackerel_read_addr_32(_dev->base, 0x6038 + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x6038 + (_i * 64), _regval);
}

static inline int e10k_tdwbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_tdwbal_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_tdwbal_t _regval = mackerel_read_addr_32(_dev->base, 0x6038 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdwbal", _i, "Tx Descriptor Completion Write Back Address Low");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_en =\t%" PRIx8 "\t(Head Write-Back Enable)\n", e10k_tdwbal_headwb_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_low =\t%" PRIx32 "\t(Lowest 32 bits of the head write-back memory location)\n", e10k_tdwbal_headwb_low_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_tdwbal_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tdwbal_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_tdwbal_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_tdwbal_headwb_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_tdwbal_headwb_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_tdwbal_t _regval = mackerel_read_addr_32(_dev->base, 0x6038 + (_i * 64));
    return(e10k_tdwbal_headwb_en_extract(_regval));
}

static inline uint32_t e10k_tdwbal_headwb_low_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdwbal_headwb_low_rdf(__DN(t) *_dev, int _i)
{
    e10k_tdwbal_t _regval = mackerel_read_addr_32(_dev->base, 0x6038 + (_i * 64));
    return(e10k_tdwbal_headwb_low_extract(_regval));
}

static inline void e10k_tdwbal_headwb_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_tdwbal_headwb_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_tdwbal_t _regval = 0x1 & (((e10k_tdwbal_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x6038 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6038 + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_tdwbal_headwb_low_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_tdwbal_headwb_low_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_tdwbal_t _regval = 0xfffffffc & (((e10k_tdwbal_t )(_fieldval)) << 2);
    _regval = (_regval | (0x3 & mackerel_read_addr_32(_dev->base, 0x6038 + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x6038 + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array tdwbah: Tx Descriptor Completion Write Back Address High
 * Type: e10k.tdwbah (Implicit type of Tx Descriptor Completion Write Back Address High register array)
 *   headwb_high	(size 32, offset 0, init 0):	RW	Highest 32 bits of the head write-back memory location
 */
static const size_t e10k_tdwbah_length = 128;
static inline e10k_tdwbah_t e10k_tdwbah_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_tdwbah_t e10k_tdwbah_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x603c + (_i * 64)));
}

static inline e10k_tdwbah_t e10k_tdwbah_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_tdwbah_t e10k_tdwbah_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x603c + (_i * 64)));
}

static inline void e10k_tdwbah_rawwr(__DN(t) *_dev, int _i, e10k_tdwbah_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdwbah_rawwr(__DN(t) *_dev, int _i, e10k_tdwbah_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x603c + (_i * 64), _regval);
}

static inline void e10k_tdwbah_wr(__DN(t) *_dev, int _i, e10k_tdwbah_t _regval) __attribute__ ((always_inline));
static inline void e10k_tdwbah_wr(__DN(t) *_dev, int _i, e10k_tdwbah_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x603c + (_i * 64), _regval);
}

static inline int e10k_tdwbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_tdwbah_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_tdwbah_t _regval = mackerel_read_addr_32(_dev->base, 0x603c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "tdwbah", _i, "Tx Descriptor Completion Write Back Address High");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " headwb_high =\t%" PRIx32 "\t(Highest 32 bits of the head write-back memory location)\n", e10k_tdwbah_headwb_high_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_tdwbah_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tdwbah_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_tdwbah_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_tdwbah_headwb_high_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_tdwbah_headwb_high_rdf(__DN(t) *_dev, int _i)
{
    e10k_tdwbah_t _regval = mackerel_read_addr_32(_dev->base, 0x603c + (_i * 64));
    return(e10k_tdwbah_headwb_high_extract(_regval));
}

static inline void e10k_tdwbah_headwb_high_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_tdwbah_headwb_high_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_tdwbah_t _regval = 0xffffffff & (((e10k_tdwbah_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x603c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array txpbsize: Transmit Packet Buffer Size
 * Type: e10k.txpbsize (Implicit type of Transmit Packet Buffer Size register array)
 *   _anon0	(size 10, offset 0, init 0):	RSVD	_
 *   size	(size 10, offset 10, init 0):	RW	Transmit packet buffer size of TCn
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static const size_t e10k_txpbsize_length = 8;
static inline e10k_txpbsize_t e10k_txpbsize_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_txpbsize_t e10k_txpbsize_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8))));
}

static inline e10k_txpbsize_t e10k_txpbsize_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_txpbsize_t e10k_txpbsize_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8))));
}

static inline void e10k_txpbsize_rawwr(__DN(t) *_dev, int _i, e10k_txpbsize_t _regval) __attribute__ ((always_inline));
static inline void e10k_txpbsize_rawwr(__DN(t) *_dev, int _i, e10k_txpbsize_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8)), _regval);
}

static inline void e10k_txpbsize_wr(__DN(t) *_dev, int _i, e10k_txpbsize_t _regval) __attribute__ ((always_inline));
static inline void e10k_txpbsize_wr(__DN(t) *_dev, int _i, e10k_txpbsize_t _regval)
{
    _regval = (_regval & 0xffc00);
    // No MB1 fields present
    _regval = (_regval | (0xfff003ff & mackerel_read_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8)), _regval);
}

static inline int e10k_txpbsize_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_txpbsize_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_txpbsize_t _regval = mackerel_read_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "txpbsize", _i, "Transmit Packet Buffer Size");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " size =\t%" PRIx16 "\t(Transmit packet buffer size of TCn)\n", e10k_txpbsize_size_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline int e10k_txpbsize_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_txpbsize_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_txpbsize_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_txpbsize_size_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_txpbsize_size_rdf(__DN(t) *_dev, int _i)
{
    e10k_txpbsize_t _regval = mackerel_read_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8)));
    return(e10k_txpbsize_size_extract(_regval));
}

static inline void e10k_txpbsize_size_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_txpbsize_size_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_txpbsize_t _regval = 0xffc00 & (((e10k_txpbsize_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfff003ff & mackerel_read_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcc00 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register mngtxmap: Manageability Transmit TC Mapping
 * Type: e10k.mngtxmap (Implicit type of Manageability Transmit TC Mapping register)
 *   map	(size 3, offset 0, init 0):	RW	Map value indicates the TC that the transmit manageability traffic is routed to
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_mngtxmap_t e10k_mngtxmap_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mngtxmap_t e10k_mngtxmap_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcd10));
}

static inline e10k_mngtxmap_t e10k_mngtxmap_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mngtxmap_t e10k_mngtxmap_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcd10));
}

static inline void e10k_mngtxmap_rawwr(__DN(t) *_dev, e10k_mngtxmap_t _regval) __attribute__ ((always_inline));
static inline void e10k_mngtxmap_rawwr(__DN(t) *_dev, e10k_mngtxmap_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcd10, _regval);
}

static inline void e10k_mngtxmap_wr(__DN(t) *_dev, e10k_mngtxmap_t _regval) __attribute__ ((always_inline));
static inline void e10k_mngtxmap_wr(__DN(t) *_dev, e10k_mngtxmap_t _regval)
{
    _regval = (_regval & 0x7);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0xcd10)));
    mackerel_write_addr_32(_dev->base, 0xcd10, _regval);
}

static inline int e10k_mngtxmap_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mngtxmap_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mngtxmap_t _regval = mackerel_read_addr_32(_dev->base, 0xcd10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mngtxmap (Manageability Transmit TC Mapping): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " map =\t%" PRIx8 "\t(Map value indicates the TC that the transmit manageability traffic is routed to)\n", e10k_mngtxmap_map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_mngtxmap_map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mngtxmap_map_rdf(__DN(t) *_dev)
{
    e10k_mngtxmap_t _regval = mackerel_read_addr_32(_dev->base, 0xcd10);
    return(e10k_mngtxmap_map_extract(_regval));
}

static inline void e10k_mngtxmap_map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mngtxmap_map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mngtxmap_t _regval = 0x7 & (((e10k_mngtxmap_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0xcd10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd10, _regval);
    // No shadow register to write to
}

/*
 * Register mtqc: Multiple Transmit Queues Command Register
 * Type: e10k.mtqc (Implicit type of Multiple Transmit Queues Command Register register)
 *   rt_en	(size 1, offset 0, init 0):	RW	DCB Enabled Mode
 *   vt_en	(size 1, offset 1, init 0):	RW	Virtualization Enabled Mode
 *   num_tc	(size 2, offset 2, init 0):	RW	Number of TCs or Number of Tx Queues per Pools
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static inline e10k_mtqc_t e10k_mtqc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mtqc_t e10k_mtqc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8120));
}

static inline e10k_mtqc_t e10k_mtqc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mtqc_t e10k_mtqc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8120));
}

static inline void e10k_mtqc_rawwr(__DN(t) *_dev, e10k_mtqc_t _regval) __attribute__ ((always_inline));
static inline void e10k_mtqc_rawwr(__DN(t) *_dev, e10k_mtqc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8120, _regval);
}

static inline void e10k_mtqc_wr(__DN(t) *_dev, e10k_mtqc_t _regval) __attribute__ ((always_inline));
static inline void e10k_mtqc_wr(__DN(t) *_dev, e10k_mtqc_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x8120)));
    mackerel_write_addr_32(_dev->base, 0x8120, _regval);
}

static inline int e10k_mtqc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mtqc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mtqc_t _regval = mackerel_read_addr_32(_dev->base, 0x8120);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mtqc (Multiple Transmit Queues Command Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rt_en =\t%" PRIx8 "\t(DCB Enabled Mode)\n", e10k_mtqc_rt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vt_en =\t%" PRIx8 "\t(Virtualization Enabled Mode)\n", e10k_mtqc_vt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " num_tc =\t%" PRIx8 "\t(Number of TCs or Number of Tx Queues per Pools)\n", e10k_mtqc_num_tc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t e10k_mtqc_rt_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mtqc_rt_en_rdf(__DN(t) *_dev)
{
    e10k_mtqc_t _regval = mackerel_read_addr_32(_dev->base, 0x8120);
    return(e10k_mtqc_rt_en_extract(_regval));
}

static inline uint8_t e10k_mtqc_vt_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mtqc_vt_en_rdf(__DN(t) *_dev)
{
    e10k_mtqc_t _regval = mackerel_read_addr_32(_dev->base, 0x8120);
    return(e10k_mtqc_vt_en_extract(_regval));
}

static inline uint8_t e10k_mtqc_num_tc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mtqc_num_tc_rdf(__DN(t) *_dev)
{
    e10k_mtqc_t _regval = mackerel_read_addr_32(_dev->base, 0x8120);
    return(e10k_mtqc_num_tc_extract(_regval));
}

static inline void e10k_mtqc_rt_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mtqc_rt_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mtqc_t _regval = 0x1 & (((e10k_mtqc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x8120)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8120, _regval);
    // No shadow register to write to
}

static inline void e10k_mtqc_vt_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mtqc_vt_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mtqc_t _regval = 0x2 & (((e10k_mtqc_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x8120)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8120, _regval);
    // No shadow register to write to
}

static inline void e10k_mtqc_num_tc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mtqc_num_tc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mtqc_t _regval = 0xc & (((e10k_mtqc_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffff3 & mackerel_read_addr_32(_dev->base, 0x8120)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8120, _regval);
    // No shadow register to write to
}

/*
 * Register array txpbthresh: Tx Packet Buffer Threshold
 * Type: e10k.txpbthresh (Implicit type of Tx Packet Buffer Threshold register array)
 *   thresh	(size 10, offset 0, init 0):	RW	Threshold used for checking room place in Tx packet buffer of TCn
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
static const size_t e10k_txpbthresh_length = 8;
static inline e10k_txpbthresh_t e10k_txpbthresh_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_txpbthresh_t e10k_txpbthresh_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x4950 + (_i * (32 / 8))));
}

static inline e10k_txpbthresh_t e10k_txpbthresh_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_txpbthresh_t e10k_txpbthresh_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x4950 + (_i * (32 / 8))));
}

static inline void e10k_txpbthresh_rawwr(__DN(t) *_dev, int _i, e10k_txpbthresh_t _regval) __attribute__ ((always_inline));
static inline void e10k_txpbthresh_rawwr(__DN(t) *_dev, int _i, e10k_txpbthresh_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4950 + (_i * (32 / 8)), _regval);
}

static inline void e10k_txpbthresh_wr(__DN(t) *_dev, int _i, e10k_txpbthresh_t _regval) __attribute__ ((always_inline));
static inline void e10k_txpbthresh_wr(__DN(t) *_dev, int _i, e10k_txpbthresh_t _regval)
{
    _regval = (_regval & 0x3ff);
    // No MB1 fields present
    _regval = (_regval | (0xfffffc00 & mackerel_read_addr_32(_dev->base, 0x4950 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x4950 + (_i * (32 / 8)), _regval);
}

static inline int e10k_txpbthresh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_txpbthresh_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_txpbthresh_t _regval = mackerel_read_addr_32(_dev->base, 0x4950 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "txpbthresh", _i, "Tx Packet Buffer Threshold");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " thresh =\t%" PRIx16 "\t(Threshold used for checking room place in Tx packet buffer of TCn)\n", e10k_txpbthresh_thresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline int e10k_txpbthresh_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_txpbthresh_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_txpbthresh_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_txpbthresh_thresh_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_txpbthresh_thresh_rdf(__DN(t) *_dev, int _i)
{
    e10k_txpbthresh_t _regval = mackerel_read_addr_32(_dev->base, 0x4950 + (_i * (32 / 8)));
    return(e10k_txpbthresh_thresh_extract(_regval));
}

static inline void e10k_txpbthresh_thresh_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_txpbthresh_thresh_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_txpbthresh_t _regval = 0x3ff & (((e10k_txpbthresh_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffc00 & mackerel_read_addr_32(_dev->base, 0x4950 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4950 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register rtrpcs: DCB Receive Packet Plane Control and Status
 * Type: e10k.rtrpcs (Implicit type of DCB Receive Packet Plane Control and Status register)
 *   _anon0	(size 1, offset 0, init 0):	RSVD	_
 *   rrm	(size 1, offset 1, init 0):	RW	Receive Recycle Mode
 *   rac	(size 1, offset 2, init 0):	RW	Receive Arbitration Control
 *   _anon3	(size 13, offset 3, init 0):	RSVD	_
 *   lrpb	(size 3, offset 16, init 0):	RW	Last Received Packet Buffer Status Indication
 *   _anon19	(size 13, offset 19, init 0):	RSVD	_
 */
static inline e10k_rtrpcs_t e10k_rtrpcs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rtrpcs_t e10k_rtrpcs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2430));
}

static inline e10k_rtrpcs_t e10k_rtrpcs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rtrpcs_t e10k_rtrpcs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2430));
}

static inline void e10k_rtrpcs_rawwr(__DN(t) *_dev, e10k_rtrpcs_t _regval) __attribute__ ((always_inline));
static inline void e10k_rtrpcs_rawwr(__DN(t) *_dev, e10k_rtrpcs_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2430, _regval);
}

static inline void e10k_rtrpcs_wr(__DN(t) *_dev, e10k_rtrpcs_t _regval) __attribute__ ((always_inline));
static inline void e10k_rtrpcs_wr(__DN(t) *_dev, e10k_rtrpcs_t _regval)
{
    _regval = (_regval & 0x70006);
    // No MB1 fields present
    _regval = (_regval | (0xfff8fff9 & mackerel_read_addr_32(_dev->base, 0x2430)));
    mackerel_write_addr_32(_dev->base, 0x2430, _regval);
}

static inline int e10k_rtrpcs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rtrpcs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rtrpcs_t _regval = mackerel_read_addr_32(_dev->base, 0x2430);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rtrpcs (DCB Receive Packet Plane Control and Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rrm =\t%" PRIx8 "\t(Receive Recycle Mode)\n", e10k_rtrpcs_rrm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rac =\t%" PRIx8 "\t(Receive Arbitration Control)\n", e10k_rtrpcs_rac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lrpb =\t%" PRIx8 "\t(Last Received Packet Buffer Status Indication)\n", e10k_rtrpcs_lrpb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    return(_r);
}

static inline uint8_t e10k_rtrpcs_rrm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpcs_rrm_rdf(__DN(t) *_dev)
{
    e10k_rtrpcs_t _regval = mackerel_read_addr_32(_dev->base, 0x2430);
    return(e10k_rtrpcs_rrm_extract(_regval));
}

static inline uint8_t e10k_rtrpcs_rac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpcs_rac_rdf(__DN(t) *_dev)
{
    e10k_rtrpcs_t _regval = mackerel_read_addr_32(_dev->base, 0x2430);
    return(e10k_rtrpcs_rac_extract(_regval));
}

static inline uint8_t e10k_rtrpcs_lrpb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpcs_lrpb_rdf(__DN(t) *_dev)
{
    e10k_rtrpcs_t _regval = mackerel_read_addr_32(_dev->base, 0x2430);
    return(e10k_rtrpcs_lrpb_extract(_regval));
}

static inline void e10k_rtrpcs_rrm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrpcs_rrm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrpcs_t _regval = 0x2 & (((e10k_rtrpcs_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x2430)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2430, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrpcs_rac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrpcs_rac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrpcs_t _regval = 0x4 & (((e10k_rtrpcs_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x2430)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2430, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrpcs_lrpb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrpcs_lrpb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrpcs_t _regval = 0x70000 & (((e10k_rtrpcs_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff8ffff & mackerel_read_addr_32(_dev->base, 0x2430)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2430, _regval);
    // No shadow register to write to
}

/*
 * Register rttdcs: DCP Transmit Descriptor Plane Control and Status
 * Type: e10k.rttdcs (Implicit type of DCP Transmit Descriptor Plane Control and Status register)
 *   tdpac	(size 1, offset 0, init 0):	RW	TC Transmit Descriptor Plane Arbitration Control
 *   vmpac	(size 1, offset 1, init 0):	RW	VM Transmit Descriptor Plane Arbitration Control
 *   _anon2	(size 2, offset 2, init 0):	RSVD	_
 *   tdrm	(size 1, offset 4, init 0):	RW	TC Transmit descriptor plane recycle mode
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   arbdis	(size 1, offset 6, init 0):	RW	DCB Arbiters Disable
 *   _anon7	(size 10, offset 7, init 0):	RSVD	_
 *   lttdesc	(size 3, offset 17, init 0):	RO	Last Transmitted TC
 *   _anon20	(size 2, offset 20, init 0):	RSVD	_
 *   bdpm	(size 1, offset 22, init 0):	RW	Bypass data pipe Monitor
 *   bpbfsm	(size 1, offset 23, init 0):	RW	Bypass Packet Buffer Free Space Monitor
 *   _anon24	(size 7, offset 24, init 0):	RSVD	_
 *   speed_chg	(size 1, offset 31, init 0):	RW	Link speed has changed
 */
static inline e10k_rttdcs_t e10k_rttdcs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4900));
}

static inline e10k_rttdcs_t e10k_rttdcs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttdcs_t e10k_rttdcs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4900));
}

static inline void e10k_rttdcs_rawwr(__DN(t) *_dev, e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_rawwr(__DN(t) *_dev, e10k_rttdcs_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
}

static inline void e10k_rttdcs_wr(__DN(t) *_dev, e10k_rttdcs_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_wr(__DN(t) *_dev, e10k_rttdcs_t _regval)
{
    _regval = (_regval & 0x80ce0053);
    // No MB1 fields present
    _regval = (_regval | (0x7f31ffac & mackerel_read_addr_32(_dev->base, 0x4900)));
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
}

static inline int e10k_rttdcs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rttdcs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rttdcs (DCP Transmit Descriptor Plane Control and Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tdpac =\t%" PRIx8 "\t(TC Transmit Descriptor Plane Arbitration Control)\n", e10k_rttdcs_tdpac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vmpac =\t%" PRIx8 "\t(VM Transmit Descriptor Plane Arbitration Control)\n", e10k_rttdcs_vmpac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tdrm =\t%" PRIx8 "\t(TC Transmit descriptor plane recycle mode)\n", e10k_rttdcs_tdrm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arbdis =\t%" PRIx8 "\t(DCB Arbiters Disable)\n", e10k_rttdcs_arbdis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lttdesc =\t%" PRIx8 "\t(Last Transmitted TC)\n", e10k_rttdcs_lttdesc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bdpm =\t%" PRIx8 "\t(Bypass data pipe Monitor)\n", e10k_rttdcs_bdpm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bpbfsm =\t%" PRIx8 "\t(Bypass Packet Buffer Free Space Monitor)\n", e10k_rttdcs_bpbfsm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " speed_chg =\t%" PRIx8 "\t(Link speed has changed)\n", e10k_rttdcs_speed_chg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_rttdcs_tdpac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_tdpac_rdf(__DN(t) *_dev)
{
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    return(e10k_rttdcs_tdpac_extract(_regval));
}

static inline uint8_t e10k_rttdcs_vmpac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_vmpac_rdf(__DN(t) *_dev)
{
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    return(e10k_rttdcs_vmpac_extract(_regval));
}

static inline uint8_t e10k_rttdcs_tdrm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_tdrm_rdf(__DN(t) *_dev)
{
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    return(e10k_rttdcs_tdrm_extract(_regval));
}

static inline uint8_t e10k_rttdcs_arbdis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_arbdis_rdf(__DN(t) *_dev)
{
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    return(e10k_rttdcs_arbdis_extract(_regval));
}

static inline uint8_t e10k_rttdcs_lttdesc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_lttdesc_rdf(__DN(t) *_dev)
{
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    return(e10k_rttdcs_lttdesc_extract(_regval));
}

static inline uint8_t e10k_rttdcs_bdpm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_bdpm_rdf(__DN(t) *_dev)
{
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    return(e10k_rttdcs_bdpm_extract(_regval));
}

static inline uint8_t e10k_rttdcs_bpbfsm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_bpbfsm_rdf(__DN(t) *_dev)
{
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    return(e10k_rttdcs_bpbfsm_extract(_regval));
}

static inline uint8_t e10k_rttdcs_speed_chg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdcs_speed_chg_rdf(__DN(t) *_dev)
{
    e10k_rttdcs_t _regval = mackerel_read_addr_32(_dev->base, 0x4900);
    return(e10k_rttdcs_speed_chg_extract(_regval));
}

static inline void e10k_rttdcs_tdpac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_tdpac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttdcs_t _regval = 0x1 & (((e10k_rttdcs_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfff1fffe & mackerel_read_addr_32(_dev->base, 0x4900)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
    // No shadow register to write to
}

static inline void e10k_rttdcs_vmpac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_vmpac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttdcs_t _regval = 0x2 & (((e10k_rttdcs_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfff1fffd & mackerel_read_addr_32(_dev->base, 0x4900)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
    // No shadow register to write to
}

static inline void e10k_rttdcs_tdrm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_tdrm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttdcs_t _regval = 0x10 & (((e10k_rttdcs_t )(_fieldval)) << 4);
    _regval = (_regval | (0xfff1ffef & mackerel_read_addr_32(_dev->base, 0x4900)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
    // No shadow register to write to
}

static inline void e10k_rttdcs_arbdis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_arbdis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttdcs_t _regval = 0x40 & (((e10k_rttdcs_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfff1ffbf & mackerel_read_addr_32(_dev->base, 0x4900)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
    // No shadow register to write to
}

static inline void e10k_rttdcs_bdpm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_bdpm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttdcs_t _regval = 0x400000 & (((e10k_rttdcs_t )(_fieldval)) << 22);
    _regval = (_regval | (0xffb1ffff & mackerel_read_addr_32(_dev->base, 0x4900)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
    // No shadow register to write to
}

static inline void e10k_rttdcs_bpbfsm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_bpbfsm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttdcs_t _regval = 0x800000 & (((e10k_rttdcs_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff71ffff & mackerel_read_addr_32(_dev->base, 0x4900)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
    // No shadow register to write to
}

static inline void e10k_rttdcs_speed_chg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdcs_speed_chg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttdcs_t _regval = 0x80000000 & (((e10k_rttdcs_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7ff1ffff & mackerel_read_addr_32(_dev->base, 0x4900)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4900, _regval);
    // No shadow register to write to
}

/*
 * Register rttpcs: DCB Transmit Packet Plane Control and Status
 * Type: e10k.rttpcs (Implicit type of DCB Transmit Packet Plane Control and Status register)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   tppac	(size 1, offset 5, init 0):	RW	Transmit Packet Plane Arbitration Control
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   tprm	(size 1, offset 8, init 0):	RW	Transmit packet plane recycle mode
 *   _anon9	(size 13, offset 9, init 0):	RSVD	_
 *   arbd	(size 10, offset 22, init 0):	RW	ARB_delay
 */
static inline e10k_rttpcs_t e10k_rttpcs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttpcs_t e10k_rttpcs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcd00));
}

static inline e10k_rttpcs_t e10k_rttpcs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttpcs_t e10k_rttpcs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xcd00));
}

static inline void e10k_rttpcs_rawwr(__DN(t) *_dev, e10k_rttpcs_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttpcs_rawwr(__DN(t) *_dev, e10k_rttpcs_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcd00, _regval);
}

static inline void e10k_rttpcs_wr(__DN(t) *_dev, e10k_rttpcs_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttpcs_wr(__DN(t) *_dev, e10k_rttpcs_t _regval)
{
    _regval = (_regval & 0xffc00120);
    // No MB1 fields present
    _regval = (_regval | (0x3ffedf & mackerel_read_addr_32(_dev->base, 0xcd00)));
    mackerel_write_addr_32(_dev->base, 0xcd00, _regval);
}

static inline int e10k_rttpcs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rttpcs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rttpcs_t _regval = mackerel_read_addr_32(_dev->base, 0xcd00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rttpcs (DCB Transmit Packet Plane Control and Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tppac =\t%" PRIx8 "\t(Transmit Packet Plane Arbitration Control)\n", e10k_rttpcs_tppac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tprm =\t%" PRIx8 "\t(Transmit packet plane recycle mode)\n", e10k_rttpcs_tprm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " arbd =\t%" PRIx16 "\t(ARB_delay)\n", e10k_rttpcs_arbd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_rttpcs_tppac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpcs_tppac_rdf(__DN(t) *_dev)
{
    e10k_rttpcs_t _regval = mackerel_read_addr_32(_dev->base, 0xcd00);
    return(e10k_rttpcs_tppac_extract(_regval));
}

static inline uint8_t e10k_rttpcs_tprm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpcs_tprm_rdf(__DN(t) *_dev)
{
    e10k_rttpcs_t _regval = mackerel_read_addr_32(_dev->base, 0xcd00);
    return(e10k_rttpcs_tprm_extract(_regval));
}

static inline uint16_t e10k_rttpcs_arbd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_rttpcs_arbd_rdf(__DN(t) *_dev)
{
    e10k_rttpcs_t _regval = mackerel_read_addr_32(_dev->base, 0xcd00);
    return(e10k_rttpcs_arbd_extract(_regval));
}

static inline void e10k_rttpcs_tppac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttpcs_tppac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttpcs_t _regval = 0x20 & (((e10k_rttpcs_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0xcd00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd00, _regval);
    // No shadow register to write to
}

static inline void e10k_rttpcs_tprm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttpcs_tprm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttpcs_t _regval = 0x100 & (((e10k_rttpcs_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0xcd00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd00, _regval);
    // No shadow register to write to
}

static inline void e10k_rttpcs_arbd_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttpcs_arbd_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_rttpcs_t _regval = 0xffc00000 & (((e10k_rttpcs_t )(_fieldval)) << 22);
    _regval = (_regval | (0x3fffff & mackerel_read_addr_32(_dev->base, 0xcd00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd00, _regval);
    // No shadow register to write to
}

/*
 * Register rtrup2tc: DCB Receive User Priority to Traffic Class
 * Type: e10k.rtrup2tc (Implicit type of DCB Receive User Priority to Traffic Class register)
 *   up0map	(size 3, offset 0, init 0):	RW	Receive UP 0 to TC Mapping
 *   up1map	(size 3, offset 3, init 0):	RW	Receive UP 1 to TC Mapping
 *   up2map	(size 3, offset 6, init 0):	RW	Receive UP 2 to TC Mapping
 *   up3map	(size 3, offset 9, init 0):	RW	Receive UP 3 to TC Mapping
 *   up4map	(size 3, offset 12, init 0):	RW	Receive UP 4 to TC Mapping
 *   up5map	(size 3, offset 15, init 0):	RW	Receive UP 5 to TC Mapping
 *   up6map	(size 3, offset 18, init 0):	RW	Receive UP 6 to TC Mapping
 *   up7map	(size 3, offset 21, init 0):	RW	Receive UP 7 to TC Mapping
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline e10k_rtrup2tc_t e10k_rtrup2tc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3020));
}

static inline e10k_rtrup2tc_t e10k_rtrup2tc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rtrup2tc_t e10k_rtrup2tc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x3020));
}

static inline void e10k_rtrup2tc_rawwr(__DN(t) *_dev, e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_rawwr(__DN(t) *_dev, e10k_rtrup2tc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
}

static inline void e10k_rtrup2tc_wr(__DN(t) *_dev, e10k_rtrup2tc_t _regval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_wr(__DN(t) *_dev, e10k_rtrup2tc_t _regval)
{
    _regval = (_regval & 0xffffff);
    // No MB1 fields present
    _regval = (_regval | (0xff000000 & mackerel_read_addr_32(_dev->base, 0x3020)));
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
}

static inline int e10k_rtrup2tc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rtrup2tc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rtrup2tc (DCB Receive User Priority to Traffic Class): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up0map =\t%" PRIx8 "\t(Receive UP 0 to TC Mapping)\n", e10k_rtrup2tc_up0map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up1map =\t%" PRIx8 "\t(Receive UP 1 to TC Mapping)\n", e10k_rtrup2tc_up1map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up2map =\t%" PRIx8 "\t(Receive UP 2 to TC Mapping)\n", e10k_rtrup2tc_up2map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up3map =\t%" PRIx8 "\t(Receive UP 3 to TC Mapping)\n", e10k_rtrup2tc_up3map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up4map =\t%" PRIx8 "\t(Receive UP 4 to TC Mapping)\n", e10k_rtrup2tc_up4map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up5map =\t%" PRIx8 "\t(Receive UP 5 to TC Mapping)\n", e10k_rtrup2tc_up5map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up6map =\t%" PRIx8 "\t(Receive UP 6 to TC Mapping)\n", e10k_rtrup2tc_up6map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up7map =\t%" PRIx8 "\t(Receive UP 7 to TC Mapping)\n", e10k_rtrup2tc_up7map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t e10k_rtrup2tc_up0map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up0map_rdf(__DN(t) *_dev)
{
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    return(e10k_rtrup2tc_up0map_extract(_regval));
}

static inline uint8_t e10k_rtrup2tc_up1map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up1map_rdf(__DN(t) *_dev)
{
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    return(e10k_rtrup2tc_up1map_extract(_regval));
}

static inline uint8_t e10k_rtrup2tc_up2map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up2map_rdf(__DN(t) *_dev)
{
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    return(e10k_rtrup2tc_up2map_extract(_regval));
}

static inline uint8_t e10k_rtrup2tc_up3map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up3map_rdf(__DN(t) *_dev)
{
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    return(e10k_rtrup2tc_up3map_extract(_regval));
}

static inline uint8_t e10k_rtrup2tc_up4map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up4map_rdf(__DN(t) *_dev)
{
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    return(e10k_rtrup2tc_up4map_extract(_regval));
}

static inline uint8_t e10k_rtrup2tc_up5map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up5map_rdf(__DN(t) *_dev)
{
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    return(e10k_rtrup2tc_up5map_extract(_regval));
}

static inline uint8_t e10k_rtrup2tc_up6map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up6map_rdf(__DN(t) *_dev)
{
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    return(e10k_rtrup2tc_up6map_extract(_regval));
}

static inline uint8_t e10k_rtrup2tc_up7map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrup2tc_up7map_rdf(__DN(t) *_dev)
{
    e10k_rtrup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0x3020);
    return(e10k_rtrup2tc_up7map_extract(_regval));
}

static inline void e10k_rtrup2tc_up0map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_up0map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrup2tc_t _regval = 0x7 & (((e10k_rtrup2tc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0x3020)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrup2tc_up1map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_up1map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrup2tc_t _regval = 0x38 & (((e10k_rtrup2tc_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffc7 & mackerel_read_addr_32(_dev->base, 0x3020)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrup2tc_up2map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_up2map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrup2tc_t _regval = 0x1c0 & (((e10k_rtrup2tc_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfffffe3f & mackerel_read_addr_32(_dev->base, 0x3020)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrup2tc_up3map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_up3map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrup2tc_t _regval = 0xe00 & (((e10k_rtrup2tc_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff1ff & mackerel_read_addr_32(_dev->base, 0x3020)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrup2tc_up4map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_up4map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrup2tc_t _regval = 0x7000 & (((e10k_rtrup2tc_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffff8fff & mackerel_read_addr_32(_dev->base, 0x3020)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrup2tc_up5map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_up5map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrup2tc_t _regval = 0x38000 & (((e10k_rtrup2tc_t )(_fieldval)) << 15);
    _regval = (_regval | (0xfffc7fff & mackerel_read_addr_32(_dev->base, 0x3020)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrup2tc_up6map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_up6map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrup2tc_t _regval = 0x1c0000 & (((e10k_rtrup2tc_t )(_fieldval)) << 18);
    _regval = (_regval | (0xffe3ffff & mackerel_read_addr_32(_dev->base, 0x3020)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
    // No shadow register to write to
}

static inline void e10k_rtrup2tc_up7map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrup2tc_up7map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rtrup2tc_t _regval = 0xe00000 & (((e10k_rtrup2tc_t )(_fieldval)) << 21);
    _regval = (_regval | (0xff1fffff & mackerel_read_addr_32(_dev->base, 0x3020)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x3020, _regval);
    // No shadow register to write to
}

/*
 * Register rttup2tc: DCB Transmit User Priority to Traffic Class
 * Type: e10k.rttup2tc (Implicit type of DCB Transmit User Priority to Traffic Class register)
 *   up0map	(size 3, offset 0, init 0):	RW	Receive UP 0 to TC Mapping
 *   up1map	(size 3, offset 3, init 0):	RW	Receive UP 1 to TC Mapping
 *   up2map	(size 3, offset 6, init 0):	RW	Receive UP 2 to TC Mapping
 *   up3map	(size 3, offset 9, init 0):	RW	Receive UP 3 to TC Mapping
 *   up4map	(size 3, offset 12, init 0):	RW	Receive UP 4 to TC Mapping
 *   up5map	(size 3, offset 15, init 0):	RW	Receive UP 5 to TC Mapping
 *   up6map	(size 3, offset 18, init 0):	RW	Receive UP 6 to TC Mapping
 *   up7map	(size 3, offset 21, init 0):	RW	Receive UP 7 to TC Mapping
 *   _anon24	(size 8, offset 24, init 0):	RSVD	_
 */
static inline e10k_rttup2tc_t e10k_rttup2tc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc800));
}

static inline e10k_rttup2tc_t e10k_rttup2tc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttup2tc_t e10k_rttup2tc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xc800));
}

static inline void e10k_rttup2tc_rawwr(__DN(t) *_dev, e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_rawwr(__DN(t) *_dev, e10k_rttup2tc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
}

static inline void e10k_rttup2tc_wr(__DN(t) *_dev, e10k_rttup2tc_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_wr(__DN(t) *_dev, e10k_rttup2tc_t _regval)
{
    _regval = (_regval & 0xffffff);
    // No MB1 fields present
    _regval = (_regval | (0xff000000 & mackerel_read_addr_32(_dev->base, 0xc800)));
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
}

static inline int e10k_rttup2tc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rttup2tc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rttup2tc (DCB Transmit User Priority to Traffic Class): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up0map =\t%" PRIx8 "\t(Receive UP 0 to TC Mapping)\n", e10k_rttup2tc_up0map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up1map =\t%" PRIx8 "\t(Receive UP 1 to TC Mapping)\n", e10k_rttup2tc_up1map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up2map =\t%" PRIx8 "\t(Receive UP 2 to TC Mapping)\n", e10k_rttup2tc_up2map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up3map =\t%" PRIx8 "\t(Receive UP 3 to TC Mapping)\n", e10k_rttup2tc_up3map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up4map =\t%" PRIx8 "\t(Receive UP 4 to TC Mapping)\n", e10k_rttup2tc_up4map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up5map =\t%" PRIx8 "\t(Receive UP 5 to TC Mapping)\n", e10k_rttup2tc_up5map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up6map =\t%" PRIx8 "\t(Receive UP 6 to TC Mapping)\n", e10k_rttup2tc_up6map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " up7map =\t%" PRIx8 "\t(Receive UP 7 to TC Mapping)\n", e10k_rttup2tc_up7map_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    return(_r);
}

static inline uint8_t e10k_rttup2tc_up0map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up0map_rdf(__DN(t) *_dev)
{
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    return(e10k_rttup2tc_up0map_extract(_regval));
}

static inline uint8_t e10k_rttup2tc_up1map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up1map_rdf(__DN(t) *_dev)
{
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    return(e10k_rttup2tc_up1map_extract(_regval));
}

static inline uint8_t e10k_rttup2tc_up2map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up2map_rdf(__DN(t) *_dev)
{
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    return(e10k_rttup2tc_up2map_extract(_regval));
}

static inline uint8_t e10k_rttup2tc_up3map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up3map_rdf(__DN(t) *_dev)
{
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    return(e10k_rttup2tc_up3map_extract(_regval));
}

static inline uint8_t e10k_rttup2tc_up4map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up4map_rdf(__DN(t) *_dev)
{
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    return(e10k_rttup2tc_up4map_extract(_regval));
}

static inline uint8_t e10k_rttup2tc_up5map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up5map_rdf(__DN(t) *_dev)
{
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    return(e10k_rttup2tc_up5map_extract(_regval));
}

static inline uint8_t e10k_rttup2tc_up6map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up6map_rdf(__DN(t) *_dev)
{
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    return(e10k_rttup2tc_up6map_extract(_regval));
}

static inline uint8_t e10k_rttup2tc_up7map_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttup2tc_up7map_rdf(__DN(t) *_dev)
{
    e10k_rttup2tc_t _regval = mackerel_read_addr_32(_dev->base, 0xc800);
    return(e10k_rttup2tc_up7map_extract(_regval));
}

static inline void e10k_rttup2tc_up0map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_up0map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttup2tc_t _regval = 0x7 & (((e10k_rttup2tc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff8 & mackerel_read_addr_32(_dev->base, 0xc800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
    // No shadow register to write to
}

static inline void e10k_rttup2tc_up1map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_up1map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttup2tc_t _regval = 0x38 & (((e10k_rttup2tc_t )(_fieldval)) << 3);
    _regval = (_regval | (0xffffffc7 & mackerel_read_addr_32(_dev->base, 0xc800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
    // No shadow register to write to
}

static inline void e10k_rttup2tc_up2map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_up2map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttup2tc_t _regval = 0x1c0 & (((e10k_rttup2tc_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfffffe3f & mackerel_read_addr_32(_dev->base, 0xc800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
    // No shadow register to write to
}

static inline void e10k_rttup2tc_up3map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_up3map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttup2tc_t _regval = 0xe00 & (((e10k_rttup2tc_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff1ff & mackerel_read_addr_32(_dev->base, 0xc800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
    // No shadow register to write to
}

static inline void e10k_rttup2tc_up4map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_up4map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttup2tc_t _regval = 0x7000 & (((e10k_rttup2tc_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffff8fff & mackerel_read_addr_32(_dev->base, 0xc800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
    // No shadow register to write to
}

static inline void e10k_rttup2tc_up5map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_up5map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttup2tc_t _regval = 0x38000 & (((e10k_rttup2tc_t )(_fieldval)) << 15);
    _regval = (_regval | (0xfffc7fff & mackerel_read_addr_32(_dev->base, 0xc800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
    // No shadow register to write to
}

static inline void e10k_rttup2tc_up6map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_up6map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttup2tc_t _regval = 0x1c0000 & (((e10k_rttup2tc_t )(_fieldval)) << 18);
    _regval = (_regval | (0xffe3ffff & mackerel_read_addr_32(_dev->base, 0xc800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
    // No shadow register to write to
}

static inline void e10k_rttup2tc_up7map_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttup2tc_up7map_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttup2tc_t _regval = 0xe00000 & (((e10k_rttup2tc_t )(_fieldval)) << 21);
    _regval = (_regval | (0xff1fffff & mackerel_read_addr_32(_dev->base, 0xc800)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xc800, _regval);
    // No shadow register to write to
}

/*
 * Register array rtrpt4c: DCB Receive Packet Plane T4 Config
 * Type: e10k.rtrpt4c (Implicit type of DCB Receive Packet Plane T4 Config register array)
 *   crq	(size 9, offset 0, init 0):	RW	Credit refill quantum
 *   bwg	(size 3, offset 9, init 0):	RW	Bandwidth group index
 *   mcl	(size 12, offset 12, init 0):	RW	Max credit limit
 *   _anon24	(size 6, offset 24, init 0):	RSVD	_
 *   gsp	(size 1, offset 30, init 0):	RW	Group strict priority
 *   lsp	(size 1, offset 31, init 0):	RW	Link strict priority
 */
static const size_t e10k_rtrpt4c_length = 8;
static inline e10k_rtrpt4c_t e10k_rtrpt4c_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rtrpt4c_t e10k_rtrpt4c_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8))));
}

static inline e10k_rtrpt4c_t e10k_rtrpt4c_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rtrpt4c_t e10k_rtrpt4c_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8))));
}

static inline void e10k_rtrpt4c_rawwr(__DN(t) *_dev, int _i, e10k_rtrpt4c_t _regval) __attribute__ ((always_inline));
static inline void e10k_rtrpt4c_rawwr(__DN(t) *_dev, int _i, e10k_rtrpt4c_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)), _regval);
}

static inline void e10k_rtrpt4c_wr(__DN(t) *_dev, int _i, e10k_rtrpt4c_t _regval) __attribute__ ((always_inline));
static inline void e10k_rtrpt4c_wr(__DN(t) *_dev, int _i, e10k_rtrpt4c_t _regval)
{
    _regval = (_regval & 0xc0ffffff);
    // No MB1 fields present
    _regval = (_regval | (0x3f000000 & mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)), _regval);
}

static inline int e10k_rtrpt4c_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rtrpt4c_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rtrpt4c_t _regval = mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rtrpt4c", _i, "DCB Receive Packet Plane T4 Config");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crq =\t%" PRIx16 "\t(Credit refill quantum)\n", e10k_rtrpt4c_crq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bwg =\t%" PRIx8 "\t(Bandwidth group index)\n", e10k_rtrpt4c_bwg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcl =\t%" PRIx16 "\t(Max credit limit)\n", e10k_rtrpt4c_mcl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gsp =\t%" PRIx8 "\t(Group strict priority)\n", e10k_rtrpt4c_gsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsp =\t%" PRIx8 "\t(Link strict priority)\n", e10k_rtrpt4c_lsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rtrpt4c_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rtrpt4c_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rtrpt4c_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_rtrpt4c_crq_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_rtrpt4c_crq_rdf(__DN(t) *_dev, int _i)
{
    e10k_rtrpt4c_t _regval = mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)));
    return(e10k_rtrpt4c_crq_extract(_regval));
}

static inline uint8_t e10k_rtrpt4c_bwg_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpt4c_bwg_rdf(__DN(t) *_dev, int _i)
{
    e10k_rtrpt4c_t _regval = mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)));
    return(e10k_rtrpt4c_bwg_extract(_regval));
}

static inline uint16_t e10k_rtrpt4c_mcl_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_rtrpt4c_mcl_rdf(__DN(t) *_dev, int _i)
{
    e10k_rtrpt4c_t _regval = mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)));
    return(e10k_rtrpt4c_mcl_extract(_regval));
}

static inline uint8_t e10k_rtrpt4c_gsp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpt4c_gsp_rdf(__DN(t) *_dev, int _i)
{
    e10k_rtrpt4c_t _regval = mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)));
    return(e10k_rtrpt4c_gsp_extract(_regval));
}

static inline uint8_t e10k_rtrpt4c_lsp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rtrpt4c_lsp_rdf(__DN(t) *_dev, int _i)
{
    e10k_rtrpt4c_t _regval = mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)));
    return(e10k_rtrpt4c_lsp_extract(_regval));
}

static inline void e10k_rtrpt4c_crq_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrpt4c_crq_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_rtrpt4c_t _regval = 0x1ff & (((e10k_rtrpt4c_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffe00 & mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rtrpt4c_bwg_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrpt4c_bwg_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rtrpt4c_t _regval = 0xe00 & (((e10k_rtrpt4c_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff1ff & mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rtrpt4c_mcl_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrpt4c_mcl_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_rtrpt4c_t _regval = 0xfff000 & (((e10k_rtrpt4c_t )(_fieldval)) << 12);
    _regval = (_regval | (0xff000fff & mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rtrpt4c_gsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrpt4c_gsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rtrpt4c_t _regval = 0x40000000 & (((e10k_rtrpt4c_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rtrpt4c_lsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rtrpt4c_lsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rtrpt4c_t _regval = 0x80000000 & (((e10k_rtrpt4c_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2140 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array rttdt2c: DCB Transmit Descriptor Plane T2 Config
 * Type: e10k.rttdt2c (Implicit type of DCB Transmit Descriptor Plane T2 Config register array)
 *   crq	(size 9, offset 0, init 0):	RW	Credit refill quantum
 *   bwg	(size 3, offset 9, init 0):	RW	Bandwidth group index
 *   mcl	(size 12, offset 12, init 0):	RW	Max credit limit
 *   _anon24	(size 6, offset 24, init 0):	RSVD	_
 *   gsp	(size 1, offset 30, init 0):	RW	Group strict priority
 *   lsp	(size 1, offset 31, init 0):	RW	Link strict priority
 */
static const size_t e10k_rttdt2c_length = 8;
static inline e10k_rttdt2c_t e10k_rttdt2c_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rttdt2c_t e10k_rttdt2c_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8))));
}

static inline e10k_rttdt2c_t e10k_rttdt2c_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rttdt2c_t e10k_rttdt2c_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8))));
}

static inline void e10k_rttdt2c_rawwr(__DN(t) *_dev, int _i, e10k_rttdt2c_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttdt2c_rawwr(__DN(t) *_dev, int _i, e10k_rttdt2c_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)), _regval);
}

static inline void e10k_rttdt2c_wr(__DN(t) *_dev, int _i, e10k_rttdt2c_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttdt2c_wr(__DN(t) *_dev, int _i, e10k_rttdt2c_t _regval)
{
    _regval = (_regval & 0xc0ffffff);
    // No MB1 fields present
    _regval = (_regval | (0x3f000000 & mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)), _regval);
}

static inline int e10k_rttdt2c_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rttdt2c_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rttdt2c_t _regval = mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rttdt2c", _i, "DCB Transmit Descriptor Plane T2 Config");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crq =\t%" PRIx16 "\t(Credit refill quantum)\n", e10k_rttdt2c_crq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bwg =\t%" PRIx8 "\t(Bandwidth group index)\n", e10k_rttdt2c_bwg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcl =\t%" PRIx16 "\t(Max credit limit)\n", e10k_rttdt2c_mcl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gsp =\t%" PRIx8 "\t(Group strict priority)\n", e10k_rttdt2c_gsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsp =\t%" PRIx8 "\t(Link strict priority)\n", e10k_rttdt2c_lsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rttdt2c_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rttdt2c_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rttdt2c_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_rttdt2c_crq_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_rttdt2c_crq_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttdt2c_t _regval = mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)));
    return(e10k_rttdt2c_crq_extract(_regval));
}

static inline uint8_t e10k_rttdt2c_bwg_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdt2c_bwg_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttdt2c_t _regval = mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)));
    return(e10k_rttdt2c_bwg_extract(_regval));
}

static inline uint16_t e10k_rttdt2c_mcl_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_rttdt2c_mcl_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttdt2c_t _regval = mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)));
    return(e10k_rttdt2c_mcl_extract(_regval));
}

static inline uint8_t e10k_rttdt2c_gsp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdt2c_gsp_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttdt2c_t _regval = mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)));
    return(e10k_rttdt2c_gsp_extract(_regval));
}

static inline uint8_t e10k_rttdt2c_lsp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdt2c_lsp_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttdt2c_t _regval = mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)));
    return(e10k_rttdt2c_lsp_extract(_regval));
}

static inline void e10k_rttdt2c_crq_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdt2c_crq_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_rttdt2c_t _regval = 0x1ff & (((e10k_rttdt2c_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffe00 & mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rttdt2c_bwg_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdt2c_bwg_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rttdt2c_t _regval = 0xe00 & (((e10k_rttdt2c_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff1ff & mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rttdt2c_mcl_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdt2c_mcl_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_rttdt2c_t _regval = 0xfff000 & (((e10k_rttdt2c_t )(_fieldval)) << 12);
    _regval = (_regval | (0xff000fff & mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rttdt2c_gsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdt2c_gsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rttdt2c_t _regval = 0x40000000 & (((e10k_rttdt2c_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rttdt2c_lsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdt2c_lsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rttdt2c_t _regval = 0x80000000 & (((e10k_rttdt2c_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4910 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array rttpt2c: DCB Transmit Packet Plane T2 Config
 * Type: e10k.rttpt2c (Implicit type of DCB Transmit Packet Plane T2 Config register array)
 *   crq	(size 9, offset 0, init 0):	RW	Credit refill quantum
 *   bwg	(size 3, offset 9, init 0):	RW	Bandwidth group index
 *   mcl	(size 12, offset 12, init 0):	RW	Max credit limit
 *   _anon24	(size 6, offset 24, init 0):	RSVD	_
 *   gsp	(size 1, offset 30, init 0):	RW	Group strict priority
 *   lsp	(size 1, offset 31, init 0):	RW	Link strict priority
 */
static const size_t e10k_rttpt2c_length = 8;
static inline e10k_rttpt2c_t e10k_rttpt2c_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rttpt2c_t e10k_rttpt2c_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8))));
}

static inline e10k_rttpt2c_t e10k_rttpt2c_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_rttpt2c_t e10k_rttpt2c_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8))));
}

static inline void e10k_rttpt2c_rawwr(__DN(t) *_dev, int _i, e10k_rttpt2c_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttpt2c_rawwr(__DN(t) *_dev, int _i, e10k_rttpt2c_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)), _regval);
}

static inline void e10k_rttpt2c_wr(__DN(t) *_dev, int _i, e10k_rttpt2c_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttpt2c_wr(__DN(t) *_dev, int _i, e10k_rttpt2c_t _regval)
{
    _regval = (_regval & 0xc0ffffff);
    // No MB1 fields present
    _regval = (_regval | (0x3f000000 & mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)), _regval);
}

static inline int e10k_rttpt2c_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rttpt2c_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rttpt2c_t _regval = mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rttpt2c", _i, "DCB Transmit Packet Plane T2 Config");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crq =\t%" PRIx16 "\t(Credit refill quantum)\n", e10k_rttpt2c_crq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bwg =\t%" PRIx8 "\t(Bandwidth group index)\n", e10k_rttpt2c_bwg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcl =\t%" PRIx16 "\t(Max credit limit)\n", e10k_rttpt2c_mcl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " gsp =\t%" PRIx8 "\t(Group strict priority)\n", e10k_rttpt2c_gsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lsp =\t%" PRIx8 "\t(Link strict priority)\n", e10k_rttpt2c_lsp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rttpt2c_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rttpt2c_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rttpt2c_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_rttpt2c_crq_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_rttpt2c_crq_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttpt2c_t _regval = mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)));
    return(e10k_rttpt2c_crq_extract(_regval));
}

static inline uint8_t e10k_rttpt2c_bwg_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpt2c_bwg_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttpt2c_t _regval = mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)));
    return(e10k_rttpt2c_bwg_extract(_regval));
}

static inline uint16_t e10k_rttpt2c_mcl_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_rttpt2c_mcl_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttpt2c_t _regval = mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)));
    return(e10k_rttpt2c_mcl_extract(_regval));
}

static inline uint8_t e10k_rttpt2c_gsp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpt2c_gsp_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttpt2c_t _regval = mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)));
    return(e10k_rttpt2c_gsp_extract(_regval));
}

static inline uint8_t e10k_rttpt2c_lsp_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_rttpt2c_lsp_rdf(__DN(t) *_dev, int _i)
{
    e10k_rttpt2c_t _regval = mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)));
    return(e10k_rttpt2c_lsp_extract(_regval));
}

static inline void e10k_rttpt2c_crq_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttpt2c_crq_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_rttpt2c_t _regval = 0x1ff & (((e10k_rttpt2c_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffe00 & mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rttpt2c_bwg_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttpt2c_bwg_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rttpt2c_t _regval = 0xe00 & (((e10k_rttpt2c_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff1ff & mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rttpt2c_mcl_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttpt2c_mcl_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_rttpt2c_t _regval = 0xfff000 & (((e10k_rttpt2c_t )(_fieldval)) << 12);
    _regval = (_regval | (0xff000fff & mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rttpt2c_gsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttpt2c_gsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rttpt2c_t _regval = 0x40000000 & (((e10k_rttpt2c_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_rttpt2c_lsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttpt2c_lsp_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_rttpt2c_t _regval = 0x80000000 & (((e10k_rttpt2c_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xcd20 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register rttdqsel: DCB Transmit Descriptor Plane Queue Select
 * Type: e10k.rttdqsel (Implicit type of DCB Transmit Descriptor Plane Queue Select register)
 *   txdq_idx	(size 7, offset 0, init 0):	RW	Tx Descriptor Queue Index
 *   _anon7	(size 25, offset 7, init 0):	RSVD	_
 */
static inline e10k_rttdqsel_t e10k_rttdqsel_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttdqsel_t e10k_rttdqsel_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4904));
}

static inline e10k_rttdqsel_t e10k_rttdqsel_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttdqsel_t e10k_rttdqsel_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4904));
}

static inline void e10k_rttdqsel_rawwr(__DN(t) *_dev, e10k_rttdqsel_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttdqsel_rawwr(__DN(t) *_dev, e10k_rttdqsel_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4904, _regval);
}

static inline void e10k_rttdqsel_wr(__DN(t) *_dev, e10k_rttdqsel_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttdqsel_wr(__DN(t) *_dev, e10k_rttdqsel_t _regval)
{
    _regval = (_regval & 0x7f);
    // No MB1 fields present
    _regval = (_regval | (0xffffff80 & mackerel_read_addr_32(_dev->base, 0x4904)));
    mackerel_write_addr_32(_dev->base, 0x4904, _regval);
}

static inline int e10k_rttdqsel_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rttdqsel_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rttdqsel_t _regval = mackerel_read_addr_32(_dev->base, 0x4904);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rttdqsel (DCB Transmit Descriptor Plane Queue Select): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdq_idx =\t%" PRIx8 "\t(Tx Descriptor Queue Index)\n", e10k_rttdqsel_txdq_idx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline uint8_t e10k_rttdqsel_txdq_idx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttdqsel_txdq_idx_rdf(__DN(t) *_dev)
{
    e10k_rttdqsel_t _regval = mackerel_read_addr_32(_dev->base, 0x4904);
    return(e10k_rttdqsel_txdq_idx_extract(_regval));
}

static inline void e10k_rttdqsel_txdq_idx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdqsel_txdq_idx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttdqsel_t _regval = 0x7f & (((e10k_rttdqsel_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff80 & mackerel_read_addr_32(_dev->base, 0x4904)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4904, _regval);
    // No shadow register to write to
}

/*
 * Register rttdt1c: DCB Transmit Descriptor Plane T1 Config
 * Type: e10k.rttdt1c (Implicit type of DCB Transmit Descriptor Plane T1 Config register)
 *   crq	(size 14, offset 0, init 0):	RW	Credit refill quantum
 *   _anon14	(size 18, offset 14, init 0):	RSVD	_
 */
static inline e10k_rttdt1c_t e10k_rttdt1c_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttdt1c_t e10k_rttdt1c_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4908));
}

static inline e10k_rttdt1c_t e10k_rttdt1c_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttdt1c_t e10k_rttdt1c_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4908));
}

static inline void e10k_rttdt1c_rawwr(__DN(t) *_dev, e10k_rttdt1c_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttdt1c_rawwr(__DN(t) *_dev, e10k_rttdt1c_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4908, _regval);
}

static inline void e10k_rttdt1c_wr(__DN(t) *_dev, e10k_rttdt1c_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttdt1c_wr(__DN(t) *_dev, e10k_rttdt1c_t _regval)
{
    _regval = (_regval & 0x3fff);
    // No MB1 fields present
    _regval = (_regval | (0xffffc000 & mackerel_read_addr_32(_dev->base, 0x4908)));
    mackerel_write_addr_32(_dev->base, 0x4908, _regval);
}

static inline int e10k_rttdt1c_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rttdt1c_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rttdt1c_t _regval = mackerel_read_addr_32(_dev->base, 0x4908);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rttdt1c (DCB Transmit Descriptor Plane T1 Config): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " crq =\t%" PRIx16 "\t(Credit refill quantum)\n", e10k_rttdt1c_crq_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    return(_r);
}

static inline uint16_t e10k_rttdt1c_crq_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_rttdt1c_crq_rdf(__DN(t) *_dev)
{
    e10k_rttdt1c_t _regval = mackerel_read_addr_32(_dev->base, 0x4908);
    return(e10k_rttdt1c_crq_extract(_regval));
}

static inline void e10k_rttdt1c_crq_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttdt1c_crq_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_rttdt1c_t _regval = 0x3fff & (((e10k_rttdt1c_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffc000 & mackerel_read_addr_32(_dev->base, 0x4908)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4908, _regval);
    // No shadow register to write to
}

/*
 * Register rttbcnrc: DCB Transmit Rate-Scheduler Config
 * Type: e10k.rttbcnrc (Implicit type of DCB Transmit Rate-Scheduler Config register)
 *   rf_dec	(size 14, offset 0, init 0):	RW	Tx rate-scheduler rate factor hexadecimal part
 *   rf_int	(size 10, offset 14, init 0):	RW	Tx rate-scheduler rate factor integral part
 *   _anon24	(size 7, offset 24, init 0):	RSVD	_
 *   rs_ena	(size 1, offset 31, init 0):	RW	Tx rate-scheduler enable
 */
static inline e10k_rttbcnrc_t e10k_rttbcnrc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttbcnrc_t e10k_rttbcnrc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4984));
}

static inline e10k_rttbcnrc_t e10k_rttbcnrc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_rttbcnrc_t e10k_rttbcnrc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4984));
}

static inline void e10k_rttbcnrc_rawwr(__DN(t) *_dev, e10k_rttbcnrc_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttbcnrc_rawwr(__DN(t) *_dev, e10k_rttbcnrc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4984, _regval);
}

static inline void e10k_rttbcnrc_wr(__DN(t) *_dev, e10k_rttbcnrc_t _regval) __attribute__ ((always_inline));
static inline void e10k_rttbcnrc_wr(__DN(t) *_dev, e10k_rttbcnrc_t _regval)
{
    _regval = (_regval & 0x80ffffff);
    // No MB1 fields present
    _regval = (_regval | (0x7f000000 & mackerel_read_addr_32(_dev->base, 0x4984)));
    mackerel_write_addr_32(_dev->base, 0x4984, _regval);
}

static inline int e10k_rttbcnrc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rttbcnrc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_rttbcnrc_t _regval = mackerel_read_addr_32(_dev->base, 0x4984);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rttbcnrc (DCB Transmit Rate-Scheduler Config): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rf_dec =\t%" PRIx16 "\t(Tx rate-scheduler rate factor hexadecimal part)\n", e10k_rttbcnrc_rf_dec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rf_int =\t%" PRIx16 "\t(Tx rate-scheduler rate factor integral part)\n", e10k_rttbcnrc_rf_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rs_ena =\t%" PRIx8 "\t(Tx rate-scheduler enable)\n", e10k_rttbcnrc_rs_ena_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_rttbcnrc_rf_dec_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_rttbcnrc_rf_dec_rdf(__DN(t) *_dev)
{
    e10k_rttbcnrc_t _regval = mackerel_read_addr_32(_dev->base, 0x4984);
    return(e10k_rttbcnrc_rf_dec_extract(_regval));
}

static inline uint16_t e10k_rttbcnrc_rf_int_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_rttbcnrc_rf_int_rdf(__DN(t) *_dev)
{
    e10k_rttbcnrc_t _regval = mackerel_read_addr_32(_dev->base, 0x4984);
    return(e10k_rttbcnrc_rf_int_extract(_regval));
}

static inline uint8_t e10k_rttbcnrc_rs_ena_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_rttbcnrc_rs_ena_rdf(__DN(t) *_dev)
{
    e10k_rttbcnrc_t _regval = mackerel_read_addr_32(_dev->base, 0x4984);
    return(e10k_rttbcnrc_rs_ena_extract(_regval));
}

static inline void e10k_rttbcnrc_rf_dec_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttbcnrc_rf_dec_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_rttbcnrc_t _regval = 0x3fff & (((e10k_rttbcnrc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffc000 & mackerel_read_addr_32(_dev->base, 0x4984)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4984, _regval);
    // No shadow register to write to
}

static inline void e10k_rttbcnrc_rf_int_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttbcnrc_rf_int_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_rttbcnrc_t _regval = 0xffc000 & (((e10k_rttbcnrc_t )(_fieldval)) << 14);
    _regval = (_regval | (0xff003fff & mackerel_read_addr_32(_dev->base, 0x4984)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4984, _regval);
    // No shadow register to write to
}

static inline void e10k_rttbcnrc_rs_ena_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_rttbcnrc_rs_ena_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_rttbcnrc_t _regval = 0x80000000 & (((e10k_rttbcnrc_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x4984)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4984, _regval);
    // No shadow register to write to
}

/*
 * Register array dca_rxctrl_1: Rx DCA Control Register (#0-#63)
 * Type: e10k.dca_rxctrl (Rx DCA Control Register)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rxdca_desc	(size 1, offset 5, init 0):	RW	Descriptor DCA EN
 *   rxdca_hdr	(size 1, offset 6, init 0):	RW	Rx Header DCA EN
 *   rxdca_payl	(size 1, offset 7, init 0):	RW	Payload DCA EN
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   rxdesc_rdro	(size 1, offset 9, init 0):	RW	Rx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   rxdesc_wbro	(size 1, offset 11, init 0):	MBZ	Rx Descriptor Write Back Relax Order Enable
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   rxdata_wrro	(size 1, offset 13, init 0):	RW	Rx data Write Relax Order Enable
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   rxhdr_ro	(size 1, offset 15, init 0):	RW	Rx Split Header Relax Order Enable
 *   _anon16	(size 8, offset 16, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	RW	Physical ID
 */
static const size_t e10k_dca_rxctrl_1_length = 64;
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64)));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64)));
}

static inline void e10k_dca_rxctrl_1_rawwr(__DN(t) *_dev, int _i, e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_rawwr(__DN(t) *_dev, int _i, e10k_dca_rxctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
}

static inline void e10k_dca_rxctrl_1_wr(__DN(t) *_dev, int _i, e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_wr(__DN(t) *_dev, int _i, e10k_dca_rxctrl_t _regval)
{
    _regval = (_regval & 0xff00a2e0);
    // No MB1 fields present
    _regval = (_regval | (0xff551f & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
}

static inline int e10k_dca_rxctrl_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_dca_rxctrl_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dca_rxctrl_1", _i, "Rx DCA Control Register (#0-#63)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_desc =\t%" PRIx8 "\t(Descriptor DCA EN)\n", e10k_dca_rxctrl_rxdca_desc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_hdr =\t%" PRIx8 "\t(Rx Header DCA EN)\n", e10k_dca_rxctrl_rxdca_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_payl =\t%" PRIx8 "\t(Payload DCA EN)\n", e10k_dca_rxctrl_rxdca_payl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_rdro =\t%" PRIx8 "\t(Rx Descriptor Read Relax Order Enable)\n", e10k_dca_rxctrl_rxdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_wbro =\t%" PRIx8 "\t(Rx Descriptor Write Back Relax Order Enable)\n", e10k_dca_rxctrl_rxdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdata_wrro =\t%" PRIx8 "\t(Rx data Write Relax Order Enable)\n", e10k_dca_rxctrl_rxdata_wrro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxhdr_ro =\t%" PRIx8 "\t(Rx Split Header Relax Order Enable)\n", e10k_dca_rxctrl_rxhdr_ro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_dca_rxctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_dca_rxctrl_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dca_rxctrl_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_dca_rxctrl_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_dca_rxctrl_1_rxdca_desc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_1_rxdca_desc_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_dca_rxctrl_rxdca_desc_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_1_rxdca_hdr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_1_rxdca_hdr_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_dca_rxctrl_rxdca_hdr_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_1_rxdca_payl_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_1_rxdca_payl_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_dca_rxctrl_rxdca_payl_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_1_rxdesc_rdro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_1_rxdesc_rdro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_dca_rxctrl_rxdesc_rdro_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_1_rxdata_wrro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_1_rxdata_wrro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_dca_rxctrl_rxdata_wrro_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_1_rxhdr_ro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_1_rxhdr_ro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_dca_rxctrl_rxhdr_ro_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_1_cpuid_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_1_cpuid_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64));
    return(e10k_dca_rxctrl_cpuid_extract(_regval));
}

static inline void e10k_dca_rxctrl_1_rxdca_desc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_rxdca_desc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x20 & (((e10k_dca_rxctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfffff7df & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_1_rxdca_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_rxdca_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x40 & (((e10k_dca_rxctrl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfffff7bf & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_1_rxdca_payl_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_rxdca_payl_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x80 & (((e10k_dca_rxctrl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfffff77f & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_1_rxdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_rxdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x200 & (((e10k_dca_rxctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff5ff & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_1_rxdata_wrro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_rxdata_wrro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x2000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffd7ff & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_1_rxhdr_ro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_rxhdr_ro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x8000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff77ff & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_1_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_1_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0xff000000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfff7ff & mackerel_read_addr_32(_dev->base, 0x100c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x100c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dca_rxctrl_2: Rx DCA Control Register  (#64-#127)
 * Type: e10k.dca_rxctrl (Rx DCA Control Register)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rxdca_desc	(size 1, offset 5, init 0):	RW	Descriptor DCA EN
 *   rxdca_hdr	(size 1, offset 6, init 0):	RW	Rx Header DCA EN
 *   rxdca_payl	(size 1, offset 7, init 0):	RW	Payload DCA EN
 *   _anon8	(size 1, offset 8, init 0):	RSVD	_
 *   rxdesc_rdro	(size 1, offset 9, init 0):	RW	Rx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   rxdesc_wbro	(size 1, offset 11, init 0):	MBZ	Rx Descriptor Write Back Relax Order Enable
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   rxdata_wrro	(size 1, offset 13, init 0):	RW	Rx data Write Relax Order Enable
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   rxhdr_ro	(size 1, offset 15, init 0):	RW	Rx Split Header Relax Order Enable
 *   _anon16	(size 8, offset 16, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	RW	Physical ID
 */
static const size_t e10k_dca_rxctrl_2_length = 64;
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64)));
}

static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_dca_rxctrl_t e10k_dca_rxctrl_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64)));
}

static inline void e10k_dca_rxctrl_2_rawwr(__DN(t) *_dev, int _i, e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_rawwr(__DN(t) *_dev, int _i, e10k_dca_rxctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
}

static inline void e10k_dca_rxctrl_2_wr(__DN(t) *_dev, int _i, e10k_dca_rxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_wr(__DN(t) *_dev, int _i, e10k_dca_rxctrl_t _regval)
{
    _regval = (_regval & 0xff00a2e0);
    // No MB1 fields present
    _regval = (_regval | (0xff551f & mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
}

static inline int e10k_dca_rxctrl_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_dca_rxctrl_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dca_rxctrl_2", _i, "Rx DCA Control Register  (#64-#127)");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_desc =\t%" PRIx8 "\t(Descriptor DCA EN)\n", e10k_dca_rxctrl_rxdca_desc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_hdr =\t%" PRIx8 "\t(Rx Header DCA EN)\n", e10k_dca_rxctrl_rxdca_hdr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdca_payl =\t%" PRIx8 "\t(Payload DCA EN)\n", e10k_dca_rxctrl_rxdca_payl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_rdro =\t%" PRIx8 "\t(Rx Descriptor Read Relax Order Enable)\n", e10k_dca_rxctrl_rxdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdesc_wbro =\t%" PRIx8 "\t(Rx Descriptor Write Back Relax Order Enable)\n", e10k_dca_rxctrl_rxdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxdata_wrro =\t%" PRIx8 "\t(Rx data Write Relax Order Enable)\n", e10k_dca_rxctrl_rxdata_wrro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxhdr_ro =\t%" PRIx8 "\t(Rx Split Header Relax Order Enable)\n", e10k_dca_rxctrl_rxhdr_ro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_dca_rxctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_dca_rxctrl_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dca_rxctrl_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_dca_rxctrl_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_dca_rxctrl_2_rxdca_desc_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_2_rxdca_desc_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64));
    return(e10k_dca_rxctrl_rxdca_desc_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_2_rxdca_hdr_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_2_rxdca_hdr_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64));
    return(e10k_dca_rxctrl_rxdca_hdr_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_2_rxdca_payl_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_2_rxdca_payl_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64));
    return(e10k_dca_rxctrl_rxdca_payl_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_2_rxdesc_rdro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_2_rxdesc_rdro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64));
    return(e10k_dca_rxctrl_rxdesc_rdro_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_2_rxdata_wrro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_2_rxdata_wrro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64));
    return(e10k_dca_rxctrl_rxdata_wrro_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_2_rxhdr_ro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_2_rxhdr_ro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64));
    return(e10k_dca_rxctrl_rxhdr_ro_extract(_regval));
}

static inline uint8_t e10k_dca_rxctrl_2_cpuid_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_rxctrl_2_cpuid_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_rxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64));
    return(e10k_dca_rxctrl_cpuid_extract(_regval));
}

static inline void e10k_dca_rxctrl_2_rxdca_desc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_rxdca_desc_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x20 & (((e10k_dca_rxctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xfffff7df & mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_2_rxdca_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_rxdca_hdr_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x40 & (((e10k_dca_rxctrl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xfffff7bf & mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_2_rxdca_payl_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_rxdca_payl_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x80 & (((e10k_dca_rxctrl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfffff77f & mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_2_rxdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_rxdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x200 & (((e10k_dca_rxctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffff5ff & mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_2_rxdata_wrro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_rxdata_wrro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x2000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffd7ff & mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_2_rxhdr_ro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_rxhdr_ro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0x8000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff77ff & mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_rxctrl_2_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_rxctrl_2_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_rxctrl_t _regval = 0xff000000 & (((e10k_dca_rxctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfff7ff & mackerel_read_addr_32(_dev->base, 0xd00c + (_i * 64))));
    // No read of register shadow required
    _regval = (_regval & 0xfffff7ff);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xd00c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register array dca_txctrl: Tx DCA Control Registers
 * Type: e10k.dca_txctrl (Implicit type of Tx DCA Control Registers register array)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   txdesc_dca	(size 1, offset 5, init 0):	RW	Descriptor DCA Enable
 *   _anon6	(size 3, offset 6, init 0):	RSVD	_
 *   txdesc_rdro	(size 1, offset 9, init 0):	RW	Tx Descriptor Read Relax Order Enable
 *   _anon10	(size 1, offset 10, init 0):	RSVD	_
 *   txdesc_wbro	(size 1, offset 11, init 0):	RW	Relax Order Enable of Tx Descriptor well as head pointer write back
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   txdata_rdro	(size 1, offset 13, init 0):	RW	Tx Data Read Relax Order Enable
 *   _anon14	(size 10, offset 14, init 0):	RSVD	_
 *   cpuid	(size 8, offset 24, init 0):	RW	Physical ID
 */
static const size_t e10k_dca_txctrl_length = 128;
static inline e10k_dca_txctrl_t e10k_dca_txctrl_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_dca_txctrl_t e10k_dca_txctrl_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64)));
}

static inline e10k_dca_txctrl_t e10k_dca_txctrl_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_dca_txctrl_t e10k_dca_txctrl_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64)));
}

static inline void e10k_dca_txctrl_rawwr(__DN(t) *_dev, int _i, e10k_dca_txctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_txctrl_rawwr(__DN(t) *_dev, int _i, e10k_dca_txctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x600c + (_i * 64), _regval);
}

static inline void e10k_dca_txctrl_wr(__DN(t) *_dev, int _i, e10k_dca_txctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_txctrl_wr(__DN(t) *_dev, int _i, e10k_dca_txctrl_t _regval)
{
    _regval = (_regval & 0xff002a20);
    // No MB1 fields present
    _regval = (_regval | (0xffd5df & mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64))));
    mackerel_write_addr_32(_dev->base, 0x600c + (_i * 64), _regval);
}

static inline int e10k_dca_txctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_dca_txctrl_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "dca_txctrl", _i, "Tx DCA Control Registers");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_dca =\t%" PRIx8 "\t(Descriptor DCA Enable)\n", e10k_dca_txctrl_txdesc_dca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_rdro =\t%" PRIx8 "\t(Tx Descriptor Read Relax Order Enable)\n", e10k_dca_txctrl_txdesc_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdesc_wbro =\t%" PRIx8 "\t(Relax Order Enable of Tx Descriptor well as head pointer write back)\n", e10k_dca_txctrl_txdesc_wbro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txdata_rdro =\t%" PRIx8 "\t(Tx Data Read Relax Order Enable)\n", e10k_dca_txctrl_txdata_rdro_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cpuid =\t%" PRIx8 "\t(Physical ID)\n", e10k_dca_txctrl_cpuid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_dca_txctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dca_txctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_dca_txctrl_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint8_t e10k_dca_txctrl_txdesc_dca_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_txdesc_dca_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64));
    return(e10k_dca_txctrl_txdesc_dca_extract(_regval));
}

static inline uint8_t e10k_dca_txctrl_txdesc_rdro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_txdesc_rdro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64));
    return(e10k_dca_txctrl_txdesc_rdro_extract(_regval));
}

static inline uint8_t e10k_dca_txctrl_txdesc_wbro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_txdesc_wbro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64));
    return(e10k_dca_txctrl_txdesc_wbro_extract(_regval));
}

static inline uint8_t e10k_dca_txctrl_txdata_rdro_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_txdata_rdro_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64));
    return(e10k_dca_txctrl_txdata_rdro_extract(_regval));
}

static inline uint8_t e10k_dca_txctrl_cpuid_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_txctrl_cpuid_rdf(__DN(t) *_dev, int _i)
{
    e10k_dca_txctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64));
    return(e10k_dca_txctrl_cpuid_extract(_regval));
}

static inline void e10k_dca_txctrl_txdesc_dca_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_txctrl_txdesc_dca_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_txctrl_t _regval = 0x20 & (((e10k_dca_txctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x600c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_txctrl_txdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_txctrl_txdesc_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_txctrl_t _regval = 0x200 & (((e10k_dca_txctrl_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x600c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_txctrl_txdesc_wbro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_txctrl_txdesc_wbro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_txctrl_t _regval = 0x800 & (((e10k_dca_txctrl_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x600c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_txctrl_txdata_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_txctrl_txdata_rdro_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_txctrl_t _regval = 0x2000 & (((e10k_dca_txctrl_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x600c + (_i * 64), _regval);
    // No shadow register to write to
}

static inline void e10k_dca_txctrl_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_txctrl_cpuid_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_dca_txctrl_t _regval = 0xff000000 & (((e10k_dca_txctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xffffff & mackerel_read_addr_32(_dev->base, 0x600c + (_i * 64))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x600c + (_i * 64), _regval);
    // No shadow register to write to
}

/*
 * Register dca_id: DCA Requester ID Information Register
 * Type: e10k.dca_id (Implicit type of DCA Requester ID Information Register register)
 *   fun_no	(size 3, offset 0, init 0):	RO	Function Number
 *   dev_no	(size 5, offset 3, init 0):	RO	Device Number
 *   bus_no	(size 8, offset 8, init 0):	RO	Bus Number
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_dca_id_t e10k_dca_id_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dca_id_t e10k_dca_id_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11070));
}

static inline e10k_dca_id_t e10k_dca_id_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dca_id_t e10k_dca_id_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11070));
}

static inline void e10k_dca_id_rawwr(__DN(t) *_dev, e10k_dca_id_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_id_rawwr(__DN(t) *_dev, e10k_dca_id_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11070, _regval);
}

// Register dca_id is not writeable
static inline int e10k_dca_id_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dca_id_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dca_id_t _regval = mackerel_read_addr_32(_dev->base, 0x11070);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dca_id (DCA Requester ID Information Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fun_no =\t%" PRIx8 "\t(Function Number)\n", e10k_dca_id_fun_no_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dev_no =\t%" PRIx8 "\t(Device Number)\n", e10k_dca_id_dev_no_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bus_no =\t%" PRIx8 "\t(Bus Number)\n", e10k_dca_id_bus_no_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e10k_dca_id_fun_no_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_id_fun_no_rdf(__DN(t) *_dev)
{
    e10k_dca_id_t _regval = mackerel_read_addr_32(_dev->base, 0x11070);
    return(e10k_dca_id_fun_no_extract(_regval));
}

static inline uint8_t e10k_dca_id_dev_no_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_id_dev_no_rdf(__DN(t) *_dev)
{
    e10k_dca_id_t _regval = mackerel_read_addr_32(_dev->base, 0x11070);
    return(e10k_dca_id_dev_no_extract(_regval));
}

static inline uint8_t e10k_dca_id_bus_no_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_id_bus_no_rdf(__DN(t) *_dev)
{
    e10k_dca_id_t _regval = mackerel_read_addr_32(_dev->base, 0x11070);
    return(e10k_dca_id_bus_no_extract(_regval));
}

/*
 * Register dca_ctrl: DCA Control Register
 * Type: e10k.dca_ctrl (Implicit type of DCA Control Register register)
 *   dca_dis	(size 1, offset 0, init 0):	RW	DCA Disable
 *   dca_mode	(size 4, offset 1, init 0):	RW	DCA Mode
 *   _anon5	(size 27, offset 5, init 0):	RSVD	_
 */
static inline e10k_dca_ctrl_t e10k_dca_ctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dca_ctrl_t e10k_dca_ctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11074));
}

static inline e10k_dca_ctrl_t e10k_dca_ctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dca_ctrl_t e10k_dca_ctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x11074));
}

static inline void e10k_dca_ctrl_rawwr(__DN(t) *_dev, e10k_dca_ctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_ctrl_rawwr(__DN(t) *_dev, e10k_dca_ctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x11074, _regval);
}

static inline void e10k_dca_ctrl_wr(__DN(t) *_dev, e10k_dca_ctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_dca_ctrl_wr(__DN(t) *_dev, e10k_dca_ctrl_t _regval)
{
    _regval = (_regval & 0x1f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffe0 & mackerel_read_addr_32(_dev->base, 0x11074)));
    mackerel_write_addr_32(_dev->base, 0x11074, _regval);
}

static inline int e10k_dca_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_dca_ctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_dca_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x11074);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register dca_ctrl (DCA Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dca_dis =\t%" PRIx8 "\t(DCA Disable)\n", e10k_dca_ctrl_dca_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dca_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dca_mode_prtval(_s + _r, _avail, e10k_dca_ctrl_dca_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(DCA Mode)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    return(_r);
}

static inline uint8_t e10k_dca_ctrl_dca_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_dca_ctrl_dca_dis_rdf(__DN(t) *_dev)
{
    e10k_dca_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x11074);
    return(e10k_dca_ctrl_dca_dis_extract(_regval));
}

static inline e10k_dca_mode_t e10k_dca_ctrl_dca_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dca_mode_t e10k_dca_ctrl_dca_mode_rdf(__DN(t) *_dev)
{
    e10k_dca_ctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x11074);
    return(e10k_dca_ctrl_dca_mode_extract(_regval));
}

static inline void e10k_dca_ctrl_dca_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_ctrl_dca_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_dca_ctrl_t _regval = 0x1 & (((e10k_dca_ctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x11074)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11074, _regval);
    // No shadow register to write to
}

static inline void e10k_dca_ctrl_dca_mode_wrf(__DN(t) *_dev, e10k_dca_mode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_dca_ctrl_dca_mode_wrf(__DN(t) *_dev, e10k_dca_mode_t _fieldval)
{
    e10k_dca_ctrl_t _regval = 0x1e & (((e10k_dca_ctrl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xffffffe1 & mackerel_read_addr_32(_dev->base, 0x11074)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x11074, _regval);
    // No shadow register to write to
}

/*
 * Register secrxctrl: Security Rx Control
 * Type: e10k.secrxctrl (Implicit type of Security Rx Control register)
 *   secrx_dis	(size 1, offset 0, init 0):	RW	Rx Security Offload Disable Bit
 *   rx_dis	(size 1, offset 1, init 0):	RW	Disable Sec Rx Path
 *   _anon2	(size 30, offset 2, init 0):	RSVD	_
 */
static inline e10k_secrxctrl_t e10k_secrxctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_secrxctrl_t e10k_secrxctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8d00));
}

static inline e10k_secrxctrl_t e10k_secrxctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_secrxctrl_t e10k_secrxctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8d00));
}

static inline void e10k_secrxctrl_rawwr(__DN(t) *_dev, e10k_secrxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_secrxctrl_rawwr(__DN(t) *_dev, e10k_secrxctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8d00, _regval);
}

static inline void e10k_secrxctrl_wr(__DN(t) *_dev, e10k_secrxctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_secrxctrl_wr(__DN(t) *_dev, e10k_secrxctrl_t _regval)
{
    _regval = (_regval & 0x3);
    // No MB1 fields present
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0x8d00)));
    mackerel_write_addr_32(_dev->base, 0x8d00, _regval);
}

static inline int e10k_secrxctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_secrxctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_secrxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x8d00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register secrxctrl (Security Rx Control): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " secrx_dis =\t%" PRIx8 "\t(Rx Security Offload Disable Bit)\n", e10k_secrxctrl_secrx_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_dis =\t%" PRIx8 "\t(Disable Sec Rx Path)\n", e10k_secrxctrl_rx_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    return(_r);
}

static inline uint8_t e10k_secrxctrl_secrx_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxctrl_secrx_dis_rdf(__DN(t) *_dev)
{
    e10k_secrxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x8d00);
    return(e10k_secrxctrl_secrx_dis_extract(_regval));
}

static inline uint8_t e10k_secrxctrl_rx_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxctrl_rx_dis_rdf(__DN(t) *_dev)
{
    e10k_secrxctrl_t _regval = mackerel_read_addr_32(_dev->base, 0x8d00);
    return(e10k_secrxctrl_rx_dis_extract(_regval));
}

static inline void e10k_secrxctrl_secrx_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_secrxctrl_secrx_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_secrxctrl_t _regval = 0x1 & (((e10k_secrxctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x8d00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8d00, _regval);
    // No shadow register to write to
}

static inline void e10k_secrxctrl_rx_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_secrxctrl_rx_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_secrxctrl_t _regval = 0x2 & (((e10k_secrxctrl_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x8d00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x8d00, _regval);
    // No shadow register to write to
}

/*
 * Register secrxstat: Security Rx Status
 * Type: e10k.secrxstat (Implicit type of Security Rx Status register)
 *   sr_rdy	(size 1, offset 0, init 0):	RO	Rx security block ready for mode change
 *   sr_off_dis	(size 1, offset 1, init 0):	RO	Security offload is disabled by fuse or strapping pin
 *   eec_rxerr	(size 1, offset 2, init 0):	RO	Unrecoverable ECC error in an Rx SA table occurred
 *   _anon3	(size 29, offset 3, init 0):	RSVD	_
 */
static inline e10k_secrxstat_t e10k_secrxstat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_secrxstat_t e10k_secrxstat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8d04));
}

static inline e10k_secrxstat_t e10k_secrxstat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_secrxstat_t e10k_secrxstat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x8d04));
}

static inline void e10k_secrxstat_rawwr(__DN(t) *_dev, e10k_secrxstat_t _regval) __attribute__ ((always_inline));
static inline void e10k_secrxstat_rawwr(__DN(t) *_dev, e10k_secrxstat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x8d04, _regval);
}

// Register secrxstat is not writeable
static inline int e10k_secrxstat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_secrxstat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_secrxstat_t _regval = mackerel_read_addr_32(_dev->base, 0x8d04);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register secrxstat (Security Rx Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_rdy =\t%" PRIx8 "\t(Rx security block ready for mode change)\n", e10k_secrxstat_sr_rdy_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sr_off_dis =\t%" PRIx8 "\t(Security offload is disabled by fuse or strapping pin)\n", e10k_secrxstat_sr_off_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " eec_rxerr =\t%" PRIx8 "\t(Unrecoverable ECC error in an Rx SA table occurred)\n", e10k_secrxstat_eec_rxerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    return(_r);
}

static inline uint8_t e10k_secrxstat_sr_rdy_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxstat_sr_rdy_rdf(__DN(t) *_dev)
{
    e10k_secrxstat_t _regval = mackerel_read_addr_32(_dev->base, 0x8d04);
    return(e10k_secrxstat_sr_rdy_extract(_regval));
}

static inline uint8_t e10k_secrxstat_sr_off_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxstat_sr_off_dis_rdf(__DN(t) *_dev)
{
    e10k_secrxstat_t _regval = mackerel_read_addr_32(_dev->base, 0x8d04);
    return(e10k_secrxstat_sr_off_dis_extract(_regval));
}

static inline uint8_t e10k_secrxstat_eec_rxerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_secrxstat_eec_rxerr_rdf(__DN(t) *_dev)
{
    e10k_secrxstat_t _regval = mackerel_read_addr_32(_dev->base, 0x8d04);
    return(e10k_secrxstat_eec_rxerr_extract(_regval));
}

/*
 * Register tcptimer: TCP Timer
 * Type: e10k.tcptimer (Implicit type of TCP Timer register)
 *   duration	(size 8, offset 0, init 0):	RW	Duration of the TCP interrupt interval, in ms
 *   kickstart	(size 1, offset 8, init 0):	RW	Counter kick-start
 *   tcpcnt_en	(size 1, offset 9, init 0):	RW	TCP Count Enable
 *   tcpcnt_fin	(size 1, offset 10, init 0):	RW	TCP Count Finish
 *   loop	(size 1, offset 11, init 0):	RW	TCP Loop
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
static inline e10k_tcptimer_t e10k_tcptimer_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_tcptimer_t e10k_tcptimer_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c));
}

static inline e10k_tcptimer_t e10k_tcptimer_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_tcptimer_t e10k_tcptimer_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4c));
}

static inline void e10k_tcptimer_rawwr(__DN(t) *_dev, e10k_tcptimer_t _regval) __attribute__ ((always_inline));
static inline void e10k_tcptimer_rawwr(__DN(t) *_dev, e10k_tcptimer_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
}

static inline void e10k_tcptimer_wr(__DN(t) *_dev, e10k_tcptimer_t _regval) __attribute__ ((always_inline));
static inline void e10k_tcptimer_wr(__DN(t) *_dev, e10k_tcptimer_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x4c)));
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
}

static inline int e10k_tcptimer_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tcptimer_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_tcptimer_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tcptimer (TCP Timer): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " duration =\t%" PRIx8 "\t(Duration of the TCP interrupt interval, in ms)\n", e10k_tcptimer_duration_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kickstart =\t%" PRIx8 "\t(Counter kick-start)\n", e10k_tcptimer_kickstart_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcpcnt_en =\t%" PRIx8 "\t(TCP Count Enable)\n", e10k_tcptimer_tcpcnt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tcpcnt_fin =\t%" PRIx8 "\t(TCP Count Finish)\n", e10k_tcptimer_tcpcnt_fin_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " loop =\t%" PRIx8 "\t(TCP Loop)\n", e10k_tcptimer_loop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline uint8_t e10k_tcptimer_duration_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_duration_rdf(__DN(t) *_dev)
{
    e10k_tcptimer_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(e10k_tcptimer_duration_extract(_regval));
}

static inline uint8_t e10k_tcptimer_kickstart_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_kickstart_rdf(__DN(t) *_dev)
{
    e10k_tcptimer_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(e10k_tcptimer_kickstart_extract(_regval));
}

static inline uint8_t e10k_tcptimer_tcpcnt_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_tcpcnt_en_rdf(__DN(t) *_dev)
{
    e10k_tcptimer_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(e10k_tcptimer_tcpcnt_en_extract(_regval));
}

static inline uint8_t e10k_tcptimer_tcpcnt_fin_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_tcpcnt_fin_rdf(__DN(t) *_dev)
{
    e10k_tcptimer_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(e10k_tcptimer_tcpcnt_fin_extract(_regval));
}

static inline uint8_t e10k_tcptimer_loop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_tcptimer_loop_rdf(__DN(t) *_dev)
{
    e10k_tcptimer_t _regval = mackerel_read_addr_32(_dev->base, 0x4c);
    return(e10k_tcptimer_loop_extract(_regval));
}

static inline void e10k_tcptimer_duration_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_tcptimer_duration_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_tcptimer_t _regval = 0xff & (((e10k_tcptimer_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void e10k_tcptimer_kickstart_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_tcptimer_kickstart_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_tcptimer_t _regval = 0x100 & (((e10k_tcptimer_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void e10k_tcptimer_tcpcnt_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_tcptimer_tcpcnt_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_tcptimer_t _regval = 0x200 & (((e10k_tcptimer_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void e10k_tcptimer_tcpcnt_fin_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_tcptimer_tcpcnt_fin_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_tcptimer_t _regval = 0x400 & (((e10k_tcptimer_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

static inline void e10k_tcptimer_loop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_tcptimer_loop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_tcptimer_t _regval = 0x800 & (((e10k_tcptimer_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x4c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4c, _regval);
    // No shadow register to write to
}

/*
 * Register fdirctrl: Flow Director Filters Control Register
 * Type: e10k.fdirctrl (Implicit type of Flow Director Filters Control Register register)
 *   pballoc	(size 2, offset 0, init 0):	RW	Memory allocation for the flow director filters
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   init_done	(size 1, offset 3, init 0):	RW	Flow director initialization completion indication
 *   perf_match	(size 1, offset 4, init 0):	RW	Flow director filters mode of operation
 *   rep_stat	(size 1, offset 5, init 0):	RW	Report flow director filter's status on matching packets
 *   _anon6	(size 1, offset 6, init 0):	RSVD	_
 *   rep_statalw	(size 1, offset 7, init 0):	RW	Report flow director filter's status always
 *   drop_queue	(size 7, offset 8, init 0):	RW	Absolute Rx queue index used for the dropped packets
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   flex_off	(size 5, offset 16, init 0):	RW	Offset of a flexible 2-byte tuple in packet
 *   _anon21	(size 3, offset 21, init 0):	RSVD	_
 *   max_len	(size 4, offset 24, init 0):	RW	Maximum linked list length
 *   full_thresh	(size 4, offset 28, init 0):	RW	Recommended minimum number of flows that should remain unused
 */
static inline e10k_fdirctrl_t e10k_fdirctrl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee00));
}

static inline e10k_fdirctrl_t e10k_fdirctrl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirctrl_t e10k_fdirctrl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee00));
}

static inline void e10k_fdirctrl_rawwr(__DN(t) *_dev, e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_rawwr(__DN(t) *_dev, e10k_fdirctrl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
}

static inline void e10k_fdirctrl_wr(__DN(t) *_dev, e10k_fdirctrl_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_wr(__DN(t) *_dev, e10k_fdirctrl_t _regval)
{
    _regval = (_regval & 0xff1f7fbb);
    // No MB1 fields present
    _regval = (_regval | (0xe08044 & mackerel_read_addr_32(_dev->base, 0xee00)));
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
}

static inline int e10k_fdirctrl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirctrl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirctrl (Flow Director Filters Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pballoc =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pballoc_prtval(_s + _r, _avail, e10k_fdirctrl_pballoc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Memory allocation for the flow director filters)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " init_done =\t%" PRIx8 "\t(Flow director initialization completion indication)\n", e10k_fdirctrl_init_done_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " perf_match =\t%" PRIx8 "\t(Flow director filters mode of operation)\n", e10k_fdirctrl_perf_match_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rep_stat =\t%" PRIx8 "\t(Report flow director filter's status on matching packets)\n", e10k_fdirctrl_rep_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rep_statalw =\t%" PRIx8 "\t(Report flow director filter's status always)\n", e10k_fdirctrl_rep_statalw_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop_queue =\t%" PRIx8 "\t(Absolute Rx queue index used for the dropped packets)\n", e10k_fdirctrl_drop_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex_off =\t%" PRIx8 "\t(Offset of a flexible 2-byte tuple in packet)\n", e10k_fdirctrl_flex_off_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " max_len =\t%" PRIx8 "\t(Maximum linked list length)\n", e10k_fdirctrl_max_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " full_thresh =\t%" PRIx8 "\t(Recommended minimum number of flows that should remain unused)\n", e10k_fdirctrl_full_thresh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline e10k_pballoc_t e10k_fdirctrl_pballoc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pballoc_t e10k_fdirctrl_pballoc_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_pballoc_extract(_regval));
}

static inline uint8_t e10k_fdirctrl_init_done_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_init_done_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_init_done_extract(_regval));
}

static inline uint8_t e10k_fdirctrl_perf_match_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_perf_match_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_perf_match_extract(_regval));
}

static inline uint8_t e10k_fdirctrl_rep_stat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_rep_stat_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_rep_stat_extract(_regval));
}

static inline uint8_t e10k_fdirctrl_rep_statalw_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_rep_statalw_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_rep_statalw_extract(_regval));
}

static inline uint8_t e10k_fdirctrl_drop_queue_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_drop_queue_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_drop_queue_extract(_regval));
}

static inline uint8_t e10k_fdirctrl_flex_off_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_flex_off_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_flex_off_extract(_regval));
}

static inline uint8_t e10k_fdirctrl_max_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_max_len_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_max_len_extract(_regval));
}

static inline uint8_t e10k_fdirctrl_full_thresh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirctrl_full_thresh_rdf(__DN(t) *_dev)
{
    e10k_fdirctrl_t _regval = mackerel_read_addr_32(_dev->base, 0xee00);
    return(e10k_fdirctrl_full_thresh_extract(_regval));
}

static inline void e10k_fdirctrl_pballoc_wrf(__DN(t) *_dev, e10k_pballoc_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_pballoc_wrf(__DN(t) *_dev, e10k_pballoc_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0x3 & (((e10k_fdirctrl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirctrl_init_done_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_init_done_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0x8 & (((e10k_fdirctrl_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirctrl_perf_match_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_perf_match_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0x10 & (((e10k_fdirctrl_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirctrl_rep_stat_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_rep_stat_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0x20 & (((e10k_fdirctrl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirctrl_rep_statalw_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_rep_statalw_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0x80 & (((e10k_fdirctrl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirctrl_drop_queue_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_drop_queue_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0x7f00 & (((e10k_fdirctrl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff80ff & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirctrl_flex_off_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_flex_off_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0x1f0000 & (((e10k_fdirctrl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffe0ffff & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirctrl_max_len_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_max_len_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0xf000000 & (((e10k_fdirctrl_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf0ffffff & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirctrl_full_thresh_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirctrl_full_thresh_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirctrl_t _regval = 0xf0000000 & (((e10k_fdirctrl_t )(_fieldval)) << 28);
    _regval = (_regval | (0xfffffff & mackerel_read_addr_32(_dev->base, 0xee00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee00, _regval);
    // No shadow register to write to
}

/*
 * Register fdirhkey: Flow Director Filters Lookup Table HASH Key
 * Type: e10k.fdirhkey (Implicit type of Flow Director Filters Lookup Table HASH Key register)
 *   key	(size 32, offset 0, init 0):	RW	Programmable hash lookup table key
 */
static inline e10k_fdirhkey_t e10k_fdirhkey_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirhkey_t e10k_fdirhkey_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee68));
}

static inline e10k_fdirhkey_t e10k_fdirhkey_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirhkey_t e10k_fdirhkey_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee68));
}

static inline void e10k_fdirhkey_rawwr(__DN(t) *_dev, e10k_fdirhkey_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirhkey_rawwr(__DN(t) *_dev, e10k_fdirhkey_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee68, _regval);
}

static inline void e10k_fdirhkey_wr(__DN(t) *_dev, e10k_fdirhkey_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirhkey_wr(__DN(t) *_dev, e10k_fdirhkey_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee68, _regval);
}

static inline int e10k_fdirhkey_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirhkey_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirhkey_t _regval = mackerel_read_addr_32(_dev->base, 0xee68);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirhkey (Flow Director Filters Lookup Table HASH Key): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " key =\t%" PRIx32 "\t(Programmable hash lookup table key)\n", e10k_fdirhkey_key_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fdirhkey_key_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirhkey_key_rdf(__DN(t) *_dev)
{
    e10k_fdirhkey_t _regval = mackerel_read_addr_32(_dev->base, 0xee68);
    return(e10k_fdirhkey_key_extract(_regval));
}

static inline void e10k_fdirhkey_key_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirhkey_key_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_fdirhkey_t _regval = 0xffffffff & (((e10k_fdirhkey_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee68, _regval);
    // No shadow register to write to
}

/*
 * Register fdirskey: Flow Director Filters Signature Hash Key 
 * Type: e10k.fdirskey (Implicit type of Flow Director Filters Signature Hash Key  register)
 *   key	(size 32, offset 0, init 0):	RW	rogrammable Signature Key
 */
static inline e10k_fdirskey_t e10k_fdirskey_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirskey_t e10k_fdirskey_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee6c));
}

static inline e10k_fdirskey_t e10k_fdirskey_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirskey_t e10k_fdirskey_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee6c));
}

static inline void e10k_fdirskey_rawwr(__DN(t) *_dev, e10k_fdirskey_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirskey_rawwr(__DN(t) *_dev, e10k_fdirskey_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee6c, _regval);
}

static inline void e10k_fdirskey_wr(__DN(t) *_dev, e10k_fdirskey_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirskey_wr(__DN(t) *_dev, e10k_fdirskey_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee6c, _regval);
}

static inline int e10k_fdirskey_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirskey_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirskey_t _regval = mackerel_read_addr_32(_dev->base, 0xee6c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirskey (Flow Director Filters Signature Hash Key ): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " key =\t%" PRIx32 "\t(rogrammable Signature Key)\n", e10k_fdirskey_key_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fdirskey_key_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirskey_key_rdf(__DN(t) *_dev)
{
    e10k_fdirskey_t _regval = mackerel_read_addr_32(_dev->base, 0xee6c);
    return(e10k_fdirskey_key_extract(_regval));
}

static inline void e10k_fdirskey_key_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirskey_key_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_fdirskey_t _regval = 0xffffffff & (((e10k_fdirskey_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee6c, _regval);
    // No shadow register to write to
}

/*
 * Register fdirdip4m: Flow Director Filters DIPv4 Mask
 * Type: e10k.fdirdip4m (Implicit type of Flow Director Filters DIPv4 Mask register)
 *   ipm	(size 32, offset 0, init 0):	RW	Mask Destination IPv4 Address
 */
static inline e10k_fdirdip4m_t e10k_fdirdip4m_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirdip4m_t e10k_fdirdip4m_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee3c));
}

static inline e10k_fdirdip4m_t e10k_fdirdip4m_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirdip4m_t e10k_fdirdip4m_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee3c));
}

static inline void e10k_fdirdip4m_rawwr(__DN(t) *_dev, e10k_fdirdip4m_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirdip4m_rawwr(__DN(t) *_dev, e10k_fdirdip4m_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee3c, _regval);
}

static inline void e10k_fdirdip4m_wr(__DN(t) *_dev, e10k_fdirdip4m_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirdip4m_wr(__DN(t) *_dev, e10k_fdirdip4m_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee3c, _regval);
}

static inline int e10k_fdirdip4m_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirdip4m_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirdip4m_t _regval = mackerel_read_addr_32(_dev->base, 0xee3c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirdip4m (Flow Director Filters DIPv4 Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipm =\t%" PRIx32 "\t(Mask Destination IPv4 Address)\n", e10k_fdirdip4m_ipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fdirdip4m_ipm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirdip4m_ipm_rdf(__DN(t) *_dev)
{
    e10k_fdirdip4m_t _regval = mackerel_read_addr_32(_dev->base, 0xee3c);
    return(e10k_fdirdip4m_ipm_extract(_regval));
}

static inline void e10k_fdirdip4m_ipm_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirdip4m_ipm_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_fdirdip4m_t _regval = 0xffffffff & (((e10k_fdirdip4m_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee3c, _regval);
    // No shadow register to write to
}

/*
 * Register fdirsip4m: Flow Director Filters Source IPv4 Mask
 * Type: e10k.fdirsip4m (Implicit type of Flow Director Filters Source IPv4 Mask register)
 *   ipm	(size 32, offset 0, init 0):	RW	Mask Source IPv4 Address
 */
static inline e10k_fdirsip4m_t e10k_fdirsip4m_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirsip4m_t e10k_fdirsip4m_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee40));
}

static inline e10k_fdirsip4m_t e10k_fdirsip4m_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirsip4m_t e10k_fdirsip4m_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee40));
}

static inline void e10k_fdirsip4m_rawwr(__DN(t) *_dev, e10k_fdirsip4m_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirsip4m_rawwr(__DN(t) *_dev, e10k_fdirsip4m_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee40, _regval);
}

static inline void e10k_fdirsip4m_wr(__DN(t) *_dev, e10k_fdirsip4m_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirsip4m_wr(__DN(t) *_dev, e10k_fdirsip4m_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee40, _regval);
}

static inline int e10k_fdirsip4m_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirsip4m_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirsip4m_t _regval = mackerel_read_addr_32(_dev->base, 0xee40);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirsip4m (Flow Director Filters Source IPv4 Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipm =\t%" PRIx32 "\t(Mask Source IPv4 Address)\n", e10k_fdirsip4m_ipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fdirsip4m_ipm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirsip4m_ipm_rdf(__DN(t) *_dev)
{
    e10k_fdirsip4m_t _regval = mackerel_read_addr_32(_dev->base, 0xee40);
    return(e10k_fdirsip4m_ipm_extract(_regval));
}

static inline void e10k_fdirsip4m_ipm_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirsip4m_ipm_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_fdirsip4m_t _regval = 0xffffffff & (((e10k_fdirsip4m_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee40, _regval);
    // No shadow register to write to
}

/*
 * Register fdirtcpm: Flow Director Filters TCP Mask
 * Type: e10k.fdirtcpm (Implicit type of Flow Director Filters TCP Mask register)
 *   sportm	(size 16, offset 0, init 0):	RW	Mask TCP Source Port
 *   dportm	(size 16, offset 16, init 0):	RW	Mask TCP Destination Port
 */
static inline e10k_fdirtcpm_t e10k_fdirtcpm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirtcpm_t e10k_fdirtcpm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee44));
}

static inline e10k_fdirtcpm_t e10k_fdirtcpm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirtcpm_t e10k_fdirtcpm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee44));
}

static inline void e10k_fdirtcpm_rawwr(__DN(t) *_dev, e10k_fdirtcpm_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirtcpm_rawwr(__DN(t) *_dev, e10k_fdirtcpm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee44, _regval);
}

static inline void e10k_fdirtcpm_wr(__DN(t) *_dev, e10k_fdirtcpm_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirtcpm_wr(__DN(t) *_dev, e10k_fdirtcpm_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee44, _regval);
}

static inline int e10k_fdirtcpm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirtcpm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirtcpm_t _regval = mackerel_read_addr_32(_dev->base, 0xee44);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirtcpm (Flow Director Filters TCP Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sportm =\t%" PRIx16 "\t(Mask TCP Source Port)\n", e10k_fdirtcpm_sportm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dportm =\t%" PRIx16 "\t(Mask TCP Destination Port)\n", e10k_fdirtcpm_dportm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_fdirtcpm_sportm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirtcpm_sportm_rdf(__DN(t) *_dev)
{
    e10k_fdirtcpm_t _regval = mackerel_read_addr_32(_dev->base, 0xee44);
    return(e10k_fdirtcpm_sportm_extract(_regval));
}

static inline uint16_t e10k_fdirtcpm_dportm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirtcpm_dportm_rdf(__DN(t) *_dev)
{
    e10k_fdirtcpm_t _regval = mackerel_read_addr_32(_dev->base, 0xee44);
    return(e10k_fdirtcpm_dportm_extract(_regval));
}

static inline void e10k_fdirtcpm_sportm_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirtcpm_sportm_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirtcpm_t _regval = 0xffff & (((e10k_fdirtcpm_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xee44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee44, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirtcpm_dportm_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirtcpm_dportm_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirtcpm_t _regval = 0xffff0000 & (((e10k_fdirtcpm_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0xee44)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee44, _regval);
    // No shadow register to write to
}

/*
 * Register fdirudpm: Flow Director Filters UDP Mask
 * Type: e10k.fdirudpm (Implicit type of Flow Director Filters UDP Mask register)
 *   sportm	(size 16, offset 0, init 0):	RW	Mask UDP Source Port
 *   dportm	(size 16, offset 16, init 0):	RW	Mask UDP Destination Port
 */
static inline e10k_fdirudpm_t e10k_fdirudpm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirudpm_t e10k_fdirudpm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee48));
}

static inline e10k_fdirudpm_t e10k_fdirudpm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirudpm_t e10k_fdirudpm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee48));
}

static inline void e10k_fdirudpm_rawwr(__DN(t) *_dev, e10k_fdirudpm_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirudpm_rawwr(__DN(t) *_dev, e10k_fdirudpm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee48, _regval);
}

static inline void e10k_fdirudpm_wr(__DN(t) *_dev, e10k_fdirudpm_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirudpm_wr(__DN(t) *_dev, e10k_fdirudpm_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee48, _regval);
}

static inline int e10k_fdirudpm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirudpm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirudpm_t _regval = mackerel_read_addr_32(_dev->base, 0xee48);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirudpm (Flow Director Filters UDP Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sportm =\t%" PRIx16 "\t(Mask UDP Source Port)\n", e10k_fdirudpm_sportm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dportm =\t%" PRIx16 "\t(Mask UDP Destination Port)\n", e10k_fdirudpm_dportm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_fdirudpm_sportm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirudpm_sportm_rdf(__DN(t) *_dev)
{
    e10k_fdirudpm_t _regval = mackerel_read_addr_32(_dev->base, 0xee48);
    return(e10k_fdirudpm_sportm_extract(_regval));
}

static inline uint16_t e10k_fdirudpm_dportm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirudpm_dportm_rdf(__DN(t) *_dev)
{
    e10k_fdirudpm_t _regval = mackerel_read_addr_32(_dev->base, 0xee48);
    return(e10k_fdirudpm_dportm_extract(_regval));
}

static inline void e10k_fdirudpm_sportm_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirudpm_sportm_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirudpm_t _regval = 0xffff & (((e10k_fdirudpm_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xee48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee48, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirudpm_dportm_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirudpm_dportm_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirudpm_t _regval = 0xffff0000 & (((e10k_fdirudpm_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0xee48)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee48, _regval);
    // No shadow register to write to
}

/*
 * Register fdirip6m: Flow Director Filters IPv6 Mask
 * Type: e10k.fdirip6m (Implicit type of Flow Director Filters IPv6 Mask register)
 *   sipm	(size 16, offset 0, init 0):	RW	Mask Source IPv6 address
 *   dipm	(size 16, offset 16, init 0):	RW	Mask Destination IPv6 address
 */
static inline e10k_fdirip6m_t e10k_fdirip6m_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirip6m_t e10k_fdirip6m_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee74));
}

static inline e10k_fdirip6m_t e10k_fdirip6m_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirip6m_t e10k_fdirip6m_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee74));
}

static inline void e10k_fdirip6m_rawwr(__DN(t) *_dev, e10k_fdirip6m_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirip6m_rawwr(__DN(t) *_dev, e10k_fdirip6m_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee74, _regval);
}

static inline void e10k_fdirip6m_wr(__DN(t) *_dev, e10k_fdirip6m_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirip6m_wr(__DN(t) *_dev, e10k_fdirip6m_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee74, _regval);
}

static inline int e10k_fdirip6m_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirip6m_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirip6m_t _regval = mackerel_read_addr_32(_dev->base, 0xee74);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirip6m (Flow Director Filters IPv6 Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sipm =\t%" PRIx16 "\t(Mask Source IPv6 address)\n", e10k_fdirip6m_sipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dipm =\t%" PRIx16 "\t(Mask Destination IPv6 address)\n", e10k_fdirip6m_dipm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_fdirip6m_sipm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirip6m_sipm_rdf(__DN(t) *_dev)
{
    e10k_fdirip6m_t _regval = mackerel_read_addr_32(_dev->base, 0xee74);
    return(e10k_fdirip6m_sipm_extract(_regval));
}

static inline uint16_t e10k_fdirip6m_dipm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirip6m_dipm_rdf(__DN(t) *_dev)
{
    e10k_fdirip6m_t _regval = mackerel_read_addr_32(_dev->base, 0xee74);
    return(e10k_fdirip6m_dipm_extract(_regval));
}

static inline void e10k_fdirip6m_sipm_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirip6m_sipm_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirip6m_t _regval = 0xffff & (((e10k_fdirip6m_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xee74)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee74, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirip6m_dipm_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirip6m_dipm_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirip6m_t _regval = 0xffff0000 & (((e10k_fdirip6m_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0xee74)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee74, _regval);
    // No shadow register to write to
}

/*
 * Register fdirm: Flow Director Filters Other Mask
 * Type: e10k.fdirm (Implicit type of Flow Director Filters Other Mask register)
 *   vlanid	(size 1, offset 0, init 0):	RW	Mask VLAN ID tag
 *   vlanp	(size 1, offset 1, init 0):	RW	Mask VLAN Priority tag
 *   pool	(size 1, offset 2, init 0):	RW	Mask Pool
 *   l4p	(size 1, offset 3, init 0):	RW	Mask L4 Protocol
 *   flex	(size 1, offset 4, init 0):	RW	Mask Flexible Tuple
 *   dipv6	(size 1, offset 5, init 0):	RW	Mask Destination IPv6
 *   _anon6	(size 26, offset 6, init 0):	RSVD	_
 */
static inline e10k_fdirm_t e10k_fdirm_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirm_t e10k_fdirm_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee70));
}

static inline e10k_fdirm_t e10k_fdirm_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirm_t e10k_fdirm_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee70));
}

static inline void e10k_fdirm_rawwr(__DN(t) *_dev, e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirm_rawwr(__DN(t) *_dev, e10k_fdirm_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee70, _regval);
}

static inline void e10k_fdirm_wr(__DN(t) *_dev, e10k_fdirm_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirm_wr(__DN(t) *_dev, e10k_fdirm_t _regval)
{
    _regval = (_regval & 0x3f);
    // No MB1 fields present
    _regval = (_regval | (0xffffffc0 & mackerel_read_addr_32(_dev->base, 0xee70)));
    mackerel_write_addr_32(_dev->base, 0xee70, _regval);
}

static inline int e10k_fdirm_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirm_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirm_t _regval = mackerel_read_addr_32(_dev->base, 0xee70);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirm (Flow Director Filters Other Mask): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlanid =\t%" PRIx8 "\t(Mask VLAN ID tag)\n", e10k_fdirm_vlanid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlanp =\t%" PRIx8 "\t(Mask VLAN Priority tag)\n", e10k_fdirm_vlanp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool =\t%" PRIx8 "\t(Mask Pool)\n", e10k_fdirm_pool_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4p =\t%" PRIx8 "\t(Mask L4 Protocol)\n", e10k_fdirm_l4p_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex =\t%" PRIx8 "\t(Mask Flexible Tuple)\n", e10k_fdirm_flex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dipv6 =\t%" PRIx8 "\t(Mask Destination IPv6)\n", e10k_fdirm_dipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    return(_r);
}

static inline uint8_t e10k_fdirm_vlanid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_vlanid_rdf(__DN(t) *_dev)
{
    e10k_fdirm_t _regval = mackerel_read_addr_32(_dev->base, 0xee70);
    return(e10k_fdirm_vlanid_extract(_regval));
}

static inline uint8_t e10k_fdirm_vlanp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_vlanp_rdf(__DN(t) *_dev)
{
    e10k_fdirm_t _regval = mackerel_read_addr_32(_dev->base, 0xee70);
    return(e10k_fdirm_vlanp_extract(_regval));
}

static inline uint8_t e10k_fdirm_pool_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_pool_rdf(__DN(t) *_dev)
{
    e10k_fdirm_t _regval = mackerel_read_addr_32(_dev->base, 0xee70);
    return(e10k_fdirm_pool_extract(_regval));
}

static inline uint8_t e10k_fdirm_l4p_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_l4p_rdf(__DN(t) *_dev)
{
    e10k_fdirm_t _regval = mackerel_read_addr_32(_dev->base, 0xee70);
    return(e10k_fdirm_l4p_extract(_regval));
}

static inline uint8_t e10k_fdirm_flex_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_flex_rdf(__DN(t) *_dev)
{
    e10k_fdirm_t _regval = mackerel_read_addr_32(_dev->base, 0xee70);
    return(e10k_fdirm_flex_extract(_regval));
}

static inline uint8_t e10k_fdirm_dipv6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirm_dipv6_rdf(__DN(t) *_dev)
{
    e10k_fdirm_t _regval = mackerel_read_addr_32(_dev->base, 0xee70);
    return(e10k_fdirm_dipv6_extract(_regval));
}

static inline void e10k_fdirm_vlanid_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirm_vlanid_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirm_t _regval = 0x1 & (((e10k_fdirm_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0xee70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee70, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirm_vlanp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirm_vlanp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirm_t _regval = 0x2 & (((e10k_fdirm_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0xee70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee70, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirm_pool_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirm_pool_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirm_t _regval = 0x4 & (((e10k_fdirm_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0xee70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee70, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirm_l4p_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirm_l4p_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirm_t _regval = 0x8 & (((e10k_fdirm_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0xee70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee70, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirm_flex_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirm_flex_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirm_t _regval = 0x10 & (((e10k_fdirm_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0xee70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee70, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirm_dipv6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirm_dipv6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirm_t _regval = 0x20 & (((e10k_fdirm_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0xee70)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee70, _regval);
    // No shadow register to write to
}

/*
 * Register fdirfree: Flow Director Filters Free
 * Type: e10k.fdirfree (Implicit type of Flow Director Filters Free register)
 *   free	(size 16, offset 0, init 0):	RW	Number of free filters in the flow director Filters logic
 *   coll	(size 15, offset 16, init 0):	RW	Number of filters with collision indication
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_fdirfree_t e10k_fdirfree_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirfree_t e10k_fdirfree_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee38));
}

static inline e10k_fdirfree_t e10k_fdirfree_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirfree_t e10k_fdirfree_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee38));
}

static inline void e10k_fdirfree_rawwr(__DN(t) *_dev, e10k_fdirfree_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirfree_rawwr(__DN(t) *_dev, e10k_fdirfree_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee38, _regval);
}

static inline void e10k_fdirfree_wr(__DN(t) *_dev, e10k_fdirfree_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirfree_wr(__DN(t) *_dev, e10k_fdirfree_t _regval)
{
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0xee38)));
    mackerel_write_addr_32(_dev->base, 0xee38, _regval);
}

static inline int e10k_fdirfree_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirfree_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirfree_t _regval = mackerel_read_addr_32(_dev->base, 0xee38);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirfree (Flow Director Filters Free): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " free =\t%" PRIx16 "\t(Number of free filters in the flow director Filters logic)\n", e10k_fdirfree_free_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " coll =\t%" PRIx16 "\t(Number of filters with collision indication)\n", e10k_fdirfree_coll_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint16_t e10k_fdirfree_free_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirfree_free_rdf(__DN(t) *_dev)
{
    e10k_fdirfree_t _regval = mackerel_read_addr_32(_dev->base, 0xee38);
    return(e10k_fdirfree_free_extract(_regval));
}

static inline uint16_t e10k_fdirfree_coll_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirfree_coll_rdf(__DN(t) *_dev)
{
    e10k_fdirfree_t _regval = mackerel_read_addr_32(_dev->base, 0xee38);
    return(e10k_fdirfree_coll_extract(_regval));
}

static inline void e10k_fdirfree_free_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirfree_free_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirfree_t _regval = 0xffff & (((e10k_fdirfree_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xee38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee38, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirfree_coll_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirfree_coll_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirfree_t _regval = 0x7fff0000 & (((e10k_fdirfree_t )(_fieldval)) << 16);
    _regval = (_regval | (0x8000ffff & mackerel_read_addr_32(_dev->base, 0xee38)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee38, _regval);
    // No shadow register to write to
}

/*
 * Register fdirlen: Flow Director Filters Length
 * Type: e10k.fdirlen (Implicit type of Flow Director Filters Length register)
 *   maxlen	(size 6, offset 0, init 0):	RC	Longest linked list of filters in the table
 *   _anon6	(size 2, offset 6, init 0):	RSVD	_
 *   bucket_len	(size 6, offset 8, init 0):	RC	The length of the linked list indicated by a query command
 *   _anon14	(size 2, offset 14, init 0):	RSVD	_
 *   maxhash	(size 15, offset 16, init 0):	RC	Hash value of the filter that updated the value of the MAXLEN
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_fdirlen_t e10k_fdirlen_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirlen_t e10k_fdirlen_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee4c));
}

static inline e10k_fdirlen_t e10k_fdirlen_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirlen_t e10k_fdirlen_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee4c));
}

static inline void e10k_fdirlen_rawwr(__DN(t) *_dev, e10k_fdirlen_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirlen_rawwr(__DN(t) *_dev, e10k_fdirlen_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee4c, _regval);
}

// Register fdirlen is not writeable
static inline int e10k_fdirlen_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirlen_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirlen_t _regval = mackerel_read_addr_32(_dev->base, 0xee4c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirlen (Flow Director Filters Length): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxlen =\t%" PRIx8 "\t(Longest linked list of filters in the table)\n", e10k_fdirlen_maxlen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bucket_len =\t%" PRIx8 "\t(The length of the linked list indicated by a query command)\n", e10k_fdirlen_bucket_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " maxhash =\t%" PRIx16 "\t(Hash value of the filter that updated the value of the MAXLEN)\n", e10k_fdirlen_maxhash_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t e10k_fdirlen_maxlen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirlen_maxlen_rdf(__DN(t) *_dev)
{
    e10k_fdirlen_t _regval = mackerel_read_addr_32(_dev->base, 0xee4c);
    return(e10k_fdirlen_maxlen_extract(_regval));
}

static inline uint8_t e10k_fdirlen_bucket_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirlen_bucket_len_rdf(__DN(t) *_dev)
{
    e10k_fdirlen_t _regval = mackerel_read_addr_32(_dev->base, 0xee4c);
    return(e10k_fdirlen_bucket_len_extract(_regval));
}

static inline uint16_t e10k_fdirlen_maxhash_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirlen_maxhash_rdf(__DN(t) *_dev)
{
    e10k_fdirlen_t _regval = mackerel_read_addr_32(_dev->base, 0xee4c);
    return(e10k_fdirlen_maxhash_extract(_regval));
}

/*
 * Register fdirustat: Flow Director Filters Usage Statistics
 * Type: e10k.fdirustat (Implicit type of Flow Director Filters Usage Statistics register)
 *   add	(size 16, offset 0, init 0):	RC	Number of added filters
 *   remove	(size 16, offset 16, init 0):	RC	Number of removed filters
 */
static inline e10k_fdirustat_t e10k_fdirustat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirustat_t e10k_fdirustat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee50));
}

static inline e10k_fdirustat_t e10k_fdirustat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirustat_t e10k_fdirustat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee50));
}

static inline void e10k_fdirustat_rawwr(__DN(t) *_dev, e10k_fdirustat_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirustat_rawwr(__DN(t) *_dev, e10k_fdirustat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee50, _regval);
}

// Register fdirustat is not writeable
static inline int e10k_fdirustat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirustat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirustat_t _regval = mackerel_read_addr_32(_dev->base, 0xee50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirustat (Flow Director Filters Usage Statistics): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " add =\t%" PRIx16 "\t(Number of added filters)\n", e10k_fdirustat_add_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " remove =\t%" PRIx16 "\t(Number of removed filters)\n", e10k_fdirustat_remove_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_fdirustat_add_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirustat_add_rdf(__DN(t) *_dev)
{
    e10k_fdirustat_t _regval = mackerel_read_addr_32(_dev->base, 0xee50);
    return(e10k_fdirustat_add_extract(_regval));
}

static inline uint16_t e10k_fdirustat_remove_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirustat_remove_rdf(__DN(t) *_dev)
{
    e10k_fdirustat_t _regval = mackerel_read_addr_32(_dev->base, 0xee50);
    return(e10k_fdirustat_remove_extract(_regval));
}

/*
 * Register fdirfstat: Flow Director Filters Failed Usage Statistics
 * Type: e10k.fdirfstat (Implicit type of Flow Director Filters Failed Usage Statistics register)
 *   fadd	(size 8, offset 0, init 0):	RC	Number of failed added filters
 *   fremove	(size 8, offset 8, init 0):	RC	Number of failed removed filters
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_fdirfstat_t e10k_fdirfstat_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirfstat_t e10k_fdirfstat_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee54));
}

static inline e10k_fdirfstat_t e10k_fdirfstat_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirfstat_t e10k_fdirfstat_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee54));
}

static inline void e10k_fdirfstat_rawwr(__DN(t) *_dev, e10k_fdirfstat_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirfstat_rawwr(__DN(t) *_dev, e10k_fdirfstat_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee54, _regval);
}

// Register fdirfstat is not writeable
static inline int e10k_fdirfstat_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirfstat_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirfstat_t _regval = mackerel_read_addr_32(_dev->base, 0xee54);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirfstat (Flow Director Filters Failed Usage Statistics): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fadd =\t%" PRIx8 "\t(Number of failed added filters)\n", e10k_fdirfstat_fadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fremove =\t%" PRIx8 "\t(Number of failed removed filters)\n", e10k_fdirfstat_fremove_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e10k_fdirfstat_fadd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirfstat_fadd_rdf(__DN(t) *_dev)
{
    e10k_fdirfstat_t _regval = mackerel_read_addr_32(_dev->base, 0xee54);
    return(e10k_fdirfstat_fadd_extract(_regval));
}

static inline uint8_t e10k_fdirfstat_fremove_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirfstat_fremove_rdf(__DN(t) *_dev)
{
    e10k_fdirfstat_t _regval = mackerel_read_addr_32(_dev->base, 0xee54);
    return(e10k_fdirfstat_fremove_extract(_regval));
}

/*
 * Register fdirmatch: Flow Director Filters Match Statistics
 * Type: e10k.fdirmatch (Implicit type of Flow Director Filters Match Statistics register)
 *   pcnt	(size 32, offset 0, init 0):	RC	Number of packets that matched any flow director filter
 */
static inline e10k_fdirmatch_t e10k_fdirmatch_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirmatch_t e10k_fdirmatch_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee58));
}

static inline e10k_fdirmatch_t e10k_fdirmatch_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirmatch_t e10k_fdirmatch_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee58));
}

static inline void e10k_fdirmatch_rawwr(__DN(t) *_dev, e10k_fdirmatch_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirmatch_rawwr(__DN(t) *_dev, e10k_fdirmatch_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee58, _regval);
}

// Register fdirmatch is not writeable
static inline int e10k_fdirmatch_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirmatch_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirmatch_t _regval = mackerel_read_addr_32(_dev->base, 0xee58);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirmatch (Flow Director Filters Match Statistics): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcnt =\t%" PRIx32 "\t(Number of packets that matched any flow director filter)\n", e10k_fdirmatch_pcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fdirmatch_pcnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirmatch_pcnt_rdf(__DN(t) *_dev)
{
    e10k_fdirmatch_t _regval = mackerel_read_addr_32(_dev->base, 0xee58);
    return(e10k_fdirmatch_pcnt_extract(_regval));
}

/*
 * Register fdirmiss: Flow Director Filters Miss Match Statistics
 * Type: e10k.fdirmiss (Implicit type of Flow Director Filters Miss Match Statistics register)
 *   pcnt	(size 32, offset 0, init 0):	RC	Number of packets that missed matched any flow director filter
 */
static inline e10k_fdirmiss_t e10k_fdirmiss_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirmiss_t e10k_fdirmiss_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee5c));
}

static inline e10k_fdirmiss_t e10k_fdirmiss_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirmiss_t e10k_fdirmiss_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee5c));
}

static inline void e10k_fdirmiss_rawwr(__DN(t) *_dev, e10k_fdirmiss_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirmiss_rawwr(__DN(t) *_dev, e10k_fdirmiss_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee5c, _regval);
}

// Register fdirmiss is not writeable
static inline int e10k_fdirmiss_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirmiss_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirmiss_t _regval = mackerel_read_addr_32(_dev->base, 0xee5c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirmiss (Flow Director Filters Miss Match Statistics): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcnt =\t%" PRIx32 "\t(Number of packets that missed matched any flow director filter)\n", e10k_fdirmiss_pcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fdirmiss_pcnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirmiss_pcnt_rdf(__DN(t) *_dev)
{
    e10k_fdirmiss_t _regval = mackerel_read_addr_32(_dev->base, 0xee5c);
    return(e10k_fdirmiss_pcnt_extract(_regval));
}

/*
 * Register array fdirsipv6: Flow Director Filters Source IPv6
 * Type: e10k.fdirsipv6 (Implicit type of Flow Director Filters Source IPv6 register array)
 *   ip6sa	(size 32, offset 0, init 0):	RW	Three MS DWords of the source IPv6 address
 */
static const size_t e10k_fdirsipv6_length = 3;
static inline e10k_fdirsipv6_t e10k_fdirsipv6_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_fdirsipv6_t e10k_fdirsipv6_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xee0c + (_i * (32 / 8))));
}

static inline e10k_fdirsipv6_t e10k_fdirsipv6_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_fdirsipv6_t e10k_fdirsipv6_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xee0c + (_i * (32 / 8))));
}

static inline void e10k_fdirsipv6_rawwr(__DN(t) *_dev, int _i, e10k_fdirsipv6_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirsipv6_rawwr(__DN(t) *_dev, int _i, e10k_fdirsipv6_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee0c + (_i * (32 / 8)), _regval);
}

static inline void e10k_fdirsipv6_wr(__DN(t) *_dev, int _i, e10k_fdirsipv6_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirsipv6_wr(__DN(t) *_dev, int _i, e10k_fdirsipv6_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee0c + (_i * (32 / 8)), _regval);
}

static inline int e10k_fdirsipv6_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_fdirsipv6_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirsipv6_t _regval = mackerel_read_addr_32(_dev->base, 0xee0c + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fdirsipv6", _i, "Flow Director Filters Source IPv6");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ip6sa =\t%" PRIx32 "\t(Three MS DWords of the source IPv6 address)\n", e10k_fdirsipv6_ip6sa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_fdirsipv6_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirsipv6_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 3; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_fdirsipv6_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_fdirsipv6_ip6sa_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_fdirsipv6_ip6sa_rdf(__DN(t) *_dev, int _i)
{
    e10k_fdirsipv6_t _regval = mackerel_read_addr_32(_dev->base, 0xee0c + (_i * (32 / 8)));
    return(e10k_fdirsipv6_ip6sa_extract(_regval));
}

static inline void e10k_fdirsipv6_ip6sa_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirsipv6_ip6sa_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_fdirsipv6_t _regval = 0xffffffff & (((e10k_fdirsipv6_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee0c + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register fdiripsa: Flow Director Filters IP SA
 * Type: e10k.fdiripsa (Implicit type of Flow Director Filters IP SA register)
 *   ip4sa	(size 32, offset 0, init 0):	RW	Source IPv4 address or LS Dword of the Source IPv6 address
 */
static inline e10k_fdiripsa_t e10k_fdiripsa_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdiripsa_t e10k_fdiripsa_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee18));
}

static inline e10k_fdiripsa_t e10k_fdiripsa_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdiripsa_t e10k_fdiripsa_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee18));
}

static inline void e10k_fdiripsa_rawwr(__DN(t) *_dev, e10k_fdiripsa_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdiripsa_rawwr(__DN(t) *_dev, e10k_fdiripsa_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee18, _regval);
}

static inline void e10k_fdiripsa_wr(__DN(t) *_dev, e10k_fdiripsa_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdiripsa_wr(__DN(t) *_dev, e10k_fdiripsa_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee18, _regval);
}

static inline int e10k_fdiripsa_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdiripsa_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdiripsa_t _regval = mackerel_read_addr_32(_dev->base, 0xee18);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdiripsa (Flow Director Filters IP SA): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ip4sa =\t%" PRIx32 "\t(Source IPv4 address or LS Dword of the Source IPv6 address)\n", e10k_fdiripsa_ip4sa_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fdiripsa_ip4sa_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fdiripsa_ip4sa_rdf(__DN(t) *_dev)
{
    e10k_fdiripsa_t _regval = mackerel_read_addr_32(_dev->base, 0xee18);
    return(e10k_fdiripsa_ip4sa_extract(_regval));
}

static inline void e10k_fdiripsa_ip4sa_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdiripsa_ip4sa_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_fdiripsa_t _regval = 0xffffffff & (((e10k_fdiripsa_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee18, _regval);
    // No shadow register to write to
}

/*
 * Register fdiripda: Flow Director Filters IP DA
 * Type: e10k.fdiripda (Implicit type of Flow Director Filters IP DA register)
 *   ip4da	(size 32, offset 0, init 0):	RW	Destination IPv4 address
 */
static inline e10k_fdiripda_t e10k_fdiripda_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdiripda_t e10k_fdiripda_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee1c));
}

static inline e10k_fdiripda_t e10k_fdiripda_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdiripda_t e10k_fdiripda_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee1c));
}

static inline void e10k_fdiripda_rawwr(__DN(t) *_dev, e10k_fdiripda_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdiripda_rawwr(__DN(t) *_dev, e10k_fdiripda_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee1c, _regval);
}

static inline void e10k_fdiripda_wr(__DN(t) *_dev, e10k_fdiripda_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdiripda_wr(__DN(t) *_dev, e10k_fdiripda_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee1c, _regval);
}

static inline int e10k_fdiripda_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdiripda_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdiripda_t _regval = mackerel_read_addr_32(_dev->base, 0xee1c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdiripda (Flow Director Filters IP DA): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ip4da =\t%" PRIx32 "\t(Destination IPv4 address)\n", e10k_fdiripda_ip4da_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fdiripda_ip4da_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fdiripda_ip4da_rdf(__DN(t) *_dev)
{
    e10k_fdiripda_t _regval = mackerel_read_addr_32(_dev->base, 0xee1c);
    return(e10k_fdiripda_ip4da_extract(_regval));
}

static inline void e10k_fdiripda_ip4da_wrf(__DN(t) *_dev, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdiripda_ip4da_wrf(__DN(t) *_dev, uint32_t _fieldval)
{
    e10k_fdiripda_t _regval = 0xffffffff & (((e10k_fdiripda_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee1c, _regval);
    // No shadow register to write to
}

/*
 * Register fdirport: Flow Director Filters Port
 * Type: e10k.fdirport (Implicit type of Flow Director Filters Port register)
 *   source	(size 16, offset 0, init 0):	RW	Source Port number
 *   dest	(size 16, offset 16, init 0):	RW	Destination Port number
 */
static inline e10k_fdirport_t e10k_fdirport_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirport_t e10k_fdirport_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee20));
}

static inline e10k_fdirport_t e10k_fdirport_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirport_t e10k_fdirport_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee20));
}

static inline void e10k_fdirport_rawwr(__DN(t) *_dev, e10k_fdirport_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirport_rawwr(__DN(t) *_dev, e10k_fdirport_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee20, _regval);
}

static inline void e10k_fdirport_wr(__DN(t) *_dev, e10k_fdirport_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirport_wr(__DN(t) *_dev, e10k_fdirport_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee20, _regval);
}

static inline int e10k_fdirport_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirport_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirport_t _regval = mackerel_read_addr_32(_dev->base, 0xee20);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirport (Flow Director Filters Port): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " source =\t%" PRIx16 "\t(Source Port number)\n", e10k_fdirport_source_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dest =\t%" PRIx16 "\t(Destination Port number)\n", e10k_fdirport_dest_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_fdirport_source_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirport_source_rdf(__DN(t) *_dev)
{
    e10k_fdirport_t _regval = mackerel_read_addr_32(_dev->base, 0xee20);
    return(e10k_fdirport_source_extract(_regval));
}

static inline uint16_t e10k_fdirport_dest_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirport_dest_rdf(__DN(t) *_dev)
{
    e10k_fdirport_t _regval = mackerel_read_addr_32(_dev->base, 0xee20);
    return(e10k_fdirport_dest_extract(_regval));
}

static inline void e10k_fdirport_source_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirport_source_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirport_t _regval = 0xffff & (((e10k_fdirport_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xee20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee20, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirport_dest_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirport_dest_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirport_t _regval = 0xffff0000 & (((e10k_fdirport_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0xee20)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee20, _regval);
    // No shadow register to write to
}

/*
 * Register fdirvlan: Flow Director Filters VLAN and FLEX Bytes
 * Type: e10k.fdirvlan (Implicit type of Flow Director Filters VLAN and FLEX Bytes register)
 *   vlan	(size 16, offset 0, init 0):	RW	Vlan Tag
 *   flex	(size 16, offset 16, init 0):	RW	Flexible tuple data
 */
static inline e10k_fdirvlan_t e10k_fdirvlan_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirvlan_t e10k_fdirvlan_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee24));
}

static inline e10k_fdirvlan_t e10k_fdirvlan_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirvlan_t e10k_fdirvlan_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee24));
}

static inline void e10k_fdirvlan_rawwr(__DN(t) *_dev, e10k_fdirvlan_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirvlan_rawwr(__DN(t) *_dev, e10k_fdirvlan_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee24, _regval);
}

static inline void e10k_fdirvlan_wr(__DN(t) *_dev, e10k_fdirvlan_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirvlan_wr(__DN(t) *_dev, e10k_fdirvlan_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xee24, _regval);
}

static inline int e10k_fdirvlan_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirvlan_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirvlan_t _regval = mackerel_read_addr_32(_dev->base, 0xee24);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirvlan (Flow Director Filters VLAN and FLEX Bytes): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan =\t%" PRIx16 "\t(Vlan Tag)\n", e10k_fdirvlan_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flex =\t%" PRIx16 "\t(Flexible tuple data)\n", e10k_fdirvlan_flex_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_fdirvlan_vlan_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirvlan_vlan_rdf(__DN(t) *_dev)
{
    e10k_fdirvlan_t _regval = mackerel_read_addr_32(_dev->base, 0xee24);
    return(e10k_fdirvlan_vlan_extract(_regval));
}

static inline uint16_t e10k_fdirvlan_flex_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirvlan_flex_rdf(__DN(t) *_dev)
{
    e10k_fdirvlan_t _regval = mackerel_read_addr_32(_dev->base, 0xee24);
    return(e10k_fdirvlan_flex_extract(_regval));
}

static inline void e10k_fdirvlan_vlan_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirvlan_vlan_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirvlan_t _regval = 0xffff & (((e10k_fdirvlan_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0xee24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee24, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirvlan_flex_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirvlan_flex_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirvlan_t _regval = 0xffff0000 & (((e10k_fdirvlan_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0xee24)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee24, _regval);
    // No shadow register to write to
}

/*
 * Register fdirhash: Flow Director Filters Hash Signature
 * Type: e10k.fdirhash (Implicit type of Flow Director Filters Hash Signature register)
 *   hash	(size 15, offset 0, init 0):	RW	Bucket hash value that identifies a filter's linked list
 *   buck_valid	(size 1, offset 15, init 0):	RW	Bucket Valid (at least 1 filter in bucket)
 *   sig_swidx	(size 15, offset 16, init 0):	RW	Signature / SW Index
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_fdirhash_t e10k_fdirhash_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirhash_t e10k_fdirhash_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee28));
}

static inline e10k_fdirhash_t e10k_fdirhash_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdirhash_t e10k_fdirhash_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee28));
}

static inline void e10k_fdirhash_rawwr(__DN(t) *_dev, e10k_fdirhash_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirhash_rawwr(__DN(t) *_dev, e10k_fdirhash_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee28, _regval);
}

static inline void e10k_fdirhash_wr(__DN(t) *_dev, e10k_fdirhash_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdirhash_wr(__DN(t) *_dev, e10k_fdirhash_t _regval)
{
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0xee28)));
    mackerel_write_addr_32(_dev->base, 0xee28, _regval);
}

static inline int e10k_fdirhash_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdirhash_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdirhash_t _regval = mackerel_read_addr_32(_dev->base, 0xee28);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdirhash (Flow Director Filters Hash Signature): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hash =\t%" PRIx16 "\t(Bucket hash value that identifies a filter's linked list)\n", e10k_fdirhash_hash_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " buck_valid =\t%" PRIx8 "\t(Bucket Valid (at least 1 filter in bucket))\n", e10k_fdirhash_buck_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sig_swidx =\t%" PRIx16 "\t(Signature / SW Index)\n", e10k_fdirhash_sig_swidx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint16_t e10k_fdirhash_hash_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirhash_hash_rdf(__DN(t) *_dev)
{
    e10k_fdirhash_t _regval = mackerel_read_addr_32(_dev->base, 0xee28);
    return(e10k_fdirhash_hash_extract(_regval));
}

static inline uint8_t e10k_fdirhash_buck_valid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdirhash_buck_valid_rdf(__DN(t) *_dev)
{
    e10k_fdirhash_t _regval = mackerel_read_addr_32(_dev->base, 0xee28);
    return(e10k_fdirhash_buck_valid_extract(_regval));
}

static inline uint16_t e10k_fdirhash_sig_swidx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_fdirhash_sig_swidx_rdf(__DN(t) *_dev)
{
    e10k_fdirhash_t _regval = mackerel_read_addr_32(_dev->base, 0xee28);
    return(e10k_fdirhash_sig_swidx_extract(_regval));
}

static inline void e10k_fdirhash_hash_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirhash_hash_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirhash_t _regval = 0x7fff & (((e10k_fdirhash_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff8000 & mackerel_read_addr_32(_dev->base, 0xee28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee28, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirhash_buck_valid_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirhash_buck_valid_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdirhash_t _regval = 0x8000 & (((e10k_fdirhash_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0xee28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee28, _regval);
    // No shadow register to write to
}

static inline void e10k_fdirhash_sig_swidx_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdirhash_sig_swidx_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_fdirhash_t _regval = 0x7fff0000 & (((e10k_fdirhash_t )(_fieldval)) << 16);
    _regval = (_regval | (0x8000ffff & mackerel_read_addr_32(_dev->base, 0xee28)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee28, _regval);
    // No shadow register to write to
}

/*
 * Register fdircmd: Flow Director Filters Command Register
 * Type: e10k.fdircmd (Implicit type of Flow Director Filters Command Register register)
 *   cmd	(size 2, offset 0, init 0):	RW	Flow Director Filter Programming Command
 *   flt_valid	(size 1, offset 2, init 0):	RW	Valid filter is found by the query command
 *   flt_update	(size 1, offset 3, init 0):	RW	Filter Update Command
 *   ipv6_dmatch	(size 1, offset 4, init 0):	RW	IP Destination match to IP6AT filter
 *   l4type	(size 2, offset 5, init 0):	RW	l4type
 *   ipv6	(size 1, offset 7, init 0):	RW	IPv6 packet type
 *   clearht	(size 1, offset 8, init 0):	RW	Clear Internal Flow Director Head and Tail Registers
 *   drop	(size 1, offset 9, init 0):	RW	Packet Drop Action
 *   int	(size 1, offset 10, init 0):	RW	Matched packet generates a LLI
 *   last	(size 1, offset 11, init 0):	RW	Last filter indication in the linked list
 *   collision	(size 1, offset 12, init 0):	RW	Collision Indication
 *   _anon13	(size 2, offset 13, init 0):	RSVD	_
 *   queue_en	(size 1, offset 15, init 0):	RW	Enable routing matched packet to Rx-Queue
 *   rx_queue	(size 7, offset 16, init 0):	RW	Rx Queue Index
 *   _anon23	(size 1, offset 23, init 0):	RSVD	_
 *   pool	(size 6, offset 24, init 0):	RW	Pool (only for VT)
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
static inline e10k_fdircmd_t e10k_fdircmd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee2c));
}

static inline e10k_fdircmd_t e10k_fdircmd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdircmd_t e10k_fdircmd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0xee2c));
}

static inline void e10k_fdircmd_rawwr(__DN(t) *_dev, e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_rawwr(__DN(t) *_dev, e10k_fdircmd_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
}

static inline void e10k_fdircmd_wr(__DN(t) *_dev, e10k_fdircmd_t _regval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_wr(__DN(t) *_dev, e10k_fdircmd_t _regval)
{
    _regval = (_regval & 0x3f7f9fff);
    // No MB1 fields present
    _regval = (_regval | (0xc0806000 & mackerel_read_addr_32(_dev->base, 0xee2c)));
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
}

static inline int e10k_fdircmd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fdircmd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fdircmd (Flow Director Filters Command Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cmd =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdir_cmd_prtval(_s + _r, _avail, e10k_fdircmd_cmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Flow Director Filter Programming Command)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flt_valid =\t%" PRIx8 "\t(Valid filter is found by the query command)\n", e10k_fdircmd_flt_valid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flt_update =\t%" PRIx8 "\t(Filter Update Command)\n", e10k_fdircmd_flt_update_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6_dmatch =\t%" PRIx8 "\t(IP Destination match to IP6AT filter)\n", e10k_fdircmd_ipv6_dmatch_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l4type =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_l4_ptype_prtval(_s + _r, _avail, e10k_fdircmd_l4type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(l4type)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(IPv6 packet type)\n", e10k_fdircmd_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " clearht =\t%" PRIx8 "\t(Clear Internal Flow Director Head and Tail Registers)\n", e10k_fdircmd_clearht_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " drop =\t%" PRIx8 "\t(Packet Drop Action)\n", e10k_fdircmd_drop_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " int =\t%" PRIx8 "\t(Matched packet generates a LLI)\n", e10k_fdircmd_int_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " last =\t%" PRIx8 "\t(Last filter indication in the linked list)\n", e10k_fdircmd_last_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " collision =\t%" PRIx8 "\t(Collision Indication)\n", e10k_fdircmd_collision_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_en =\t%" PRIx8 "\t(Enable routing matched packet to Rx-Queue)\n", e10k_fdircmd_queue_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_queue =\t%" PRIx8 "\t(Rx Queue Index)\n", e10k_fdircmd_rx_queue_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon23 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool =\t%" PRIx8 "\t(Pool (only for VT))\n", e10k_fdircmd_pool_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline e10k_fdir_cmd_t e10k_fdircmd_cmd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fdir_cmd_t e10k_fdircmd_cmd_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_cmd_extract(_regval));
}

static inline uint8_t e10k_fdircmd_flt_valid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_flt_valid_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_flt_valid_extract(_regval));
}

static inline uint8_t e10k_fdircmd_flt_update_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_flt_update_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_flt_update_extract(_regval));
}

static inline uint8_t e10k_fdircmd_ipv6_dmatch_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_ipv6_dmatch_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_ipv6_dmatch_extract(_regval));
}

static inline e10k_l4_ptype_t e10k_fdircmd_l4type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_l4_ptype_t e10k_fdircmd_l4type_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_l4type_extract(_regval));
}

static inline uint8_t e10k_fdircmd_ipv6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_ipv6_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_ipv6_extract(_regval));
}

static inline uint8_t e10k_fdircmd_clearht_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_clearht_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_clearht_extract(_regval));
}

static inline uint8_t e10k_fdircmd_drop_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_drop_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_drop_extract(_regval));
}

static inline uint8_t e10k_fdircmd_int_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_int_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_int_extract(_regval));
}

static inline uint8_t e10k_fdircmd_last_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_last_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_last_extract(_regval));
}

static inline uint8_t e10k_fdircmd_collision_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_collision_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_collision_extract(_regval));
}

static inline uint8_t e10k_fdircmd_queue_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_queue_en_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_queue_en_extract(_regval));
}

static inline uint8_t e10k_fdircmd_rx_queue_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_rx_queue_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_rx_queue_extract(_regval));
}

static inline uint8_t e10k_fdircmd_pool_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_fdircmd_pool_rdf(__DN(t) *_dev)
{
    e10k_fdircmd_t _regval = mackerel_read_addr_32(_dev->base, 0xee2c);
    return(e10k_fdircmd_pool_extract(_regval));
}

static inline void e10k_fdircmd_cmd_wrf(__DN(t) *_dev, e10k_fdir_cmd_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_cmd_wrf(__DN(t) *_dev, e10k_fdir_cmd_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x3 & (((e10k_fdircmd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffc & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_flt_valid_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_flt_valid_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x4 & (((e10k_fdircmd_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_flt_update_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_flt_update_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x8 & (((e10k_fdircmd_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_ipv6_dmatch_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_ipv6_dmatch_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x10 & (((e10k_fdircmd_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_l4type_wrf(__DN(t) *_dev, e10k_l4_ptype_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_l4type_wrf(__DN(t) *_dev, e10k_l4_ptype_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x60 & (((e10k_fdircmd_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffff9f & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_ipv6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_ipv6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x80 & (((e10k_fdircmd_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_clearht_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_clearht_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x100 & (((e10k_fdircmd_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_drop_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_drop_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x200 & (((e10k_fdircmd_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_int_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_int_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x400 & (((e10k_fdircmd_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_last_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_last_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x800 & (((e10k_fdircmd_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_collision_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_collision_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x1000 & (((e10k_fdircmd_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_queue_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_queue_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x8000 & (((e10k_fdircmd_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_rx_queue_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_rx_queue_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x7f0000 & (((e10k_fdircmd_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff80ffff & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

static inline void e10k_fdircmd_pool_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_fdircmd_pool_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_fdircmd_t _regval = 0x3f000000 & (((e10k_fdircmd_t )(_fieldval)) << 24);
    _regval = (_regval | (0xc0ffffff & mackerel_read_addr_32(_dev->base, 0xee2c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xee2c, _regval);
    // No shadow register to write to
}

/*
 * Register pcs1gcfig: PCS_1G Global Config Register 1
 * Type: e10k.pcs1gcfig (Implicit type of PCS_1G Global Config Register 1 register)
 *   _anon0	(size 30, offset 0, init 0):	RSVD	_
 *   pcs_isolate	(size 1, offset 30, init 0):	RW	Isolates the 1 GbE PCS logic from the MAC's data path
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_pcs1gcfig_t e10k_pcs1gcfig_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1gcfig_t e10k_pcs1gcfig_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4200));
}

static inline e10k_pcs1gcfig_t e10k_pcs1gcfig_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1gcfig_t e10k_pcs1gcfig_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4200));
}

static inline void e10k_pcs1gcfig_rawwr(__DN(t) *_dev, e10k_pcs1gcfig_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1gcfig_rawwr(__DN(t) *_dev, e10k_pcs1gcfig_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4200, _regval);
}

static inline void e10k_pcs1gcfig_wr(__DN(t) *_dev, e10k_pcs1gcfig_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1gcfig_wr(__DN(t) *_dev, e10k_pcs1gcfig_t _regval)
{
    _regval = (_regval & 0x40000000);
    // No MB1 fields present
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x4200)));
    mackerel_write_addr_32(_dev->base, 0x4200, _regval);
}

static inline int e10k_pcs1gcfig_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcs1gcfig_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcs1gcfig_t _regval = mackerel_read_addr_32(_dev->base, 0x4200);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcs1gcfig (PCS_1G Global Config Register 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcs_isolate =\t%" PRIx8 "\t(Isolates the 1 GbE PCS logic from the MAC's data path)\n", e10k_pcs1gcfig_pcs_isolate_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t e10k_pcs1gcfig_pcs_isolate_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gcfig_pcs_isolate_rdf(__DN(t) *_dev)
{
    e10k_pcs1gcfig_t _regval = mackerel_read_addr_32(_dev->base, 0x4200);
    return(e10k_pcs1gcfig_pcs_isolate_extract(_regval));
}

static inline void e10k_pcs1gcfig_pcs_isolate_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gcfig_pcs_isolate_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1gcfig_t _regval = 0x40000000 & (((e10k_pcs1gcfig_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x4200)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4200, _regval);
    // No shadow register to write to
}

/*
 * Register pcs1glctl: PCG_1G link Control Register
 * Type: e10k.pcs1glctl (Implicit type of PCG_1G link Control Register register)
 *   flv	(size 1, offset 0, init 0):	RW	Forced Link 1 GbE Value
 *   _anon1	(size 4, offset 1, init 0):	RSVD	_
 *   force1glnk	(size 1, offset 5, init 0):	RW	Force 1 GbE Link
 *   lnk_latchl	(size 1, offset 6, init 0):	RW	Link Latch Low Enable
 *   _anon7	(size 11, offset 7, init 0):	RSVD	_
 *   an_1gto	(size 1, offset 18, init 0):	RW	Auto Negotiation 1 GbE Timeout Enable
 *   _anon19	(size 6, offset 19, init 0):	RSVD	_
 *   lnk_okfixen	(size 1, offset 25, init 0):	RW	Link OK Fix En
 *   _anon26	(size 6, offset 26, init 0):	RSVD	_
 */
static inline e10k_pcs1glctl_t e10k_pcs1glctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1glctl_t e10k_pcs1glctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4208));
}

static inline e10k_pcs1glctl_t e10k_pcs1glctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1glctl_t e10k_pcs1glctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4208));
}

static inline void e10k_pcs1glctl_rawwr(__DN(t) *_dev, e10k_pcs1glctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1glctl_rawwr(__DN(t) *_dev, e10k_pcs1glctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4208, _regval);
}

static inline void e10k_pcs1glctl_wr(__DN(t) *_dev, e10k_pcs1glctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1glctl_wr(__DN(t) *_dev, e10k_pcs1glctl_t _regval)
{
    _regval = (_regval & 0x2040061);
    // No MB1 fields present
    _regval = (_regval | (0xfdfbff9e & mackerel_read_addr_32(_dev->base, 0x4208)));
    mackerel_write_addr_32(_dev->base, 0x4208, _regval);
}

static inline int e10k_pcs1glctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcs1glctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcs1glctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4208);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcs1glctl (PCG_1G link Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flv =\t%" PRIx8 "\t(Forced Link 1 GbE Value)\n", e10k_pcs1glctl_flv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " force1glnk =\t%" PRIx8 "\t(Force 1 GbE Link)\n", e10k_pcs1glctl_force1glnk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_latchl =\t%" PRIx8 "\t(Link Latch Low Enable)\n", e10k_pcs1glctl_lnk_latchl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_1gto =\t%" PRIx8 "\t(Auto Negotiation 1 GbE Timeout Enable)\n", e10k_pcs1glctl_an_1gto_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_okfixen =\t%" PRIx8 "\t(Link OK Fix En)\n", e10k_pcs1glctl_lnk_okfixen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon26 is anonymous
    return(_r);
}

static inline uint8_t e10k_pcs1glctl_flv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_flv_rdf(__DN(t) *_dev)
{
    e10k_pcs1glctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4208);
    return(e10k_pcs1glctl_flv_extract(_regval));
}

static inline uint8_t e10k_pcs1glctl_force1glnk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_force1glnk_rdf(__DN(t) *_dev)
{
    e10k_pcs1glctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4208);
    return(e10k_pcs1glctl_force1glnk_extract(_regval));
}

static inline uint8_t e10k_pcs1glctl_lnk_latchl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_lnk_latchl_rdf(__DN(t) *_dev)
{
    e10k_pcs1glctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4208);
    return(e10k_pcs1glctl_lnk_latchl_extract(_regval));
}

static inline uint8_t e10k_pcs1glctl_an_1gto_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_an_1gto_rdf(__DN(t) *_dev)
{
    e10k_pcs1glctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4208);
    return(e10k_pcs1glctl_an_1gto_extract(_regval));
}

static inline uint8_t e10k_pcs1glctl_lnk_okfixen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glctl_lnk_okfixen_rdf(__DN(t) *_dev)
{
    e10k_pcs1glctl_t _regval = mackerel_read_addr_32(_dev->base, 0x4208);
    return(e10k_pcs1glctl_lnk_okfixen_extract(_regval));
}

static inline void e10k_pcs1glctl_flv_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1glctl_flv_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1glctl_t _regval = 0x1 & (((e10k_pcs1glctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x4208)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4208, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1glctl_force1glnk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1glctl_force1glnk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1glctl_t _regval = 0x20 & (((e10k_pcs1glctl_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x4208)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4208, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1glctl_lnk_latchl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1glctl_lnk_latchl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1glctl_t _regval = 0x40 & (((e10k_pcs1glctl_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x4208)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4208, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1glctl_an_1gto_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1glctl_an_1gto_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1glctl_t _regval = 0x40000 & (((e10k_pcs1glctl_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffbffff & mackerel_read_addr_32(_dev->base, 0x4208)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4208, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1glctl_lnk_okfixen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1glctl_lnk_okfixen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1glctl_t _regval = 0x2000000 & (((e10k_pcs1glctl_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0x4208)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4208, _regval);
    // No shadow register to write to
}

/*
 * Register pcs1glsta: PCS_1G Link Status Register
 * Type: e10k.pcs1glsta (Implicit type of PCS_1G Link Status Register register)
 *   _anon0	(size 4, offset 0, init 0):	RSVD	_
 *   syncok_1g	(size 1, offset 4, init 0):	RO	Sync OK 1 GbE
 *   _anon5	(size 11, offset 5, init 0):	RSVD	_
 *   an_1gcompl	(size 1, offset 16, init 0):	RO	Auto Negotiation1 GbE Complete
 *   an_pagercv	(size 1, offset 17, init 0):	RO	Auto-Negotiation Page Received
 *   an_1gto	(size 1, offset 18, init 0):	RO	Auto Negotiation1 GbE Timed Out
 *   an_remflt	(size 1, offset 19, init 0):	RO	Auto Negotiation Remote Fault
 *   an_error	(size 1, offset 20, init 0):	RW	Auto Negotiation Error
 *   _anon21	(size 11, offset 21, init 0):	RSVD	_
 */
static inline e10k_pcs1glsta_t e10k_pcs1glsta_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1glsta_t e10k_pcs1glsta_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x420c));
}

static inline e10k_pcs1glsta_t e10k_pcs1glsta_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1glsta_t e10k_pcs1glsta_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x420c));
}

static inline void e10k_pcs1glsta_rawwr(__DN(t) *_dev, e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1glsta_rawwr(__DN(t) *_dev, e10k_pcs1glsta_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x420c, _regval);
}

static inline void e10k_pcs1glsta_wr(__DN(t) *_dev, e10k_pcs1glsta_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1glsta_wr(__DN(t) *_dev, e10k_pcs1glsta_t _regval)
{
    _regval = (_regval & 0x1f0010);
    // No MB1 fields present
    _regval = (_regval | (0xffe0ffef & mackerel_read_addr_32(_dev->base, 0x420c)));
    mackerel_write_addr_32(_dev->base, 0x420c, _regval);
}

static inline int e10k_pcs1glsta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcs1glsta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcs1glsta_t _regval = mackerel_read_addr_32(_dev->base, 0x420c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcs1glsta (PCS_1G Link Status Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " syncok_1g =\t%" PRIx8 "\t(Sync OK 1 GbE)\n", e10k_pcs1glsta_syncok_1g_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_1gcompl =\t%" PRIx8 "\t(Auto Negotiation1 GbE Complete)\n", e10k_pcs1glsta_an_1gcompl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_pagercv =\t%" PRIx8 "\t(Auto-Negotiation Page Received)\n", e10k_pcs1glsta_an_pagercv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_1gto =\t%" PRIx8 "\t(Auto Negotiation1 GbE Timed Out)\n", e10k_pcs1glsta_an_1gto_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_remflt =\t%" PRIx8 "\t(Auto Negotiation Remote Fault)\n", e10k_pcs1glsta_an_remflt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " an_error =\t%" PRIx8 "\t(Auto Negotiation Error)\n", e10k_pcs1glsta_an_error_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon21 is anonymous
    return(_r);
}

static inline uint8_t e10k_pcs1glsta_syncok_1g_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_syncok_1g_rdf(__DN(t) *_dev)
{
    e10k_pcs1glsta_t _regval = mackerel_read_addr_32(_dev->base, 0x420c);
    return(e10k_pcs1glsta_syncok_1g_extract(_regval));
}

static inline uint8_t e10k_pcs1glsta_an_1gcompl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_1gcompl_rdf(__DN(t) *_dev)
{
    e10k_pcs1glsta_t _regval = mackerel_read_addr_32(_dev->base, 0x420c);
    return(e10k_pcs1glsta_an_1gcompl_extract(_regval));
}

static inline uint8_t e10k_pcs1glsta_an_pagercv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_pagercv_rdf(__DN(t) *_dev)
{
    e10k_pcs1glsta_t _regval = mackerel_read_addr_32(_dev->base, 0x420c);
    return(e10k_pcs1glsta_an_pagercv_extract(_regval));
}

static inline uint8_t e10k_pcs1glsta_an_1gto_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_1gto_rdf(__DN(t) *_dev)
{
    e10k_pcs1glsta_t _regval = mackerel_read_addr_32(_dev->base, 0x420c);
    return(e10k_pcs1glsta_an_1gto_extract(_regval));
}

static inline uint8_t e10k_pcs1glsta_an_remflt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_remflt_rdf(__DN(t) *_dev)
{
    e10k_pcs1glsta_t _regval = mackerel_read_addr_32(_dev->base, 0x420c);
    return(e10k_pcs1glsta_an_remflt_extract(_regval));
}

static inline uint8_t e10k_pcs1glsta_an_error_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1glsta_an_error_rdf(__DN(t) *_dev)
{
    e10k_pcs1glsta_t _regval = mackerel_read_addr_32(_dev->base, 0x420c);
    return(e10k_pcs1glsta_an_error_extract(_regval));
}

static inline void e10k_pcs1glsta_an_error_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1glsta_an_error_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1glsta_t _regval = 0x100000 & (((e10k_pcs1glsta_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffe0ffef & mackerel_read_addr_32(_dev->base, 0x420c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x420c, _regval);
    // No shadow register to write to
}

/*
 * Register pcs1gana: PCS_1 Gb/s Auto Negotiation Advanced Register
 * Type: e10k.pcs1gana (Implicit type of PCS_1 Gb/s Auto Negotiation Advanced Register register)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   fdc	(size 1, offset 5, init 0):	RW	FD: Full-Duplex
 *   _anon6	(size 1, offset 6, init 0):	RSVD	_
 *   asm	(size 2, offset 7, init 0):	RW	Local PAUSE Capabilities
 *   _anon9	(size 3, offset 9, init 0):	RSVD	_
 *   rflt	(size 2, offset 12, init 0):	RW	Remote Fault
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   nextp	(size 1, offset 15, init 0):	RW	NEXTP: Next Page Capable
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_pcs1gana_t e10k_pcs1gana_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1gana_t e10k_pcs1gana_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4218));
}

static inline e10k_pcs1gana_t e10k_pcs1gana_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1gana_t e10k_pcs1gana_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4218));
}

static inline void e10k_pcs1gana_rawwr(__DN(t) *_dev, e10k_pcs1gana_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1gana_rawwr(__DN(t) *_dev, e10k_pcs1gana_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4218, _regval);
}

static inline void e10k_pcs1gana_wr(__DN(t) *_dev, e10k_pcs1gana_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1gana_wr(__DN(t) *_dev, e10k_pcs1gana_t _regval)
{
    _regval = (_regval & 0xb1a0);
    // No MB1 fields present
    _regval = (_regval | (0xffff4e5f & mackerel_read_addr_32(_dev->base, 0x4218)));
    mackerel_write_addr_32(_dev->base, 0x4218, _regval);
}

static inline int e10k_pcs1gana_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcs1gana_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcs1gana_t _regval = mackerel_read_addr_32(_dev->base, 0x4218);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcs1gana (PCS_1 Gb/s Auto Negotiation Advanced Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fdc =\t%" PRIx8 "\t(FD: Full-Duplex)\n", e10k_pcs1gana_fdc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon6 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " asm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pause_cap_prtval(_s + _r, _avail, e10k_pcs1gana_asm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Local PAUSE Capabilities)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rflt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_remote_fault_prtval(_s + _r, _avail, e10k_pcs1gana_rflt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Remote Fault)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nextp =\t%" PRIx8 "\t(NEXTP: Next Page Capable)\n", e10k_pcs1gana_nextp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e10k_pcs1gana_fdc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gana_fdc_rdf(__DN(t) *_dev)
{
    e10k_pcs1gana_t _regval = mackerel_read_addr_32(_dev->base, 0x4218);
    return(e10k_pcs1gana_fdc_extract(_regval));
}

static inline e10k_pause_cap_t e10k_pcs1gana_asm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pause_cap_t e10k_pcs1gana_asm_rdf(__DN(t) *_dev)
{
    e10k_pcs1gana_t _regval = mackerel_read_addr_32(_dev->base, 0x4218);
    return(e10k_pcs1gana_asm_extract(_regval));
}

static inline e10k_remote_fault_t e10k_pcs1gana_rflt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_remote_fault_t e10k_pcs1gana_rflt_rdf(__DN(t) *_dev)
{
    e10k_pcs1gana_t _regval = mackerel_read_addr_32(_dev->base, 0x4218);
    return(e10k_pcs1gana_rflt_extract(_regval));
}

static inline uint8_t e10k_pcs1gana_nextp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gana_nextp_rdf(__DN(t) *_dev)
{
    e10k_pcs1gana_t _regval = mackerel_read_addr_32(_dev->base, 0x4218);
    return(e10k_pcs1gana_nextp_extract(_regval));
}

static inline void e10k_pcs1gana_fdc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gana_fdc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1gana_t _regval = 0x20 & (((e10k_pcs1gana_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x4218)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4218, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1gana_asm_wrf(__DN(t) *_dev, e10k_pause_cap_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gana_asm_wrf(__DN(t) *_dev, e10k_pause_cap_t _fieldval)
{
    e10k_pcs1gana_t _regval = 0x180 & (((e10k_pcs1gana_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfffffe7f & mackerel_read_addr_32(_dev->base, 0x4218)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4218, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1gana_rflt_wrf(__DN(t) *_dev, e10k_remote_fault_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gana_rflt_wrf(__DN(t) *_dev, e10k_remote_fault_t _fieldval)
{
    e10k_pcs1gana_t _regval = 0x3000 & (((e10k_pcs1gana_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffcfff & mackerel_read_addr_32(_dev->base, 0x4218)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4218, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1gana_nextp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gana_nextp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1gana_t _regval = 0x8000 & (((e10k_pcs1gana_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x4218)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4218, _regval);
    // No shadow register to write to
}

/*
 * Register pcs1ganlp: PCS_1GAN LP Ability Register
 * Type: e10k.pcs1ganlp (Implicit type of PCS_1GAN LP Ability Register register)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   lpfd	(size 1, offset 5, init 0):	RO	LP Full-Duplex (SerDes)
 *   lphd	(size 1, offset 6, init 0):	RO	LP Half-Duplex (SerDes)
 *   lpasm	(size 2, offset 7, init 0):	RO	LP PAUSE capability
 *   _anon9	(size 3, offset 9, init 0):	RSVD	_
 *   prf	(size 2, offset 12, init 0):	RO	LP Remote Fault
 *   ack	(size 1, offset 14, init 0):	RO	LP acknowledged page reception
 *   lpnextp	(size 1, offset 15, init 0):	RO	LP Next Page Capable
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x421c));
}

static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1ganlp_t e10k_pcs1ganlp_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x421c));
}

static inline void e10k_pcs1ganlp_rawwr(__DN(t) *_dev, e10k_pcs1ganlp_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1ganlp_rawwr(__DN(t) *_dev, e10k_pcs1ganlp_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x421c, _regval);
}

// Register pcs1ganlp is not writeable
static inline int e10k_pcs1ganlp_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcs1ganlp_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcs1ganlp_t _regval = mackerel_read_addr_32(_dev->base, 0x421c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcs1ganlp (PCS_1GAN LP Ability Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpfd =\t%" PRIx8 "\t(LP Full-Duplex (SerDes))\n", e10k_pcs1ganlp_lpfd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lphd =\t%" PRIx8 "\t(LP Half-Duplex (SerDes))\n", e10k_pcs1ganlp_lphd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpasm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pause_cap_prtval(_s + _r, _avail, e10k_pcs1ganlp_lpasm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LP PAUSE capability)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon9 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prf =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_remote_fault_prtval(_s + _r, _avail, e10k_pcs1ganlp_prf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(LP Remote Fault)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(LP acknowledged page reception)\n", e10k_pcs1ganlp_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpnextp =\t%" PRIx8 "\t(LP Next Page Capable)\n", e10k_pcs1ganlp_lpnextp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e10k_pcs1ganlp_lpfd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlp_lpfd_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlp_t _regval = mackerel_read_addr_32(_dev->base, 0x421c);
    return(e10k_pcs1ganlp_lpfd_extract(_regval));
}

static inline uint8_t e10k_pcs1ganlp_lphd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlp_lphd_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlp_t _regval = mackerel_read_addr_32(_dev->base, 0x421c);
    return(e10k_pcs1ganlp_lphd_extract(_regval));
}

static inline e10k_pause_cap_t e10k_pcs1ganlp_lpasm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pause_cap_t e10k_pcs1ganlp_lpasm_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlp_t _regval = mackerel_read_addr_32(_dev->base, 0x421c);
    return(e10k_pcs1ganlp_lpasm_extract(_regval));
}

static inline e10k_remote_fault_t e10k_pcs1ganlp_prf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_remote_fault_t e10k_pcs1ganlp_prf_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlp_t _regval = mackerel_read_addr_32(_dev->base, 0x421c);
    return(e10k_pcs1ganlp_prf_extract(_regval));
}

static inline uint8_t e10k_pcs1ganlp_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlp_ack_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlp_t _regval = mackerel_read_addr_32(_dev->base, 0x421c);
    return(e10k_pcs1ganlp_ack_extract(_regval));
}

static inline uint8_t e10k_pcs1ganlp_lpnextp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlp_lpnextp_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlp_t _regval = mackerel_read_addr_32(_dev->base, 0x421c);
    return(e10k_pcs1ganlp_lpnextp_extract(_regval));
}

/*
 * Register pcs1gannp: PCS_1G Auto Negotiation Next Page Transmit Register
 * Type: e10k.pcs1gannp (Implicit type of PCS_1G Auto Negotiation Next Page Transmit Register register)
 *   code	(size 11, offset 0, init 0):	RW	Message/Unformatted Code Field
 *   toggle	(size 1, offset 11, init 0):	RW	Toggle
 *   ack2	(size 1, offset 12, init 0):	RW	Acknowledge2
 *   pgtype	(size 1, offset 13, init 0):	RW	Message/ Unformatted Page
 *   _anon14	(size 1, offset 14, init 0):	RSVD	_
 *   nxtpg	(size 1, offset 15, init 0):	RW	Next Page
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_pcs1gannp_t e10k_pcs1gannp_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1gannp_t e10k_pcs1gannp_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4220));
}

static inline e10k_pcs1gannp_t e10k_pcs1gannp_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1gannp_t e10k_pcs1gannp_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4220));
}

static inline void e10k_pcs1gannp_rawwr(__DN(t) *_dev, e10k_pcs1gannp_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1gannp_rawwr(__DN(t) *_dev, e10k_pcs1gannp_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4220, _regval);
}

static inline void e10k_pcs1gannp_wr(__DN(t) *_dev, e10k_pcs1gannp_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1gannp_wr(__DN(t) *_dev, e10k_pcs1gannp_t _regval)
{
    _regval = (_regval & 0xbfff);
    // No MB1 fields present
    _regval = (_regval | (0xffff4000 & mackerel_read_addr_32(_dev->base, 0x4220)));
    mackerel_write_addr_32(_dev->base, 0x4220, _regval);
}

static inline int e10k_pcs1gannp_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcs1gannp_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcs1gannp_t _regval = mackerel_read_addr_32(_dev->base, 0x4220);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcs1gannp (PCS_1G Auto Negotiation Next Page Transmit Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code =\t%" PRIx16 "\t(Message/Unformatted Code Field)\n", e10k_pcs1gannp_code_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " toggle =\t%" PRIx8 "\t(Toggle)\n", e10k_pcs1gannp_toggle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack2 =\t%" PRIx8 "\t(Acknowledge2)\n", e10k_pcs1gannp_ack2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pgtype =\t%" PRIx8 "\t(Message/ Unformatted Page)\n", e10k_pcs1gannp_pgtype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon14 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nxtpg =\t%" PRIx8 "\t(Next Page)\n", e10k_pcs1gannp_nxtpg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e10k_pcs1gannp_code_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_pcs1gannp_code_rdf(__DN(t) *_dev)
{
    e10k_pcs1gannp_t _regval = mackerel_read_addr_32(_dev->base, 0x4220);
    return(e10k_pcs1gannp_code_extract(_regval));
}

static inline uint8_t e10k_pcs1gannp_toggle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gannp_toggle_rdf(__DN(t) *_dev)
{
    e10k_pcs1gannp_t _regval = mackerel_read_addr_32(_dev->base, 0x4220);
    return(e10k_pcs1gannp_toggle_extract(_regval));
}

static inline uint8_t e10k_pcs1gannp_ack2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gannp_ack2_rdf(__DN(t) *_dev)
{
    e10k_pcs1gannp_t _regval = mackerel_read_addr_32(_dev->base, 0x4220);
    return(e10k_pcs1gannp_ack2_extract(_regval));
}

static inline uint8_t e10k_pcs1gannp_pgtype_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gannp_pgtype_rdf(__DN(t) *_dev)
{
    e10k_pcs1gannp_t _regval = mackerel_read_addr_32(_dev->base, 0x4220);
    return(e10k_pcs1gannp_pgtype_extract(_regval));
}

static inline uint8_t e10k_pcs1gannp_nxtpg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1gannp_nxtpg_rdf(__DN(t) *_dev)
{
    e10k_pcs1gannp_t _regval = mackerel_read_addr_32(_dev->base, 0x4220);
    return(e10k_pcs1gannp_nxtpg_extract(_regval));
}

static inline void e10k_pcs1gannp_code_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gannp_code_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_pcs1gannp_t _regval = 0x7ff & (((e10k_pcs1gannp_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff800 & mackerel_read_addr_32(_dev->base, 0x4220)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4220, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1gannp_toggle_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gannp_toggle_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1gannp_t _regval = 0x800 & (((e10k_pcs1gannp_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x4220)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4220, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1gannp_ack2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gannp_ack2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1gannp_t _regval = 0x1000 & (((e10k_pcs1gannp_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x4220)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4220, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1gannp_pgtype_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gannp_pgtype_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1gannp_t _regval = 0x2000 & (((e10k_pcs1gannp_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x4220)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4220, _regval);
    // No shadow register to write to
}

static inline void e10k_pcs1gannp_nxtpg_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pcs1gannp_nxtpg_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pcs1gannp_t _regval = 0x8000 & (((e10k_pcs1gannp_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x4220)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4220, _regval);
    // No shadow register to write to
}

/*
 * Register pcs1ganlpnp: PCS_1G Auto Negotiation LP's Next Page Register
 * Type: e10k.pcs1ganlpnp (Implicit type of PCS_1G Auto Negotiation LP's Next Page Register register)
 *   code	(size 11, offset 0, init 0):	RO	Message/Unformatted Code Field
 *   toggle	(size 1, offset 11, init 0):	RO	Toggle
 *   ack2	(size 1, offset 12, init 0):	RO	Acknowledge2
 *   msgpg	(size 1, offset 13, init 0):	RO	Message Page
 *   ack	(size 1, offset 14, init 0):	RO	LP has acknowledge next page reception
 *   nxtpg	(size 1, offset 15, init 0):	RO	Next Page
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4224));
}

static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcs1ganlpnp_t e10k_pcs1ganlpnp_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4224));
}

static inline void e10k_pcs1ganlpnp_rawwr(__DN(t) *_dev, e10k_pcs1ganlpnp_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcs1ganlpnp_rawwr(__DN(t) *_dev, e10k_pcs1ganlpnp_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4224, _regval);
}

// Register pcs1ganlpnp is not writeable
static inline int e10k_pcs1ganlpnp_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcs1ganlpnp_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcs1ganlpnp_t _regval = mackerel_read_addr_32(_dev->base, 0x4224);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcs1ganlpnp (PCS_1G Auto Negotiation LP's Next Page Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " code =\t%" PRIx16 "\t(Message/Unformatted Code Field)\n", e10k_pcs1ganlpnp_code_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " toggle =\t%" PRIx8 "\t(Toggle)\n", e10k_pcs1ganlpnp_toggle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack2 =\t%" PRIx8 "\t(Acknowledge2)\n", e10k_pcs1ganlpnp_ack2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msgpg =\t%" PRIx8 "\t(Message Page)\n", e10k_pcs1ganlpnp_msgpg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(LP has acknowledge next page reception)\n", e10k_pcs1ganlpnp_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " nxtpg =\t%" PRIx8 "\t(Next Page)\n", e10k_pcs1ganlpnp_nxtpg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e10k_pcs1ganlpnp_code_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_pcs1ganlpnp_code_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlpnp_t _regval = mackerel_read_addr_32(_dev->base, 0x4224);
    return(e10k_pcs1ganlpnp_code_extract(_regval));
}

static inline uint8_t e10k_pcs1ganlpnp_toggle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_toggle_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlpnp_t _regval = mackerel_read_addr_32(_dev->base, 0x4224);
    return(e10k_pcs1ganlpnp_toggle_extract(_regval));
}

static inline uint8_t e10k_pcs1ganlpnp_ack2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_ack2_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlpnp_t _regval = mackerel_read_addr_32(_dev->base, 0x4224);
    return(e10k_pcs1ganlpnp_ack2_extract(_regval));
}

static inline uint8_t e10k_pcs1ganlpnp_msgpg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_msgpg_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlpnp_t _regval = mackerel_read_addr_32(_dev->base, 0x4224);
    return(e10k_pcs1ganlpnp_msgpg_extract(_regval));
}

static inline uint8_t e10k_pcs1ganlpnp_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_ack_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlpnp_t _regval = mackerel_read_addr_32(_dev->base, 0x4224);
    return(e10k_pcs1ganlpnp_ack_extract(_regval));
}

static inline uint8_t e10k_pcs1ganlpnp_nxtpg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcs1ganlpnp_nxtpg_rdf(__DN(t) *_dev)
{
    e10k_pcs1ganlpnp_t _regval = mackerel_read_addr_32(_dev->base, 0x4224);
    return(e10k_pcs1ganlpnp_nxtpg_extract(_regval));
}

/*
 * Register hlreg0: MAC Core Control 0 Register
 * Type: e10k.hlreg0 (Implicit type of MAC Core Control 0 Register register)
 *   txcrcen	(size 1, offset 0, init 0):	RW	Tx CRC Enable
 *   rxcrcstrp	(size 1, offset 1, init 0):	RW	Rx CRC Strip
 *   jumboen	(size 1, offset 2, init 0):	RW	Jumbo Frame Enable
 *   _anon3	(size 7, offset 3, init 0):	MBZ	_
 *   txpaden	(size 1, offset 10, init 0):	RW	Tx Pad Frame Enable
 *   _anon11	(size 4, offset 11, init 0):	RSVD	_
 *   lpbk	(size 1, offset 15, init 0):	RW	Loopback enabled
 *   mdcspd	(size 1, offset 16, init 0):	RW	MDC SPEED
 *   contmdc	(size 1, offset 17, init 0):	RW	Continuous MDC
 *   _anon18	(size 2, offset 18, init 0):	RSVD	_
 *   prepend	(size 4, offset 20, init 0):	RW	Prepend Value
 *   _anon24	(size 3, offset 24, init 0):	RSVD	_
 *   rxlenerrr	(size 1, offset 27, init 0):	RW	Rx Length Error Reporting
 *   rxpadstrp	(size 1, offset 28, init 0):	RW	Rx Padding Strip Enable
 *   _anon29	(size 3, offset 29, init 0):	RSVD	_
 */
static inline e10k_hlreg0_t e10k_hlreg0_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4240));
}

static inline e10k_hlreg0_t e10k_hlreg0_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_hlreg0_t e10k_hlreg0_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4240));
}

static inline void e10k_hlreg0_rawwr(__DN(t) *_dev, e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_rawwr(__DN(t) *_dev, e10k_hlreg0_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
}

static inline void e10k_hlreg0_wr(__DN(t) *_dev, e10k_hlreg0_t _regval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_wr(__DN(t) *_dev, e10k_hlreg0_t _regval)
{
    _regval = (_regval & 0x18f38407);
    // No MB1 fields present
    _regval = (_regval | (0xe70c7800 & mackerel_read_addr_32(_dev->base, 0x4240)));
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
}

static inline int e10k_hlreg0_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_hlreg0_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hlreg0 (MAC Core Control 0 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txcrcen =\t%" PRIx8 "\t(Tx CRC Enable)\n", e10k_hlreg0_txcrcen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxcrcstrp =\t%" PRIx8 "\t(Rx CRC Strip)\n", e10k_hlreg0_rxcrcstrp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " jumboen =\t%" PRIx8 "\t(Jumbo Frame Enable)\n", e10k_hlreg0_jumboen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txpaden =\t%" PRIx8 "\t(Tx Pad Frame Enable)\n", e10k_hlreg0_txpaden_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpbk =\t%" PRIx8 "\t(Loopback enabled)\n", e10k_hlreg0_lpbk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdcspd =\t%" PRIx8 "\t(MDC SPEED)\n", e10k_hlreg0_mdcspd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " contmdc =\t%" PRIx8 "\t(Continuous MDC)\n", e10k_hlreg0_contmdc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " prepend =\t%" PRIx8 "\t(Prepend Value)\n", e10k_hlreg0_prepend_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon24 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxlenerrr =\t%" PRIx8 "\t(Rx Length Error Reporting)\n", e10k_hlreg0_rxlenerrr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxpadstrp =\t%" PRIx8 "\t(Rx Padding Strip Enable)\n", e10k_hlreg0_rxpadstrp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon29 is anonymous
    return(_r);
}

static inline uint8_t e10k_hlreg0_txcrcen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_txcrcen_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_txcrcen_extract(_regval));
}

static inline uint8_t e10k_hlreg0_rxcrcstrp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_rxcrcstrp_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_rxcrcstrp_extract(_regval));
}

static inline uint8_t e10k_hlreg0_jumboen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_jumboen_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_jumboen_extract(_regval));
}

static inline uint8_t e10k_hlreg0_txpaden_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_txpaden_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_txpaden_extract(_regval));
}

static inline uint8_t e10k_hlreg0_lpbk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_lpbk_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_lpbk_extract(_regval));
}

static inline uint8_t e10k_hlreg0_mdcspd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_mdcspd_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_mdcspd_extract(_regval));
}

static inline uint8_t e10k_hlreg0_contmdc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_contmdc_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_contmdc_extract(_regval));
}

static inline uint8_t e10k_hlreg0_prepend_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_prepend_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_prepend_extract(_regval));
}

static inline uint8_t e10k_hlreg0_rxlenerrr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_rxlenerrr_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_rxlenerrr_extract(_regval));
}

static inline uint8_t e10k_hlreg0_rxpadstrp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg0_rxpadstrp_rdf(__DN(t) *_dev)
{
    e10k_hlreg0_t _regval = mackerel_read_addr_32(_dev->base, 0x4240);
    return(e10k_hlreg0_rxpadstrp_extract(_regval));
}

static inline void e10k_hlreg0_txcrcen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_txcrcen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x1 & (((e10k_hlreg0_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffc06 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_rxcrcstrp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_rxcrcstrp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x2 & (((e10k_hlreg0_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffc05 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_jumboen_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_jumboen_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x4 & (((e10k_hlreg0_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffc03 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_txpaden_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_txpaden_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x400 & (((e10k_hlreg0_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffff807 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_lpbk_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_lpbk_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x8000 & (((e10k_hlreg0_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7c07 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_mdcspd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_mdcspd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x10000 & (((e10k_hlreg0_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffefc07 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_contmdc_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_contmdc_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x20000 & (((e10k_hlreg0_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdfc07 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_prepend_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_prepend_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0xf00000 & (((e10k_hlreg0_t )(_fieldval)) << 20);
    _regval = (_regval | (0xff0ffc07 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_rxlenerrr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_rxlenerrr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x8000000 & (((e10k_hlreg0_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7fffc07 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

static inline void e10k_hlreg0_rxpadstrp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_hlreg0_rxpadstrp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_hlreg0_t _regval = 0x10000000 & (((e10k_hlreg0_t )(_fieldval)) << 28);
    _regval = (_regval | (0xeffffc07 & mackerel_read_addr_32(_dev->base, 0x4240)));
    // No read of register shadow required
    _regval = (_regval & 0xfffffc07);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4240, _regval);
    // No shadow register to write to
}

/*
 * Register hlreg1: MAC Core Status 1 Register
 * Type: e10k.hlreg1 (Implicit type of MAC Core Status 1 Register register)
 *   _anon0	(size 5, offset 0, init 0):	RSVD	_
 *   rxerrsym	(size 1, offset 5, init 0):	RC	Error symbol received
 *   rxillsym	(size 1, offset 6, init 0):	RC	Illegal symbol received
 *   rxidleerr	(size 1, offset 7, init 0):	RC	Idle error received
 *   rxlclflt	(size 1, offset 8, init 0):	RC	Local fault is or was active
 *   rxrmtflt	(size 1, offset 9, init 0):	RC	Remote fault is or was active
 *   _anon10	(size 22, offset 10, init 0):	RSVD	_
 */
static inline e10k_hlreg1_t e10k_hlreg1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_hlreg1_t e10k_hlreg1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4244));
}

static inline e10k_hlreg1_t e10k_hlreg1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_hlreg1_t e10k_hlreg1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4244));
}

static inline void e10k_hlreg1_rawwr(__DN(t) *_dev, e10k_hlreg1_t _regval) __attribute__ ((always_inline));
static inline void e10k_hlreg1_rawwr(__DN(t) *_dev, e10k_hlreg1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4244, _regval);
}

// Register hlreg1 is not writeable
static inline int e10k_hlreg1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_hlreg1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_hlreg1_t _regval = mackerel_read_addr_32(_dev->base, 0x4244);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register hlreg1 (MAC Core Status 1 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxerrsym =\t%" PRIx8 "\t(Error symbol received)\n", e10k_hlreg1_rxerrsym_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxillsym =\t%" PRIx8 "\t(Illegal symbol received)\n", e10k_hlreg1_rxillsym_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxidleerr =\t%" PRIx8 "\t(Idle error received)\n", e10k_hlreg1_rxidleerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxlclflt =\t%" PRIx8 "\t(Local fault is or was active)\n", e10k_hlreg1_rxlclflt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxrmtflt =\t%" PRIx8 "\t(Remote fault is or was active)\n", e10k_hlreg1_rxrmtflt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon10 is anonymous
    return(_r);
}

static inline uint8_t e10k_hlreg1_rxerrsym_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxerrsym_rdf(__DN(t) *_dev)
{
    e10k_hlreg1_t _regval = mackerel_read_addr_32(_dev->base, 0x4244);
    return(e10k_hlreg1_rxerrsym_extract(_regval));
}

static inline uint8_t e10k_hlreg1_rxillsym_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxillsym_rdf(__DN(t) *_dev)
{
    e10k_hlreg1_t _regval = mackerel_read_addr_32(_dev->base, 0x4244);
    return(e10k_hlreg1_rxillsym_extract(_regval));
}

static inline uint8_t e10k_hlreg1_rxidleerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxidleerr_rdf(__DN(t) *_dev)
{
    e10k_hlreg1_t _regval = mackerel_read_addr_32(_dev->base, 0x4244);
    return(e10k_hlreg1_rxidleerr_extract(_regval));
}

static inline uint8_t e10k_hlreg1_rxlclflt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxlclflt_rdf(__DN(t) *_dev)
{
    e10k_hlreg1_t _regval = mackerel_read_addr_32(_dev->base, 0x4244);
    return(e10k_hlreg1_rxlclflt_extract(_regval));
}

static inline uint8_t e10k_hlreg1_rxrmtflt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_hlreg1_rxrmtflt_rdf(__DN(t) *_dev)
{
    e10k_hlreg1_t _regval = mackerel_read_addr_32(_dev->base, 0x4244);
    return(e10k_hlreg1_rxrmtflt_extract(_regval));
}

/*
 * Register pap: Pause and Pace Register
 * Type: e10k.pap (Implicit type of Pause and Pace Register register)
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   pace	(size 4, offset 16, init 0):	RW	Pace
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline e10k_pap_t e10k_pap_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pap_t e10k_pap_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4248));
}

static inline e10k_pap_t e10k_pap_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pap_t e10k_pap_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4248));
}

static inline void e10k_pap_rawwr(__DN(t) *_dev, e10k_pap_t _regval) __attribute__ ((always_inline));
static inline void e10k_pap_rawwr(__DN(t) *_dev, e10k_pap_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4248, _regval);
}

static inline void e10k_pap_wr(__DN(t) *_dev, e10k_pap_t _regval) __attribute__ ((always_inline));
static inline void e10k_pap_wr(__DN(t) *_dev, e10k_pap_t _regval)
{
    _regval = (_regval & 0xf0000);
    // No MB1 fields present
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x4248)));
    mackerel_write_addr_32(_dev->base, 0x4248, _regval);
}

static inline int e10k_pap_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pap_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pap_t _regval = mackerel_read_addr_32(_dev->base, 0x4248);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pap (Pause and Pace Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pace =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pace_prtval(_s + _r, _avail, e10k_pap_pace_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Pace)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline e10k_pace_t e10k_pap_pace_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pace_t e10k_pap_pace_rdf(__DN(t) *_dev)
{
    e10k_pap_t _regval = mackerel_read_addr_32(_dev->base, 0x4248);
    return(e10k_pap_pace_extract(_regval));
}

static inline void e10k_pap_pace_wrf(__DN(t) *_dev, e10k_pace_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pap_pace_wrf(__DN(t) *_dev, e10k_pace_t _fieldval)
{
    e10k_pap_t _regval = 0xf0000 & (((e10k_pap_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x4248)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4248, _regval);
    // No shadow register to write to
}

/*
 * Register msca: MDI Single Command and Address
 * Type: e10k.msca (Implicit type of MDI Single Command and Address register)
 *   mdiadd	(size 16, offset 0, init 0):	RW	MDI Address
 *   devadd	(size 5, offset 16, init 0):	RW	DeviceType/Register Address
 *   phyadd	(size 5, offset 21, init 0):	RW	PHY Address
 *   opcode	(size 2, offset 26, init 0):	RW	OP Code
 *   stcode	(size 2, offset 28, init 0):	RW	ST Code
 *   mdicmd	(size 1, offset 30, init 0):	RW	MDI Command
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_msca_t e10k_msca_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_msca_t e10k_msca_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x425c));
}

static inline e10k_msca_t e10k_msca_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_msca_t e10k_msca_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x425c));
}

static inline void e10k_msca_rawwr(__DN(t) *_dev, e10k_msca_t _regval) __attribute__ ((always_inline));
static inline void e10k_msca_rawwr(__DN(t) *_dev, e10k_msca_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x425c, _regval);
}

static inline void e10k_msca_wr(__DN(t) *_dev, e10k_msca_t _regval) __attribute__ ((always_inline));
static inline void e10k_msca_wr(__DN(t) *_dev, e10k_msca_t _regval)
{
    _regval = (_regval & 0x7fffffff);
    // No MB1 fields present
    _regval = (_regval | (0x80000000 & mackerel_read_addr_32(_dev->base, 0x425c)));
    mackerel_write_addr_32(_dev->base, 0x425c, _regval);
}

static inline int e10k_msca_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_msca_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_msca_t _regval = mackerel_read_addr_32(_dev->base, 0x425c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register msca (MDI Single Command and Address): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdiadd =\t%" PRIx16 "\t(MDI Address)\n", e10k_msca_mdiadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " devadd =\t%" PRIx8 "\t(DeviceType/Register Address)\n", e10k_msca_devadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " phyadd =\t%" PRIx8 "\t(PHY Address)\n", e10k_msca_phyadd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " opcode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mdi_opcode_prtval(_s + _r, _avail, e10k_msca_opcode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(OP Code)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stcode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mdi_stcode_prtval(_s + _r, _avail, e10k_msca_stcode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(ST Code)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdicmd =\t%" PRIx8 "\t(MDI Command)\n", e10k_msca_mdicmd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint16_t e10k_msca_mdiadd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_msca_mdiadd_rdf(__DN(t) *_dev)
{
    e10k_msca_t _regval = mackerel_read_addr_32(_dev->base, 0x425c);
    return(e10k_msca_mdiadd_extract(_regval));
}

static inline uint8_t e10k_msca_devadd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_msca_devadd_rdf(__DN(t) *_dev)
{
    e10k_msca_t _regval = mackerel_read_addr_32(_dev->base, 0x425c);
    return(e10k_msca_devadd_extract(_regval));
}

static inline uint8_t e10k_msca_phyadd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_msca_phyadd_rdf(__DN(t) *_dev)
{
    e10k_msca_t _regval = mackerel_read_addr_32(_dev->base, 0x425c);
    return(e10k_msca_phyadd_extract(_regval));
}

static inline e10k_mdi_opcode_t e10k_msca_opcode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mdi_opcode_t e10k_msca_opcode_rdf(__DN(t) *_dev)
{
    e10k_msca_t _regval = mackerel_read_addr_32(_dev->base, 0x425c);
    return(e10k_msca_opcode_extract(_regval));
}

static inline e10k_mdi_stcode_t e10k_msca_stcode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mdi_stcode_t e10k_msca_stcode_rdf(__DN(t) *_dev)
{
    e10k_msca_t _regval = mackerel_read_addr_32(_dev->base, 0x425c);
    return(e10k_msca_stcode_extract(_regval));
}

static inline uint8_t e10k_msca_mdicmd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_msca_mdicmd_rdf(__DN(t) *_dev)
{
    e10k_msca_t _regval = mackerel_read_addr_32(_dev->base, 0x425c);
    return(e10k_msca_mdicmd_extract(_regval));
}

static inline void e10k_msca_mdiadd_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_msca_mdiadd_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_msca_t _regval = 0xffff & (((e10k_msca_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x425c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x425c, _regval);
    // No shadow register to write to
}

static inline void e10k_msca_devadd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_msca_devadd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_msca_t _regval = 0x1f0000 & (((e10k_msca_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffe0ffff & mackerel_read_addr_32(_dev->base, 0x425c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x425c, _regval);
    // No shadow register to write to
}

static inline void e10k_msca_phyadd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_msca_phyadd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_msca_t _regval = 0x3e00000 & (((e10k_msca_t )(_fieldval)) << 21);
    _regval = (_regval | (0xfc1fffff & mackerel_read_addr_32(_dev->base, 0x425c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x425c, _regval);
    // No shadow register to write to
}

static inline void e10k_msca_opcode_wrf(__DN(t) *_dev, e10k_mdi_opcode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_msca_opcode_wrf(__DN(t) *_dev, e10k_mdi_opcode_t _fieldval)
{
    e10k_msca_t _regval = 0xc000000 & (((e10k_msca_t )(_fieldval)) << 26);
    _regval = (_regval | (0xf3ffffff & mackerel_read_addr_32(_dev->base, 0x425c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x425c, _regval);
    // No shadow register to write to
}

static inline void e10k_msca_stcode_wrf(__DN(t) *_dev, e10k_mdi_stcode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_msca_stcode_wrf(__DN(t) *_dev, e10k_mdi_stcode_t _fieldval)
{
    e10k_msca_t _regval = 0x30000000 & (((e10k_msca_t )(_fieldval)) << 28);
    _regval = (_regval | (0xcfffffff & mackerel_read_addr_32(_dev->base, 0x425c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x425c, _regval);
    // No shadow register to write to
}

static inline void e10k_msca_mdicmd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_msca_mdicmd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_msca_t _regval = 0x40000000 & (((e10k_msca_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x425c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x425c, _regval);
    // No shadow register to write to
}

/*
 * Register msrwd: MDI Single Read and Write Data
 * Type: e10k.msrwd (Implicit type of MDI Single Read and Write Data register)
 *   mdiwrdata	(size 16, offset 0, init 0):	RW	MDI Write Data
 *   mdirddata	(size 16, offset 16, init 0):	RW	MDI Read Data
 */
static inline e10k_msrwd_t e10k_msrwd_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_msrwd_t e10k_msrwd_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4260));
}

static inline e10k_msrwd_t e10k_msrwd_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_msrwd_t e10k_msrwd_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4260));
}

static inline void e10k_msrwd_rawwr(__DN(t) *_dev, e10k_msrwd_t _regval) __attribute__ ((always_inline));
static inline void e10k_msrwd_rawwr(__DN(t) *_dev, e10k_msrwd_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4260, _regval);
}

static inline void e10k_msrwd_wr(__DN(t) *_dev, e10k_msrwd_t _regval) __attribute__ ((always_inline));
static inline void e10k_msrwd_wr(__DN(t) *_dev, e10k_msrwd_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4260, _regval);
}

static inline int e10k_msrwd_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_msrwd_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_msrwd_t _regval = mackerel_read_addr_32(_dev->base, 0x4260);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register msrwd (MDI Single Read and Write Data): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdiwrdata =\t%" PRIx16 "\t(MDI Write Data)\n", e10k_msrwd_mdiwrdata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mdirddata =\t%" PRIx16 "\t(MDI Read Data)\n", e10k_msrwd_mdirddata_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_msrwd_mdiwrdata_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_msrwd_mdiwrdata_rdf(__DN(t) *_dev)
{
    e10k_msrwd_t _regval = mackerel_read_addr_32(_dev->base, 0x4260);
    return(e10k_msrwd_mdiwrdata_extract(_regval));
}

static inline uint16_t e10k_msrwd_mdirddata_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_msrwd_mdirddata_rdf(__DN(t) *_dev)
{
    e10k_msrwd_t _regval = mackerel_read_addr_32(_dev->base, 0x4260);
    return(e10k_msrwd_mdirddata_extract(_regval));
}

static inline void e10k_msrwd_mdiwrdata_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_msrwd_mdiwrdata_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_msrwd_t _regval = 0xffff & (((e10k_msrwd_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x4260)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4260, _regval);
    // No shadow register to write to
}

static inline void e10k_msrwd_mdirddata_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_msrwd_mdirddata_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_msrwd_t _regval = 0xffff0000 & (((e10k_msrwd_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x4260)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4260, _regval);
    // No shadow register to write to
}

/*
 * Register maxfrs: Max Frame Size
 * Type: e10k.maxfrs (Implicit type of Max Frame Size register)
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   mfs	(size 16, offset 16, init 0):	RW	Maximum frame size in bytes units
 */
static inline e10k_maxfrs_t e10k_maxfrs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_maxfrs_t e10k_maxfrs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4268));
}

static inline e10k_maxfrs_t e10k_maxfrs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_maxfrs_t e10k_maxfrs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4268));
}

static inline void e10k_maxfrs_rawwr(__DN(t) *_dev, e10k_maxfrs_t _regval) __attribute__ ((always_inline));
static inline void e10k_maxfrs_rawwr(__DN(t) *_dev, e10k_maxfrs_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4268, _regval);
}

static inline void e10k_maxfrs_wr(__DN(t) *_dev, e10k_maxfrs_t _regval) __attribute__ ((always_inline));
static inline void e10k_maxfrs_wr(__DN(t) *_dev, e10k_maxfrs_t _regval)
{
    _regval = (_regval & 0xffff0000);
    // No MB1 fields present
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x4268)));
    mackerel_write_addr_32(_dev->base, 0x4268, _regval);
}

static inline int e10k_maxfrs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_maxfrs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_maxfrs_t _regval = mackerel_read_addr_32(_dev->base, 0x4268);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register maxfrs (Max Frame Size): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mfs =\t%" PRIx16 "\t(Maximum frame size in bytes units)\n", e10k_maxfrs_mfs_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_maxfrs_mfs_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_maxfrs_mfs_rdf(__DN(t) *_dev)
{
    e10k_maxfrs_t _regval = mackerel_read_addr_32(_dev->base, 0x4268);
    return(e10k_maxfrs_mfs_extract(_regval));
}

static inline void e10k_maxfrs_mfs_wrf(__DN(t) *_dev, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_maxfrs_mfs_wrf(__DN(t) *_dev, uint16_t _fieldval)
{
    e10k_maxfrs_t _regval = 0xffff0000 & (((e10k_maxfrs_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x4268)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4268, _regval);
    // No shadow register to write to
}

/*
 * Register pcss1: XGXS Status 1
 * Type: e10k.pcss1 (Implicit type of XGXS Status 1 register)
 *   _anon0	(size 2, offset 0, init 0):	RSVD	_
 *   pcsrcvlnkup	(size 1, offset 2, init 0):	RO	PCS receive link up
 *   _anon3	(size 4, offset 3, init 0):	RSVD	_
 *   local_fault	(size 1, offset 7, init 0):	RO	LF detected on transmit or receive path
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline e10k_pcss1_t e10k_pcss1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcss1_t e10k_pcss1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4288));
}

static inline e10k_pcss1_t e10k_pcss1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcss1_t e10k_pcss1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4288));
}

static inline void e10k_pcss1_rawwr(__DN(t) *_dev, e10k_pcss1_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcss1_rawwr(__DN(t) *_dev, e10k_pcss1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4288, _regval);
}

// Register pcss1 is not writeable
static inline int e10k_pcss1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcss1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcss1_t _regval = mackerel_read_addr_32(_dev->base, 0x4288);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcss1 (XGXS Status 1): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pcsrcvlnkup =\t%" PRIx8 "\t(PCS receive link up)\n", e10k_pcss1_pcsrcvlnkup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " local_fault =\t%" PRIx8 "\t(LF detected on transmit or receive path)\n", e10k_pcss1_local_fault_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t e10k_pcss1_pcsrcvlnkup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss1_pcsrcvlnkup_rdf(__DN(t) *_dev)
{
    e10k_pcss1_t _regval = mackerel_read_addr_32(_dev->base, 0x4288);
    return(e10k_pcss1_pcsrcvlnkup_extract(_regval));
}

static inline uint8_t e10k_pcss1_local_fault_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss1_local_fault_rdf(__DN(t) *_dev)
{
    e10k_pcss1_t _regval = mackerel_read_addr_32(_dev->base, 0x4288);
    return(e10k_pcss1_local_fault_extract(_regval));
}

/*
 * Register pcss2: XGXS Status 2
 * Type: e10k.pcss2 (Implicit type of XGXS Status 2 register)
 *   c10gbase_r	(size 1, offset 0, init 0):	RO	PCS is able to support 10GBASE-R port type
 *   c10gbase_x	(size 1, offset 1, init 0):	RO	PCS is able to support 10GBASE-X port type
 *   c10gbase_w	(size 1, offset 2, init 0):	RO	PCS is able to support 10GBASE-W port type
 *   _anon3	(size 7, offset 3, init 0):	RSVD	_
 *   rx_lfault	(size 1, offset 10, init 0):	RO	Local fault condition on the receive path
 *   tx_lfault	(size 1, offset 11, init 0):	RO	Local fault condition on the transmit path
 *   _anon12	(size 2, offset 12, init 0):	RSVD	_
 *   dev_present	(size 2, offset 14, init 0):	RO	Device present
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_pcss2_t e10k_pcss2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcss2_t e10k_pcss2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x428c));
}

static inline e10k_pcss2_t e10k_pcss2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pcss2_t e10k_pcss2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x428c));
}

static inline void e10k_pcss2_rawwr(__DN(t) *_dev, e10k_pcss2_t _regval) __attribute__ ((always_inline));
static inline void e10k_pcss2_rawwr(__DN(t) *_dev, e10k_pcss2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x428c, _regval);
}

// Register pcss2 is not writeable
static inline int e10k_pcss2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pcss2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pcss2_t _regval = mackerel_read_addr_32(_dev->base, 0x428c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pcss2 (XGXS Status 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c10gbase_r =\t%" PRIx8 "\t(PCS is able to support 10GBASE-R port type)\n", e10k_pcss2_c10gbase_r_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c10gbase_x =\t%" PRIx8 "\t(PCS is able to support 10GBASE-X port type)\n", e10k_pcss2_c10gbase_x_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " c10gbase_w =\t%" PRIx8 "\t(PCS is able to support 10GBASE-W port type)\n", e10k_pcss2_c10gbase_w_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon3 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_lfault =\t%" PRIx8 "\t(Local fault condition on the receive path)\n", e10k_pcss2_rx_lfault_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_lfault =\t%" PRIx8 "\t(Local fault condition on the transmit path)\n", e10k_pcss2_tx_lfault_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dev_present =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dev_present_prtval(_s + _r, _avail, e10k_pcss2_dev_present_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Device present)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint8_t e10k_pcss2_c10gbase_r_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_c10gbase_r_rdf(__DN(t) *_dev)
{
    e10k_pcss2_t _regval = mackerel_read_addr_32(_dev->base, 0x428c);
    return(e10k_pcss2_c10gbase_r_extract(_regval));
}

static inline uint8_t e10k_pcss2_c10gbase_x_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_c10gbase_x_rdf(__DN(t) *_dev)
{
    e10k_pcss2_t _regval = mackerel_read_addr_32(_dev->base, 0x428c);
    return(e10k_pcss2_c10gbase_x_extract(_regval));
}

static inline uint8_t e10k_pcss2_c10gbase_w_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_c10gbase_w_rdf(__DN(t) *_dev)
{
    e10k_pcss2_t _regval = mackerel_read_addr_32(_dev->base, 0x428c);
    return(e10k_pcss2_c10gbase_w_extract(_regval));
}

static inline uint8_t e10k_pcss2_rx_lfault_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_rx_lfault_rdf(__DN(t) *_dev)
{
    e10k_pcss2_t _regval = mackerel_read_addr_32(_dev->base, 0x428c);
    return(e10k_pcss2_rx_lfault_extract(_regval));
}

static inline uint8_t e10k_pcss2_tx_lfault_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pcss2_tx_lfault_rdf(__DN(t) *_dev)
{
    e10k_pcss2_t _regval = mackerel_read_addr_32(_dev->base, 0x428c);
    return(e10k_pcss2_tx_lfault_extract(_regval));
}

static inline e10k_dev_present_t e10k_pcss2_dev_present_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_dev_present_t e10k_pcss2_dev_present_rdf(__DN(t) *_dev)
{
    e10k_pcss2_t _regval = mackerel_read_addr_32(_dev->base, 0x428c);
    return(e10k_pcss2_dev_present_extract(_regval));
}

/*
 * Register xpcss: 10GBASE-X PCS Status
 * Type: e10k.xpcss (Implicit type of 10GBASE-X PCS Status register)
 *   lane0_sync	(size 1, offset 0, init 0):	RO	Lane 0 is synchronized
 *   lane1_sync	(size 1, offset 1, init 0):	RO	Lane 1 is synchronized
 *   lane2_sync	(size 1, offset 2, init 0):	RO	Lane 2 is synchronized
 *   lane3_sync	(size 1, offset 3, init 0):	RO	Lane 3 is synchronized
 *   _anon4	(size 8, offset 4, init 0):	RSVD	_
 *   align_stat	(size 1, offset 12, init 0):	RO	10GBASE-X PCS receive lanes aligned
 *   _anon13	(size 3, offset 13, init 0):	RSVD	_
 *   deskew_err	(size 1, offset 16, init 0):	RO	De-skew error was detected
 *   algcolcnt4	(size 1, offset 17, init 0):	RO	Align column count has reached four
 *   lane0_invc	(size 1, offset 18, init 0):	RO	Invalid code was detected for that lane
 *   lane1_invc	(size 1, offset 19, init 0):	RO	Invalid code was detected for that lane
 *   lane2_invc	(size 1, offset 20, init 0):	RO	Invalid code was detected for that lane
 *   lane3_invc	(size 1, offset 21, init 0):	RO	Invalid code was detected for that lane
 *   lane0_ccnt4	(size 1, offset 22, init 0):	RO	Comma count for that lane has reached four
 *   lane1_ccnt4	(size 1, offset 23, init 0):	RO	Comma count for that lane has reached four
 *   lane2_ccnt4	(size 1, offset 24, init 0):	RO	Comma count for that lane has reached four
 *   lane3_ccnt4	(size 1, offset 25, init 0):	RO	Comma count for that lane has reached four
 *   lane0_sigd	(size 1, offset 26, init 0):	RO	Signal is detected
 *   lane1_sigd	(size 1, offset 27, init 0):	RO	Signal is detected
 *   lane2_sigd	(size 1, offset 28, init 0):	RO	Signal is detected
 *   lane3_sigd	(size 1, offset 29, init 0):	RO	Signal is detected
 *   _anon30	(size 2, offset 30, init 0):	RSVD	_
 */
static inline e10k_xpcss_t e10k_xpcss_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4290));
}

static inline e10k_xpcss_t e10k_xpcss_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_xpcss_t e10k_xpcss_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4290));
}

static inline void e10k_xpcss_rawwr(__DN(t) *_dev, e10k_xpcss_t _regval) __attribute__ ((always_inline));
static inline void e10k_xpcss_rawwr(__DN(t) *_dev, e10k_xpcss_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4290, _regval);
}

// Register xpcss is not writeable
static inline int e10k_xpcss_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_xpcss_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register xpcss (10GBASE-X PCS Status): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane0_sync =\t%" PRIx8 "\t(Lane 0 is synchronized)\n", e10k_xpcss_lane0_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane1_sync =\t%" PRIx8 "\t(Lane 1 is synchronized)\n", e10k_xpcss_lane1_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane2_sync =\t%" PRIx8 "\t(Lane 2 is synchronized)\n", e10k_xpcss_lane2_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane3_sync =\t%" PRIx8 "\t(Lane 3 is synchronized)\n", e10k_xpcss_lane3_sync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " align_stat =\t%" PRIx8 "\t(10GBASE-X PCS receive lanes aligned)\n", e10k_xpcss_align_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " deskew_err =\t%" PRIx8 "\t(De-skew error was detected)\n", e10k_xpcss_deskew_err_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " algcolcnt4 =\t%" PRIx8 "\t(Align column count has reached four)\n", e10k_xpcss_algcolcnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane0_invc =\t%" PRIx8 "\t(Invalid code was detected for that lane)\n", e10k_xpcss_lane0_invc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane1_invc =\t%" PRIx8 "\t(Invalid code was detected for that lane)\n", e10k_xpcss_lane1_invc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane2_invc =\t%" PRIx8 "\t(Invalid code was detected for that lane)\n", e10k_xpcss_lane2_invc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane3_invc =\t%" PRIx8 "\t(Invalid code was detected for that lane)\n", e10k_xpcss_lane3_invc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane0_ccnt4 =\t%" PRIx8 "\t(Comma count for that lane has reached four)\n", e10k_xpcss_lane0_ccnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane1_ccnt4 =\t%" PRIx8 "\t(Comma count for that lane has reached four)\n", e10k_xpcss_lane1_ccnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane2_ccnt4 =\t%" PRIx8 "\t(Comma count for that lane has reached four)\n", e10k_xpcss_lane2_ccnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane3_ccnt4 =\t%" PRIx8 "\t(Comma count for that lane has reached four)\n", e10k_xpcss_lane3_ccnt4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane0_sigd =\t%" PRIx8 "\t(Signal is detected)\n", e10k_xpcss_lane0_sigd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane1_sigd =\t%" PRIx8 "\t(Signal is detected)\n", e10k_xpcss_lane1_sigd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane2_sigd =\t%" PRIx8 "\t(Signal is detected)\n", e10k_xpcss_lane2_sigd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lane3_sigd =\t%" PRIx8 "\t(Signal is detected)\n", e10k_xpcss_lane3_sigd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon30 is anonymous
    return(_r);
}

static inline uint8_t e10k_xpcss_lane0_sync_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane0_sync_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane0_sync_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane1_sync_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane1_sync_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane1_sync_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane2_sync_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane2_sync_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane2_sync_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane3_sync_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane3_sync_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane3_sync_extract(_regval));
}

static inline uint8_t e10k_xpcss_align_stat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_align_stat_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_align_stat_extract(_regval));
}

static inline uint8_t e10k_xpcss_deskew_err_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_deskew_err_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_deskew_err_extract(_regval));
}

static inline uint8_t e10k_xpcss_algcolcnt4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_algcolcnt4_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_algcolcnt4_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane0_invc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane0_invc_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane0_invc_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane1_invc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane1_invc_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane1_invc_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane2_invc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane2_invc_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane2_invc_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane3_invc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane3_invc_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane3_invc_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane0_ccnt4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane0_ccnt4_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane0_ccnt4_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane1_ccnt4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane1_ccnt4_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane1_ccnt4_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane2_ccnt4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane2_ccnt4_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane2_ccnt4_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane3_ccnt4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane3_ccnt4_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane3_ccnt4_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane0_sigd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane0_sigd_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane0_sigd_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane1_sigd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane1_sigd_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane1_sigd_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane2_sigd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane2_sigd_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane2_sigd_extract(_regval));
}

static inline uint8_t e10k_xpcss_lane3_sigd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_xpcss_lane3_sigd_rdf(__DN(t) *_dev)
{
    e10k_xpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x4290);
    return(e10k_xpcss_lane3_sigd_extract(_regval));
}

/*
 * Register serdesc: SerDes Interface Control Register
 * Type: e10k.serdesc (Implicit type of SerDes Interface Control Register register)
 *   txl0_pol	(size 1, offset 0, init 0):	RW	Changes bits polarity of MAC Tx lane 0
 *   txl1_pol	(size 1, offset 1, init 0):	RW	Changes bits polarity of MAC Tx lane 1
 *   txl2_pol	(size 1, offset 2, init 0):	RW	Changes bits polarity of MAC Tx lane 2
 *   txl3_pol	(size 1, offset 3, init 0):	RW	Changes bits polarity of MAC Tx lane 3
 *   rxl0_pol	(size 1, offset 4, init 0):	RW	Changes bits polarity of MAC Rx lane 0
 *   rxl1_pol	(size 1, offset 5, init 0):	RW	Changes bits polarity of MAC Rx lane 1
 *   rxl2_pol	(size 1, offset 6, init 0):	RW	Changes bits polarity of MAC Rx lane 2
 *   rxl3_pol	(size 1, offset 7, init 0):	RW	Changes bits polarity of MAC Rx lane 3
 *   txl0_swiz	(size 1, offset 8, init 0):	RW	Swizzles bits of MAC Tx lane 0
 *   txl1_swiz	(size 1, offset 9, init 0):	RW	Swizzles bits of MAC Tx lane 1
 *   txl2_swiz	(size 1, offset 10, init 0):	RW	Swizzles bits of MAC Tx lane 2
 *   txl3_swiz	(size 1, offset 11, init 0):	RW	Swizzles bits of MAC Tx lane 3
 *   rxl0_swiz	(size 1, offset 12, init 0):	RW	Swizzles bits of MAC Rx lane 0
 *   rxl1_swiz	(size 1, offset 13, init 0):	RW	Swizzles bits of MAC Rx lane 1
 *   rxl2_swiz	(size 1, offset 14, init 0):	RW	Swizzles bits of MAC Rx lane 2
 *   rxl3_swiz	(size 1, offset 15, init 0):	RW	Swizzles bits of MAC Rx lane 3
 *   txl3_swap	(size 2, offset 16, init 0):	RW	Determines Core destination Tx lane for MAC Tx lane 3
 *   txl2_swap	(size 2, offset 18, init 0):	RW	Determines Core destination Tx lane for MAC Tx lane 2
 *   txl1_swap	(size 2, offset 20, init 0):	RW	Determines Core destination Tx lane for MAC Tx lane 1
 *   txl0_swap	(size 2, offset 22, init 0):	RW	Determines Core destination Tx lane for MAC Tx lane 0
 *   rxl3_swap	(size 2, offset 24, init 0):	RW	Determines which Core lane is mapped to MAC Rx lane 3
 *   rxl2_swap	(size 2, offset 26, init 0):	RW	Determines which Core lane is mapped to MAC Rx lane 2
 *   rxl1_swap	(size 2, offset 28, init 0):	RW	Determines which Core lane is mapped to MAC Rx lane 1
 *   rxl0_swap	(size 2, offset 30, init 0):	RW	Determines which Core lane is mapped to MAC Rx lane 0
 */
static inline e10k_serdesc_t e10k_serdesc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4298));
}

static inline e10k_serdesc_t e10k_serdesc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_serdesc_t e10k_serdesc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4298));
}

static inline void e10k_serdesc_rawwr(__DN(t) *_dev, e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rawwr(__DN(t) *_dev, e10k_serdesc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
}

static inline void e10k_serdesc_wr(__DN(t) *_dev, e10k_serdesc_t _regval) __attribute__ ((always_inline));
static inline void e10k_serdesc_wr(__DN(t) *_dev, e10k_serdesc_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
}

static inline int e10k_serdesc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_serdesc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register serdesc (SerDes Interface Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl0_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Tx lane 0)\n", e10k_serdesc_txl0_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl1_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Tx lane 1)\n", e10k_serdesc_txl1_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl2_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Tx lane 2)\n", e10k_serdesc_txl2_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl3_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Tx lane 3)\n", e10k_serdesc_txl3_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl0_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Rx lane 0)\n", e10k_serdesc_rxl0_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl1_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Rx lane 1)\n", e10k_serdesc_rxl1_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl2_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Rx lane 2)\n", e10k_serdesc_rxl2_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl3_pol =\t%" PRIx8 "\t(Changes bits polarity of MAC Rx lane 3)\n", e10k_serdesc_rxl3_pol_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl0_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Tx lane 0)\n", e10k_serdesc_txl0_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl1_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Tx lane 1)\n", e10k_serdesc_txl1_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl2_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Tx lane 2)\n", e10k_serdesc_txl2_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl3_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Tx lane 3)\n", e10k_serdesc_txl3_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl0_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Rx lane 0)\n", e10k_serdesc_rxl0_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl1_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Rx lane 1)\n", e10k_serdesc_rxl1_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl2_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Rx lane 2)\n", e10k_serdesc_rxl2_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl3_swiz =\t%" PRIx8 "\t(Swizzles bits of MAC Rx lane 3)\n", e10k_serdesc_rxl3_swiz_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl3_swap =\t%" PRIx8 "\t(Determines Core destination Tx lane for MAC Tx lane 3)\n", e10k_serdesc_txl3_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl2_swap =\t%" PRIx8 "\t(Determines Core destination Tx lane for MAC Tx lane 2)\n", e10k_serdesc_txl2_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl1_swap =\t%" PRIx8 "\t(Determines Core destination Tx lane for MAC Tx lane 1)\n", e10k_serdesc_txl1_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txl0_swap =\t%" PRIx8 "\t(Determines Core destination Tx lane for MAC Tx lane 0)\n", e10k_serdesc_txl0_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl3_swap =\t%" PRIx8 "\t(Determines which Core lane is mapped to MAC Rx lane 3)\n", e10k_serdesc_rxl3_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl2_swap =\t%" PRIx8 "\t(Determines which Core lane is mapped to MAC Rx lane 2)\n", e10k_serdesc_rxl2_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl1_swap =\t%" PRIx8 "\t(Determines which Core lane is mapped to MAC Rx lane 1)\n", e10k_serdesc_rxl1_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxl0_swap =\t%" PRIx8 "\t(Determines which Core lane is mapped to MAC Rx lane 0)\n", e10k_serdesc_rxl0_swap_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_serdesc_txl0_pol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl0_pol_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl0_pol_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl1_pol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl1_pol_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl1_pol_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl2_pol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl2_pol_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl2_pol_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl3_pol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl3_pol_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl3_pol_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl0_pol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl0_pol_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl0_pol_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl1_pol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl1_pol_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl1_pol_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl2_pol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl2_pol_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl2_pol_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl3_pol_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl3_pol_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl3_pol_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl0_swiz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl0_swiz_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl0_swiz_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl1_swiz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl1_swiz_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl1_swiz_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl2_swiz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl2_swiz_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl2_swiz_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl3_swiz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl3_swiz_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl3_swiz_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl0_swiz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl0_swiz_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl0_swiz_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl1_swiz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl1_swiz_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl1_swiz_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl2_swiz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl2_swiz_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl2_swiz_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl3_swiz_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl3_swiz_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl3_swiz_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl3_swap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl3_swap_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl3_swap_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl2_swap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl2_swap_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl2_swap_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl1_swap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl1_swap_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl1_swap_extract(_regval));
}

static inline uint8_t e10k_serdesc_txl0_swap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_txl0_swap_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_txl0_swap_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl3_swap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl3_swap_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl3_swap_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl2_swap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl2_swap_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl2_swap_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl1_swap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl1_swap_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl1_swap_extract(_regval));
}

static inline uint8_t e10k_serdesc_rxl0_swap_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_serdesc_rxl0_swap_rdf(__DN(t) *_dev)
{
    e10k_serdesc_t _regval = mackerel_read_addr_32(_dev->base, 0x4298);
    return(e10k_serdesc_rxl0_swap_extract(_regval));
}

static inline void e10k_serdesc_txl0_pol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl0_pol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x1 & (((e10k_serdesc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl1_pol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl1_pol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x2 & (((e10k_serdesc_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl2_pol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl2_pol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x4 & (((e10k_serdesc_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl3_pol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl3_pol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x8 & (((e10k_serdesc_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl0_pol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl0_pol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x10 & (((e10k_serdesc_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffffef & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl1_pol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl1_pol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x20 & (((e10k_serdesc_t )(_fieldval)) << 5);
    _regval = (_regval | (0xffffffdf & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl2_pol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl2_pol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x40 & (((e10k_serdesc_t )(_fieldval)) << 6);
    _regval = (_regval | (0xffffffbf & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl3_pol_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl3_pol_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x80 & (((e10k_serdesc_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffff7f & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl0_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl0_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x100 & (((e10k_serdesc_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffffeff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl1_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl1_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x200 & (((e10k_serdesc_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl2_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl2_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x400 & (((e10k_serdesc_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl3_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl3_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x800 & (((e10k_serdesc_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl0_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl0_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x1000 & (((e10k_serdesc_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl1_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl1_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x2000 & (((e10k_serdesc_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl2_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl2_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x4000 & (((e10k_serdesc_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl3_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl3_swiz_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x8000 & (((e10k_serdesc_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl3_swap_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl3_swap_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x30000 & (((e10k_serdesc_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffcffff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl2_swap_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl2_swap_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0xc0000 & (((e10k_serdesc_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfff3ffff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl1_swap_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl1_swap_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x300000 & (((e10k_serdesc_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffcfffff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_txl0_swap_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_txl0_swap_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0xc00000 & (((e10k_serdesc_t )(_fieldval)) << 22);
    _regval = (_regval | (0xff3fffff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl3_swap_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl3_swap_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x3000000 & (((e10k_serdesc_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfcffffff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl2_swap_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl2_swap_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0xc000000 & (((e10k_serdesc_t )(_fieldval)) << 26);
    _regval = (_regval | (0xf3ffffff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl1_swap_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl1_swap_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0x30000000 & (((e10k_serdesc_t )(_fieldval)) << 28);
    _regval = (_regval | (0xcfffffff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

static inline void e10k_serdesc_rxl0_swap_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_serdesc_rxl0_swap_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_serdesc_t _regval = 0xc0000000 & (((e10k_serdesc_t )(_fieldval)) << 30);
    _regval = (_regval | (0x3fffffff & mackerel_read_addr_32(_dev->base, 0x4298)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4298, _regval);
    // No shadow register to write to
}

/*
 * Register macs: FIFO Status/CNTL Report Register
 * Type: e10k.macs (Implicit type of FIFO Status/CNTL Report Register register)
 *   xgssf_dis	(size 1, offset 0, init 0):	RW	Use shift-fsm control, disable fix
 *   xgtxe_dis	(size 1, offset 1, init 0):	RW	Disable tx_end on link-down
 *   xgsdsf_dis	(size 1, offset 2, init 0):	RW	Disable align on invalid fix
 *   noncem_dis	(size 1, offset 3, init 0):	RW	Disable nonce match
 *   _anon4	(size 12, offset 4, init 0):	RSVD	_
 *   cfgflt_len	(size 8, offset 16, init 0):	RW	Config fault length
 *   cfgfifothr	(size 4, offset 24, init 0):	RW	Config FIFO threshold
 *   txfifo_ur	(size 1, offset 28, init 0):	RW	FIFO under run in xgmii_mux_tx_fifo
 *   txfifo_or	(size 1, offset 29, init 0):	RW	FIFO overrun in xgmii_mux_tx_fifo
 *   rxfifo_ur	(size 1, offset 30, init 0):	RW	FIFO under run in xgmii_mux_rx_fifo
 *   rxfifo_or	(size 1, offset 31, init 0):	RW	FIFO overrun in xgmii_mux_rx_fifo
 */
static inline e10k_macs_t e10k_macs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x429c));
}

static inline e10k_macs_t e10k_macs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_macs_t e10k_macs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x429c));
}

static inline void e10k_macs_rawwr(__DN(t) *_dev, e10k_macs_t _regval) __attribute__ ((always_inline));
static inline void e10k_macs_rawwr(__DN(t) *_dev, e10k_macs_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
}

static inline void e10k_macs_wr(__DN(t) *_dev, e10k_macs_t _regval) __attribute__ ((always_inline));
static inline void e10k_macs_wr(__DN(t) *_dev, e10k_macs_t _regval)
{
    _regval = (_regval & 0xffff000f);
    // No MB1 fields present
    _regval = (_regval | (0xfff0 & mackerel_read_addr_32(_dev->base, 0x429c)));
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
}

static inline int e10k_macs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_macs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register macs (FIFO Status/CNTL Report Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xgssf_dis =\t%" PRIx8 "\t(Use shift-fsm control, disable fix)\n", e10k_macs_xgssf_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xgtxe_dis =\t%" PRIx8 "\t(Disable tx_end on link-down)\n", e10k_macs_xgtxe_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " xgsdsf_dis =\t%" PRIx8 "\t(Disable align on invalid fix)\n", e10k_macs_xgsdsf_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " noncem_dis =\t%" PRIx8 "\t(Disable nonce match)\n", e10k_macs_noncem_dis_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfgflt_len =\t%" PRIx8 "\t(Config fault length)\n", e10k_macs_cfgflt_len_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " cfgfifothr =\t%" PRIx8 "\t(Config FIFO threshold)\n", e10k_macs_cfgfifothr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfifo_ur =\t%" PRIx8 "\t(FIFO under run in xgmii_mux_tx_fifo)\n", e10k_macs_txfifo_ur_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " txfifo_or =\t%" PRIx8 "\t(FIFO overrun in xgmii_mux_tx_fifo)\n", e10k_macs_txfifo_or_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_ur =\t%" PRIx8 "\t(FIFO under run in xgmii_mux_rx_fifo)\n", e10k_macs_rxfifo_ur_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_or =\t%" PRIx8 "\t(FIFO overrun in xgmii_mux_rx_fifo)\n", e10k_macs_rxfifo_or_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_macs_xgssf_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_xgssf_dis_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_xgssf_dis_extract(_regval));
}

static inline uint8_t e10k_macs_xgtxe_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_xgtxe_dis_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_xgtxe_dis_extract(_regval));
}

static inline uint8_t e10k_macs_xgsdsf_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_xgsdsf_dis_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_xgsdsf_dis_extract(_regval));
}

static inline uint8_t e10k_macs_noncem_dis_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_noncem_dis_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_noncem_dis_extract(_regval));
}

static inline uint8_t e10k_macs_cfgflt_len_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_cfgflt_len_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_cfgflt_len_extract(_regval));
}

static inline uint8_t e10k_macs_cfgfifothr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_cfgfifothr_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_cfgfifothr_extract(_regval));
}

static inline uint8_t e10k_macs_txfifo_ur_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_txfifo_ur_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_txfifo_ur_extract(_regval));
}

static inline uint8_t e10k_macs_txfifo_or_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_txfifo_or_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_txfifo_or_extract(_regval));
}

static inline uint8_t e10k_macs_rxfifo_ur_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_rxfifo_ur_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_rxfifo_ur_extract(_regval));
}

static inline uint8_t e10k_macs_rxfifo_or_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_macs_rxfifo_or_rdf(__DN(t) *_dev)
{
    e10k_macs_t _regval = mackerel_read_addr_32(_dev->base, 0x429c);
    return(e10k_macs_rxfifo_or_extract(_regval));
}

static inline void e10k_macs_xgssf_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_xgssf_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0x1 & (((e10k_macs_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_xgtxe_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_xgtxe_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0x2 & (((e10k_macs_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_xgsdsf_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_xgsdsf_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0x4 & (((e10k_macs_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_noncem_dis_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_noncem_dis_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0x8 & (((e10k_macs_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_cfgflt_len_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_cfgflt_len_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0xff0000 & (((e10k_macs_t )(_fieldval)) << 16);
    _regval = (_regval | (0xff00ffff & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_cfgfifothr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_cfgfifothr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0xf000000 & (((e10k_macs_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf0ffffff & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_txfifo_ur_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_txfifo_ur_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0x10000000 & (((e10k_macs_t )(_fieldval)) << 28);
    _regval = (_regval | (0xefffffff & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_txfifo_or_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_txfifo_or_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0x20000000 & (((e10k_macs_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_rxfifo_ur_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_rxfifo_ur_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0x40000000 & (((e10k_macs_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

static inline void e10k_macs_rxfifo_or_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_macs_rxfifo_or_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_macs_t _regval = 0x80000000 & (((e10k_macs_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x429c)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x429c, _regval);
    // No shadow register to write to
}

/*
 * Register autoc: Auto Negotiation Control Register
 * Type: e10k.autoc (Implicit type of Auto Negotiation Control Register register)
 *   flu	(size 1, offset 0, init 0):	RW	Force Link Up
 *   anack2	(size 1, offset 1, init 0):	RW	Auto-Negotiation Ack2 field
 *   ansf	(size 5, offset 2, init 0):	RW	Auto-Negotiation Selector Field
 *   pmad_10gbe	(size 2, offset 7, init 0):	RW	10 GbE PMA/PMD over four differential pairs
 *   pmad_1gbe	(size 1, offset 9, init 0):	RW	PMA/PMD used for 1 GbE
 *   d10gmp	(size 1, offset 10, init 0):	RW	Disables 10 GbE (KX4) on Dx (Dr/D3) without main-power
 *   ratd	(size 1, offset 11, init 0):	RW	Restarts auto-negotiation on transition to Dx
 *   restart_an	(size 1, offset 12, init 0):	RW	Applies new link settings and restarts relative auto-negotiation
 *   lms	(size 3, offset 13, init 0):	RW	Link Mode Select
 *   kr_sup	(size 1, offset 16, init 0):	RW	KR supported
 *   fecr	(size 1, offset 17, init 0):	RW	FEC requested from link partner
 *   feca	(size 1, offset 18, init 0):	RW	FEC supported
 *   anrxat	(size 4, offset 19, init 0):	RW	Backplane Auto-Negotiation Rx Align Threshold
 *   anrxdm	(size 1, offset 23, init 0):	RW	Auto-Negotiation Rx Drift Mode
 *   anrxlm	(size 1, offset 24, init 0):	RW	Auto-Negotiation Rx Loose Mode
 *   anpdt	(size 2, offset 25, init 0):	RW	Auto-Negotiation Parallel Detect Timer
 *   rf	(size 1, offset 27, init 0):	RW	Loaded to the RF of the auto-negotiation word
 *   pb	(size 2, offset 28, init 0):	RW	Loaded to bits D11-D10 of the Link code word
 *   kx_sup	(size 1, offset 30, init 0):	RW	KX supported
 *   kx4sup	(size 1, offset 31, init 0):	RW	KX4 supported
 */
static inline e10k_autoc_t e10k_autoc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42a0));
}

static inline e10k_autoc_t e10k_autoc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_autoc_t e10k_autoc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42a0));
}

static inline void e10k_autoc_rawwr(__DN(t) *_dev, e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline void e10k_autoc_rawwr(__DN(t) *_dev, e10k_autoc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
}

static inline void e10k_autoc_wr(__DN(t) *_dev, e10k_autoc_t _regval) __attribute__ ((always_inline));
static inline void e10k_autoc_wr(__DN(t) *_dev, e10k_autoc_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
}

static inline int e10k_autoc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_autoc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register autoc (Auto Negotiation Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " flu =\t%" PRIx8 "\t(Force Link Up)\n", e10k_autoc_flu_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anack2 =\t%" PRIx8 "\t(Auto-Negotiation Ack2 field)\n", e10k_autoc_anack2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ansf =\t%" PRIx8 "\t(Auto-Negotiation Selector Field)\n", e10k_autoc_ansf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmad_10gbe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pmad_10gbe_prtval(_s + _r, _avail, e10k_autoc_pmad_10gbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(10 GbE PMA/PMD over four differential pairs)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmad_1gbe =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pmad_1gbe_prtval(_s + _r, _avail, e10k_autoc_pmad_1gbe_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PMA/PMD used for 1 GbE)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " d10gmp =\t%" PRIx8 "\t(Disables 10 GbE (KX4) on Dx (Dr/D3) without main-power)\n", e10k_autoc_d10gmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ratd =\t%" PRIx8 "\t(Restarts auto-negotiation on transition to Dx)\n", e10k_autoc_ratd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " restart_an =\t%" PRIx8 "\t(Applies new link settings and restarts relative auto-negotiation)\n", e10k_autoc_restart_an_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lms =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_link_mode_prtval(_s + _r, _avail, e10k_autoc_lms_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Link Mode Select)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kr_sup =\t%" PRIx8 "\t(KR supported)\n", e10k_autoc_kr_sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecr =\t%" PRIx8 "\t(FEC requested from link partner)\n", e10k_autoc_fecr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " feca =\t%" PRIx8 "\t(FEC supported)\n", e10k_autoc_feca_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anrxat =\t%" PRIx8 "\t(Backplane Auto-Negotiation Rx Align Threshold)\n", e10k_autoc_anrxat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anrxdm =\t%" PRIx8 "\t(Auto-Negotiation Rx Drift Mode)\n", e10k_autoc_anrxdm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anrxlm =\t%" PRIx8 "\t(Auto-Negotiation Rx Loose Mode)\n", e10k_autoc_anrxlm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anpdt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_aneg_pdt_prtval(_s + _r, _avail, e10k_autoc_anpdt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Auto-Negotiation Parallel Detect Timer)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rf =\t%" PRIx8 "\t(Loaded to the RF of the auto-negotiation word)\n", e10k_autoc_rf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pb =\t%" PRIx8 "\t(Loaded to bits D11-D10 of the Link code word)\n", e10k_autoc_pb_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kx_sup =\t%" PRIx8 "\t(KX supported)\n", e10k_autoc_kx_sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kx4sup =\t%" PRIx8 "\t(KX4 supported)\n", e10k_autoc_kx4sup_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_autoc_flu_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_flu_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_flu_extract(_regval));
}

static inline uint8_t e10k_autoc_anack2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_anack2_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_anack2_extract(_regval));
}

static inline uint8_t e10k_autoc_ansf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_ansf_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_ansf_extract(_regval));
}

static inline e10k_pmad_10gbe_t e10k_autoc_pmad_10gbe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pmad_10gbe_t e10k_autoc_pmad_10gbe_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_pmad_10gbe_extract(_regval));
}

static inline e10k_pmad_1gbe_t e10k_autoc_pmad_1gbe_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pmad_1gbe_t e10k_autoc_pmad_1gbe_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_pmad_1gbe_extract(_regval));
}

static inline uint8_t e10k_autoc_d10gmp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_d10gmp_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_d10gmp_extract(_regval));
}

static inline uint8_t e10k_autoc_ratd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_ratd_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_ratd_extract(_regval));
}

static inline uint8_t e10k_autoc_restart_an_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_restart_an_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_restart_an_extract(_regval));
}

static inline e10k_link_mode_t e10k_autoc_lms_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_link_mode_t e10k_autoc_lms_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_lms_extract(_regval));
}

static inline uint8_t e10k_autoc_kr_sup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_kr_sup_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_kr_sup_extract(_regval));
}

static inline uint8_t e10k_autoc_fecr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_fecr_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_fecr_extract(_regval));
}

static inline uint8_t e10k_autoc_feca_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_feca_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_feca_extract(_regval));
}

static inline uint8_t e10k_autoc_anrxat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_anrxat_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_anrxat_extract(_regval));
}

static inline uint8_t e10k_autoc_anrxdm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_anrxdm_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_anrxdm_extract(_regval));
}

static inline uint8_t e10k_autoc_anrxlm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_anrxlm_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_anrxlm_extract(_regval));
}

static inline e10k_aneg_pdt_t e10k_autoc_anpdt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_aneg_pdt_t e10k_autoc_anpdt_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_anpdt_extract(_regval));
}

static inline uint8_t e10k_autoc_rf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_rf_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_rf_extract(_regval));
}

static inline uint8_t e10k_autoc_pb_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_pb_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_pb_extract(_regval));
}

static inline uint8_t e10k_autoc_kx_sup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_kx_sup_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_kx_sup_extract(_regval));
}

static inline uint8_t e10k_autoc_kx4sup_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc_kx4sup_rdf(__DN(t) *_dev)
{
    e10k_autoc_t _regval = mackerel_read_addr_32(_dev->base, 0x42a0);
    return(e10k_autoc_kx4sup_extract(_regval));
}

static inline void e10k_autoc_flu_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_flu_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x1 & (((e10k_autoc_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_anack2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_anack2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x2 & (((e10k_autoc_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_ansf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_ansf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x7c & (((e10k_autoc_t )(_fieldval)) << 2);
    _regval = (_regval | (0xffffff83 & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_pmad_10gbe_wrf(__DN(t) *_dev, e10k_pmad_10gbe_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_pmad_10gbe_wrf(__DN(t) *_dev, e10k_pmad_10gbe_t _fieldval)
{
    e10k_autoc_t _regval = 0x180 & (((e10k_autoc_t )(_fieldval)) << 7);
    _regval = (_regval | (0xfffffe7f & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_pmad_1gbe_wrf(__DN(t) *_dev, e10k_pmad_1gbe_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_pmad_1gbe_wrf(__DN(t) *_dev, e10k_pmad_1gbe_t _fieldval)
{
    e10k_autoc_t _regval = 0x200 & (((e10k_autoc_t )(_fieldval)) << 9);
    _regval = (_regval | (0xfffffdff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_d10gmp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_d10gmp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x400 & (((e10k_autoc_t )(_fieldval)) << 10);
    _regval = (_regval | (0xfffffbff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_ratd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_ratd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x800 & (((e10k_autoc_t )(_fieldval)) << 11);
    _regval = (_regval | (0xfffff7ff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_restart_an_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_restart_an_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x1000 & (((e10k_autoc_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_lms_wrf(__DN(t) *_dev, e10k_link_mode_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_lms_wrf(__DN(t) *_dev, e10k_link_mode_t _fieldval)
{
    e10k_autoc_t _regval = 0xe000 & (((e10k_autoc_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffff1fff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_kr_sup_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_kr_sup_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x10000 & (((e10k_autoc_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_fecr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_fecr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x20000 & (((e10k_autoc_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_feca_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_feca_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x40000 & (((e10k_autoc_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffbffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_anrxat_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_anrxat_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x780000 & (((e10k_autoc_t )(_fieldval)) << 19);
    _regval = (_regval | (0xff87ffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_anrxdm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_anrxdm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x800000 & (((e10k_autoc_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_anrxlm_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_anrxlm_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x1000000 & (((e10k_autoc_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfeffffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_anpdt_wrf(__DN(t) *_dev, e10k_aneg_pdt_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_anpdt_wrf(__DN(t) *_dev, e10k_aneg_pdt_t _fieldval)
{
    e10k_autoc_t _regval = 0x6000000 & (((e10k_autoc_t )(_fieldval)) << 25);
    _regval = (_regval | (0xf9ffffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_rf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_rf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x8000000 & (((e10k_autoc_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7ffffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_pb_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_pb_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x30000000 & (((e10k_autoc_t )(_fieldval)) << 28);
    _regval = (_regval | (0xcfffffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_kx_sup_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_kx_sup_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x40000000 & (((e10k_autoc_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc_kx4sup_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc_kx4sup_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc_t _regval = 0x80000000 & (((e10k_autoc_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0x42a0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a0, _regval);
    // No shadow register to write to
}

/*
 * Register links: Link Status Register
 * Type: e10k.links (Implicit type of Link Status Register register)
 *   kxsig_det	(size 1, offset 0, init 0):	RO	A signal is present
 *   fecsig_det	(size 1, offset 1, init 0):	RO	FEC reports signal detected
 *   fecblk_lck	(size 1, offset 2, init 0):	RO	FEC reached block lock
 *   krhberr	(size 1, offset 3, init 0):	RO	10GbE serial KR_PCS high error rate
 *   krpcsbl	(size 1, offset 4, init 0):	RO	10 GbE serial PCS block lock
 *   kxr_annprcv	(size 1, offset 5, init 0):	RO	KX/KX4/KR AN Next Page Received
 *   kxr_anprcv	(size 1, offset 6, init 0):	RO	KX/KX4/KR Backplane Auto Negotiation Page Received
 *   lnk_stat	(size 1, offset 7, init 0):	RO	Link Up and there was no link down from last time read
 *   kx4sig_det	(size 4, offset 8, init 0):	RO	Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane)
 *   krsig_det	(size 1, offset 12, init 0):	RO	Signal Detect of 10 GbE serial (KR or SFI)
 *   l10g_syncst	(size 4, offset 13, init 0):	RO	10G Parallel lane sync status (1bit per lane)
 *   l10g_algst	(size 1, offset 17, init 0):	RO	10 GbE align_status
 *   l1g_syncst	(size 1, offset 18, init 0):	RO	1G sync_status
 *   kxr_anrxid	(size 1, offset 19, init 0):	RO	KX/KX4/KR Backplane Auto Negotiation Rx Idle
 *   l1g_anen	(size 1, offset 20, init 0):	RO	PCS_1 GbE auto-negotiation is enabled
 *   l1g_lnken	(size 1, offset 21, init 0):	RO	1 GbE PCS enabled for 1 GbE and SGMII operation
 *   l10g_lnken	(size 1, offset 22, init 0):	RO	XGXS Enabled for 10 GbE operation
 *   fec_en	(size 1, offset 23, init 0):	RO	Status of forwarderrorcorrection in 10 GbE serial link
 *   l10g_seren	(size 1, offset 24, init 0):	RO	Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation
 *   sgmii_en	(size 1, offset 25, init 0):	RO	Status of SGMII operation
 *   mlink_mode	(size 2, offset 26, init 0):	RO	MAC link mode status
 *   lnk_speed	(size 2, offset 28, init 0):	RO	MAC link speed status
 *   lnk_up	(size 1, offset 30, init 0):	RO	Link is up
 *   kxr_ancomp	(size 1, offset 31, init 0):	RO	KX/KX4/KR backplane auto-negotiation has completed successfully
 */
static inline e10k_links_t e10k_links_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42a4));
}

static inline e10k_links_t e10k_links_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_links_t e10k_links_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42a4));
}

static inline void e10k_links_rawwr(__DN(t) *_dev, e10k_links_t _regval) __attribute__ ((always_inline));
static inline void e10k_links_rawwr(__DN(t) *_dev, e10k_links_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42a4, _regval);
}

// Register links is not writeable
static inline int e10k_links_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_links_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register links (Link Status Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxsig_det =\t%" PRIx8 "\t(A signal is present)\n", e10k_links_kxsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecsig_det =\t%" PRIx8 "\t(FEC reports signal detected)\n", e10k_links_fecsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fecblk_lck =\t%" PRIx8 "\t(FEC reached block lock)\n", e10k_links_fecblk_lck_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krhberr =\t%" PRIx8 "\t(10GbE serial KR_PCS high error rate)\n", e10k_links_krhberr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krpcsbl =\t%" PRIx8 "\t(10 GbE serial PCS block lock)\n", e10k_links_krpcsbl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_annprcv =\t%" PRIx8 "\t(KX/KX4/KR AN Next Page Received)\n", e10k_links_kxr_annprcv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_anprcv =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto Negotiation Page Received)\n", e10k_links_kxr_anprcv_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_stat =\t%" PRIx8 "\t(Link Up and there was no link down from last time read)\n", e10k_links_lnk_stat_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kx4sig_det =\t%" PRIx8 "\t(Signal Detect of 10 GbE Parallel (KX4, CX4 or XAUI) (1bit per lane))\n", e10k_links_kx4sig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " krsig_det =\t%" PRIx8 "\t(Signal Detect of 10 GbE serial (KR or SFI))\n", e10k_links_krsig_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_syncst =\t%" PRIx8 "\t(10G Parallel lane sync status (1bit per lane))\n", e10k_links_l10g_syncst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_algst =\t%" PRIx8 "\t(10 GbE align_status)\n", e10k_links_l10g_algst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_syncst =\t%" PRIx8 "\t(1G sync_status)\n", e10k_links_l1g_syncst_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_anrxid =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto Negotiation Rx Idle)\n", e10k_links_kxr_anrxid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_anen =\t%" PRIx8 "\t(PCS_1 GbE auto-negotiation is enabled)\n", e10k_links_l1g_anen_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l1g_lnken =\t%" PRIx8 "\t(1 GbE PCS enabled for 1 GbE and SGMII operation)\n", e10k_links_l1g_lnken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_lnken =\t%" PRIx8 "\t(XGXS Enabled for 10 GbE operation)\n", e10k_links_l10g_lnken_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_en =\t%" PRIx8 "\t(Status of forwarderrorcorrection in 10 GbE serial link)\n", e10k_links_fec_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " l10g_seren =\t%" PRIx8 "\t(Status of 10 GbE serial PCS (KR PCS) for KR or SFI operation)\n", e10k_links_l10g_seren_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " sgmii_en =\t%" PRIx8 "\t(Status of SGMII operation)\n", e10k_links_sgmii_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mlink_mode =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mac_lnkmode_prtval(_s + _r, _avail, e10k_links_mlink_mode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link mode status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_speed =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_link_speed_prtval(_s + _r, _avail, e10k_links_lnk_speed_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link speed status)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_up =\t%" PRIx8 "\t(Link is up)\n", e10k_links_lnk_up_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " kxr_ancomp =\t%" PRIx8 "\t(KX/KX4/KR backplane auto-negotiation has completed successfully)\n", e10k_links_kxr_ancomp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_links_kxsig_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxsig_det_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_kxsig_det_extract(_regval));
}

static inline uint8_t e10k_links_fecsig_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_fecsig_det_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_fecsig_det_extract(_regval));
}

static inline uint8_t e10k_links_fecblk_lck_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_fecblk_lck_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_fecblk_lck_extract(_regval));
}

static inline uint8_t e10k_links_krhberr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_krhberr_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_krhberr_extract(_regval));
}

static inline uint8_t e10k_links_krpcsbl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_krpcsbl_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_krpcsbl_extract(_regval));
}

static inline uint8_t e10k_links_kxr_annprcv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxr_annprcv_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_kxr_annprcv_extract(_regval));
}

static inline uint8_t e10k_links_kxr_anprcv_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxr_anprcv_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_kxr_anprcv_extract(_regval));
}

static inline uint8_t e10k_links_lnk_stat_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_lnk_stat_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_lnk_stat_extract(_regval));
}

static inline uint8_t e10k_links_kx4sig_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kx4sig_det_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_kx4sig_det_extract(_regval));
}

static inline uint8_t e10k_links_krsig_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_krsig_det_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_krsig_det_extract(_regval));
}

static inline uint8_t e10k_links_l10g_syncst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l10g_syncst_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_l10g_syncst_extract(_regval));
}

static inline uint8_t e10k_links_l10g_algst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l10g_algst_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_l10g_algst_extract(_regval));
}

static inline uint8_t e10k_links_l1g_syncst_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l1g_syncst_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_l1g_syncst_extract(_regval));
}

static inline uint8_t e10k_links_kxr_anrxid_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxr_anrxid_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_kxr_anrxid_extract(_regval));
}

static inline uint8_t e10k_links_l1g_anen_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l1g_anen_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_l1g_anen_extract(_regval));
}

static inline uint8_t e10k_links_l1g_lnken_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l1g_lnken_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_l1g_lnken_extract(_regval));
}

static inline uint8_t e10k_links_l10g_lnken_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l10g_lnken_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_l10g_lnken_extract(_regval));
}

static inline uint8_t e10k_links_fec_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_fec_en_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_fec_en_extract(_regval));
}

static inline uint8_t e10k_links_l10g_seren_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_l10g_seren_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_l10g_seren_extract(_regval));
}

static inline uint8_t e10k_links_sgmii_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_sgmii_en_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_sgmii_en_extract(_regval));
}

static inline e10k_mac_lnkmode_t e10k_links_mlink_mode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mac_lnkmode_t e10k_links_mlink_mode_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_mlink_mode_extract(_regval));
}

static inline e10k_link_speed_t e10k_links_lnk_speed_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_link_speed_t e10k_links_lnk_speed_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_lnk_speed_extract(_regval));
}

static inline uint8_t e10k_links_lnk_up_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_lnk_up_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_lnk_up_extract(_regval));
}

static inline uint8_t e10k_links_kxr_ancomp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links_kxr_ancomp_rdf(__DN(t) *_dev)
{
    e10k_links_t _regval = mackerel_read_addr_32(_dev->base, 0x42a4);
    return(e10k_links_kxr_ancomp_extract(_regval));
}

/*
 * Register links2: Link Status Register 2
 * Type: e10k.links2 (Implicit type of Link Status Register 2 register)
 *   mac_rxlm	(size 2, offset 0, init 0):	RO	MAC link mode in the Core Rx path
 *   _anon2	(size 1, offset 2, init 0):	RSVD	_
 *   mac_txlm	(size 2, offset 3, init 0):	RO	MAC link mode in the Core Tx path
 *   _anon5	(size 1, offset 5, init 0):	RSVD	_
 *   lnkp_an	(size 1, offset 6, init 0):	RO	Link partner is KX/KX4/KR backplane auto-negotiation capable
 *   _anon7	(size 25, offset 7, init 0):	RSVD	_
 */
static inline e10k_links2_t e10k_links2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_links2_t e10k_links2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4324));
}

static inline e10k_links2_t e10k_links2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_links2_t e10k_links2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4324));
}

static inline void e10k_links2_rawwr(__DN(t) *_dev, e10k_links2_t _regval) __attribute__ ((always_inline));
static inline void e10k_links2_rawwr(__DN(t) *_dev, e10k_links2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4324, _regval);
}

// Register links2 is not writeable
static inline int e10k_links2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_links2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_links2_t _regval = mackerel_read_addr_32(_dev->base, 0x4324);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register links2 (Link Status Register 2): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mac_rxlm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mac_rxtxlm_prtval(_s + _r, _avail, e10k_links2_mac_rxlm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link mode in the Core Rx path)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon2 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mac_txlm =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mac_rxtxlm_prtval(_s + _r, _avail, e10k_links2_mac_txlm_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(MAC link mode in the Core Tx path)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon5 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnkp_an =\t%" PRIx8 "\t(Link partner is KX/KX4/KR backplane auto-negotiation capable)\n", e10k_links2_lnkp_an_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon7 is anonymous
    return(_r);
}

static inline e10k_mac_rxtxlm_t e10k_links2_mac_rxlm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mac_rxtxlm_t e10k_links2_mac_rxlm_rdf(__DN(t) *_dev)
{
    e10k_links2_t _regval = mackerel_read_addr_32(_dev->base, 0x4324);
    return(e10k_links2_mac_rxlm_extract(_regval));
}

static inline e10k_mac_rxtxlm_t e10k_links2_mac_txlm_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mac_rxtxlm_t e10k_links2_mac_txlm_rdf(__DN(t) *_dev)
{
    e10k_links2_t _regval = mackerel_read_addr_32(_dev->base, 0x4324);
    return(e10k_links2_mac_txlm_extract(_regval));
}

static inline uint8_t e10k_links2_lnkp_an_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_links2_lnkp_an_rdf(__DN(t) *_dev)
{
    e10k_links2_t _regval = mackerel_read_addr_32(_dev->base, 0x4324);
    return(e10k_links2_lnkp_an_extract(_regval));
}

/*
 * Register autoc2: Auto Negotiation Control 2 Register
 * Type: e10k.autoc2 (Implicit type of Auto Negotiation Control 2 Register register)
 *   _anon0	(size 16, offset 0, init 0):	RSVD	_
 *   pmad_10ser	(size 2, offset 16, init 0):	RW	PMAPMD used for 10 GbE serial link operation
 *   ddpt	(size 1, offset 18, init 0):	RW	Disable DME Pages Transmit
 *   _anon19	(size 11, offset 19, init 0):	RSVD	_
 *   pdd	(size 1, offset 30, init 0):	RW	Disable the parallel detect part in the KX/KX4/KR bp aneg
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_autoc2_t e10k_autoc2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_autoc2_t e10k_autoc2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42a8));
}

static inline e10k_autoc2_t e10k_autoc2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_autoc2_t e10k_autoc2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42a8));
}

static inline void e10k_autoc2_rawwr(__DN(t) *_dev, e10k_autoc2_t _regval) __attribute__ ((always_inline));
static inline void e10k_autoc2_rawwr(__DN(t) *_dev, e10k_autoc2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42a8, _regval);
}

static inline void e10k_autoc2_wr(__DN(t) *_dev, e10k_autoc2_t _regval) __attribute__ ((always_inline));
static inline void e10k_autoc2_wr(__DN(t) *_dev, e10k_autoc2_t _regval)
{
    _regval = (_regval & 0x40070000);
    // No MB1 fields present
    _regval = (_regval | (0xbff8ffff & mackerel_read_addr_32(_dev->base, 0x42a8)));
    mackerel_write_addr_32(_dev->base, 0x42a8, _regval);
}

static inline int e10k_autoc2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_autoc2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_autoc2_t _regval = mackerel_read_addr_32(_dev->base, 0x42a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register autoc2 (Auto Negotiation Control 2 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmad_10ser =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pmapd_10gbes_prtval(_s + _r, _avail, e10k_autoc2_pmad_10ser_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(PMAPMD used for 10 GbE serial link operation)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ddpt =\t%" PRIx8 "\t(Disable DME Pages Transmit)\n", e10k_autoc2_ddpt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon19 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pdd =\t%" PRIx8 "\t(Disable the parallel detect part in the KX/KX4/KR bp aneg)\n", e10k_autoc2_pdd_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline e10k_pmapd_10gbes_t e10k_autoc2_pmad_10ser_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pmapd_10gbes_t e10k_autoc2_pmad_10ser_rdf(__DN(t) *_dev)
{
    e10k_autoc2_t _regval = mackerel_read_addr_32(_dev->base, 0x42a8);
    return(e10k_autoc2_pmad_10ser_extract(_regval));
}

static inline uint8_t e10k_autoc2_ddpt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc2_ddpt_rdf(__DN(t) *_dev)
{
    e10k_autoc2_t _regval = mackerel_read_addr_32(_dev->base, 0x42a8);
    return(e10k_autoc2_ddpt_extract(_regval));
}

static inline uint8_t e10k_autoc2_pdd_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_autoc2_pdd_rdf(__DN(t) *_dev)
{
    e10k_autoc2_t _regval = mackerel_read_addr_32(_dev->base, 0x42a8);
    return(e10k_autoc2_pdd_extract(_regval));
}

static inline void e10k_autoc2_pmad_10ser_wrf(__DN(t) *_dev, e10k_pmapd_10gbes_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc2_pmad_10ser_wrf(__DN(t) *_dev, e10k_pmapd_10gbes_t _fieldval)
{
    e10k_autoc2_t _regval = 0x30000 & (((e10k_autoc2_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffcffff & mackerel_read_addr_32(_dev->base, 0x42a8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a8, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc2_ddpt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc2_ddpt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc2_t _regval = 0x40000 & (((e10k_autoc2_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfffbffff & mackerel_read_addr_32(_dev->base, 0x42a8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a8, _regval);
    // No shadow register to write to
}

static inline void e10k_autoc2_pdd_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_autoc2_pdd_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_autoc2_t _regval = 0x40000000 & (((e10k_autoc2_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x42a8)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42a8, _regval);
    // No shadow register to write to
}

/*
 * Register anlp1: Auto Negotiation Link Partner Link Control Word 1 Register
 * Type: e10k.anlp1 (Implicit type of Auto Negotiation Link Partner Link Control Word 1 Register register)
 *   lpan_sel	(size 5, offset 0, init 0):	RO	LP AN adv Selector field
 *   lpan_echn	(size 5, offset 5, init 0):	RO	LP AN adv Echoed Nonce field
 *   lpan_pause	(size 2, offset 10, init 0):	RO	LP AN adv Pause
 *   _anon12	(size 1, offset 12, init 0):	RSVD	_
 *   lpan_rf	(size 1, offset 13, init 0):	RO	LP AN adv RF
 *   lpan_ack	(size 1, offset 14, init 0):	RO	LP AN adv Acknowledge
 *   lpan_np	(size 1, offset 15, init 0):	RO	LP AN adv NP
 *   anas	(size 4, offset 16, init 0):	RO	KX/KX4/KR Backplane Auto-Negotiation Arbitration State
 *   _anon20	(size 12, offset 20, init 0):	RSVD	_
 */
static inline e10k_anlp1_t e10k_anlp1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42b0));
}

static inline e10k_anlp1_t e10k_anlp1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_anlp1_t e10k_anlp1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42b0));
}

static inline void e10k_anlp1_rawwr(__DN(t) *_dev, e10k_anlp1_t _regval) __attribute__ ((always_inline));
static inline void e10k_anlp1_rawwr(__DN(t) *_dev, e10k_anlp1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42b0, _regval);
}

// Register anlp1 is not writeable
static inline int e10k_anlp1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_anlp1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_anlp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register anlp1 (Auto Negotiation Link Partner Link Control Word 1 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_sel =\t%" PRIx8 "\t(LP AN adv Selector field)\n", e10k_anlp1_lpan_sel_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_echn =\t%" PRIx8 "\t(LP AN adv Echoed Nonce field)\n", e10k_anlp1_lpan_echn_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_pause =\t%" PRIx8 "\t(LP AN adv Pause)\n", e10k_anlp1_lpan_pause_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_rf =\t%" PRIx8 "\t(LP AN adv RF)\n", e10k_anlp1_lpan_rf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_ack =\t%" PRIx8 "\t(LP AN adv Acknowledge)\n", e10k_anlp1_lpan_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_np =\t%" PRIx8 "\t(LP AN adv NP)\n", e10k_anlp1_lpan_np_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anas =\t%" PRIx8 "\t(KX/KX4/KR Backplane Auto-Negotiation Arbitration State)\n", e10k_anlp1_anas_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    return(_r);
}

static inline uint8_t e10k_anlp1_lpan_sel_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_sel_rdf(__DN(t) *_dev)
{
    e10k_anlp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42b0);
    return(e10k_anlp1_lpan_sel_extract(_regval));
}

static inline uint8_t e10k_anlp1_lpan_echn_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_echn_rdf(__DN(t) *_dev)
{
    e10k_anlp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42b0);
    return(e10k_anlp1_lpan_echn_extract(_regval));
}

static inline uint8_t e10k_anlp1_lpan_pause_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_pause_rdf(__DN(t) *_dev)
{
    e10k_anlp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42b0);
    return(e10k_anlp1_lpan_pause_extract(_regval));
}

static inline uint8_t e10k_anlp1_lpan_rf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_rf_rdf(__DN(t) *_dev)
{
    e10k_anlp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42b0);
    return(e10k_anlp1_lpan_rf_extract(_regval));
}

static inline uint8_t e10k_anlp1_lpan_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_ack_rdf(__DN(t) *_dev)
{
    e10k_anlp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42b0);
    return(e10k_anlp1_lpan_ack_extract(_regval));
}

static inline uint8_t e10k_anlp1_lpan_np_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_lpan_np_rdf(__DN(t) *_dev)
{
    e10k_anlp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42b0);
    return(e10k_anlp1_lpan_np_extract(_regval));
}

static inline uint8_t e10k_anlp1_anas_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp1_anas_rdf(__DN(t) *_dev)
{
    e10k_anlp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42b0);
    return(e10k_anlp1_anas_extract(_regval));
}

/*
 * Register anlp2: Auto Negotiation Link Partner Link Control Word 2 Register
 * Type: e10k.anlp2 (Implicit type of Auto Negotiation Link Partner Link Control Word 2 Register register)
 *   lpan_nf	(size 5, offset 0, init 0):	RO	LP AN adv page fields T[4:0]
 *   lpan_afl	(size 11, offset 5, init 0):	RO	LP AN adv page fields A[10:0]
 *   lpan_afh	(size 16, offset 16, init 0):	RO	LP AN adv page fields A[26:11]
 */
static inline e10k_anlp2_t e10k_anlp2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_anlp2_t e10k_anlp2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42b4));
}

static inline e10k_anlp2_t e10k_anlp2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_anlp2_t e10k_anlp2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42b4));
}

static inline void e10k_anlp2_rawwr(__DN(t) *_dev, e10k_anlp2_t _regval) __attribute__ ((always_inline));
static inline void e10k_anlp2_rawwr(__DN(t) *_dev, e10k_anlp2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42b4, _regval);
}

// Register anlp2 is not writeable
static inline int e10k_anlp2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_anlp2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_anlp2_t _regval = mackerel_read_addr_32(_dev->base, 0x42b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register anlp2 (Auto Negotiation Link Partner Link Control Word 2 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_nf =\t%" PRIx8 "\t(LP AN adv page fields T[4:0])\n", e10k_anlp2_lpan_nf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_afl =\t%" PRIx16 "\t(LP AN adv page fields A[10:0])\n", e10k_anlp2_lpan_afl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_afh =\t%" PRIx16 "\t(LP AN adv page fields A[26:11])\n", e10k_anlp2_lpan_afh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_anlp2_lpan_nf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlp2_lpan_nf_rdf(__DN(t) *_dev)
{
    e10k_anlp2_t _regval = mackerel_read_addr_32(_dev->base, 0x42b4);
    return(e10k_anlp2_lpan_nf_extract(_regval));
}

static inline uint16_t e10k_anlp2_lpan_afl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_anlp2_lpan_afl_rdf(__DN(t) *_dev)
{
    e10k_anlp2_t _regval = mackerel_read_addr_32(_dev->base, 0x42b4);
    return(e10k_anlp2_lpan_afl_extract(_regval));
}

static inline uint16_t e10k_anlp2_lpan_afh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_anlp2_lpan_afh_rdf(__DN(t) *_dev)
{
    e10k_anlp2_t _regval = mackerel_read_addr_32(_dev->base, 0x42b4);
    return(e10k_anlp2_lpan_afh_extract(_regval));
}

/*
 * Register mmngc: MAC Manageability Control Register
 * Type: e10k.mmngc (Implicit type of MAC Manageability Control Register register)
 *   mng_veto	(size 1, offset 0, init 0):	RO	MNG_VETO
 *   _anon1	(size 31, offset 1, init 0):	RSVD	_
 */
static inline e10k_mmngc_t e10k_mmngc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mmngc_t e10k_mmngc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42d0));
}

static inline e10k_mmngc_t e10k_mmngc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mmngc_t e10k_mmngc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42d0));
}

static inline void e10k_mmngc_rawwr(__DN(t) *_dev, e10k_mmngc_t _regval) __attribute__ ((always_inline));
static inline void e10k_mmngc_rawwr(__DN(t) *_dev, e10k_mmngc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42d0, _regval);
}

// Register mmngc is not writeable
static inline int e10k_mmngc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mmngc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mmngc_t _regval = mackerel_read_addr_32(_dev->base, 0x42d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mmngc (MAC Manageability Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mng_veto =\t%" PRIx8 "\t(MNG_VETO)\n", e10k_mmngc_mng_veto_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    return(_r);
}

static inline uint8_t e10k_mmngc_mng_veto_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mmngc_mng_veto_rdf(__DN(t) *_dev)
{
    e10k_mmngc_t _regval = mackerel_read_addr_32(_dev->base, 0x42d0);
    return(e10k_mmngc_mng_veto_extract(_regval));
}

/*
 * Register anlpnp1: Auto Negotiation Link Partner Next Page 1 Register
 * Type: e10k.anlpnp1 (Implicit type of Auto Negotiation Link Partner Next Page 1 Register register)
 *   msg	(size 11, offset 0, init 0):	RO	LP AN adv np Message/Unformatted Code
 *   toggle	(size 1, offset 11, init 0):	RO	LP AN adv np Toggle
 *   ack2	(size 1, offset 12, init 0):	RO	LP AN adv np Acknowledge2
 *   mp	(size 1, offset 13, init 0):	RO	LP AN adv np MP
 *   ack	(size 1, offset 14, init 0):	RO	LP AN adv np Acknowledge
 *   np	(size 1, offset 15, init 0):	RO	LP AN adv np NP
 *   ufmtc	(size 16, offset 16, init 0):	RO	LP AN adv np Unformatted Code
 */
static inline e10k_anlpnp1_t e10k_anlpnp1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42d4));
}

static inline e10k_anlpnp1_t e10k_anlpnp1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_anlpnp1_t e10k_anlpnp1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42d4));
}

static inline void e10k_anlpnp1_rawwr(__DN(t) *_dev, e10k_anlpnp1_t _regval) __attribute__ ((always_inline));
static inline void e10k_anlpnp1_rawwr(__DN(t) *_dev, e10k_anlpnp1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42d4, _regval);
}

// Register anlpnp1 is not writeable
static inline int e10k_anlpnp1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_anlpnp1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_anlpnp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register anlpnp1 (Auto Negotiation Link Partner Next Page 1 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " msg =\t%" PRIx16 "\t(LP AN adv np Message/Unformatted Code)\n", e10k_anlpnp1_msg_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " toggle =\t%" PRIx8 "\t(LP AN adv np Toggle)\n", e10k_anlpnp1_toggle_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack2 =\t%" PRIx8 "\t(LP AN adv np Acknowledge2)\n", e10k_anlpnp1_ack2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mp =\t%" PRIx8 "\t(LP AN adv np MP)\n", e10k_anlpnp1_mp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ack =\t%" PRIx8 "\t(LP AN adv np Acknowledge)\n", e10k_anlpnp1_ack_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " np =\t%" PRIx8 "\t(LP AN adv np NP)\n", e10k_anlpnp1_np_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ufmtc =\t%" PRIx16 "\t(LP AN adv np Unformatted Code)\n", e10k_anlpnp1_ufmtc_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint16_t e10k_anlpnp1_msg_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_anlpnp1_msg_rdf(__DN(t) *_dev)
{
    e10k_anlpnp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42d4);
    return(e10k_anlpnp1_msg_extract(_regval));
}

static inline uint8_t e10k_anlpnp1_toggle_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_toggle_rdf(__DN(t) *_dev)
{
    e10k_anlpnp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42d4);
    return(e10k_anlpnp1_toggle_extract(_regval));
}

static inline uint8_t e10k_anlpnp1_ack2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_ack2_rdf(__DN(t) *_dev)
{
    e10k_anlpnp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42d4);
    return(e10k_anlpnp1_ack2_extract(_regval));
}

static inline uint8_t e10k_anlpnp1_mp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_mp_rdf(__DN(t) *_dev)
{
    e10k_anlpnp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42d4);
    return(e10k_anlpnp1_mp_extract(_regval));
}

static inline uint8_t e10k_anlpnp1_ack_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_ack_rdf(__DN(t) *_dev)
{
    e10k_anlpnp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42d4);
    return(e10k_anlpnp1_ack_extract(_regval));
}

static inline uint8_t e10k_anlpnp1_np_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_anlpnp1_np_rdf(__DN(t) *_dev)
{
    e10k_anlpnp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42d4);
    return(e10k_anlpnp1_np_extract(_regval));
}

static inline uint16_t e10k_anlpnp1_ufmtc_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_anlpnp1_ufmtc_rdf(__DN(t) *_dev)
{
    e10k_anlpnp1_t _regval = mackerel_read_addr_32(_dev->base, 0x42d4);
    return(e10k_anlpnp1_ufmtc_extract(_regval));
}

/*
 * Register anlpnp2: Auto Negotiation Link Partner Next Page 2 Register
 * Type: e10k.anlpnp2 (Implicit type of Auto Negotiation Link Partner Next Page 2 Register register)
 *   lpan_nph	(size 16, offset 0, init 0):	RO	LP AN Next Page Fields D[47:32]. [15:0] = Unformatted Code
 *   _anon16	(size 16, offset 16, init 0):	RSVD	_
 */
static inline e10k_anlpnp2_t e10k_anlpnp2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_anlpnp2_t e10k_anlpnp2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42d8));
}

static inline e10k_anlpnp2_t e10k_anlpnp2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_anlpnp2_t e10k_anlpnp2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42d8));
}

static inline void e10k_anlpnp2_rawwr(__DN(t) *_dev, e10k_anlpnp2_t _regval) __attribute__ ((always_inline));
static inline void e10k_anlpnp2_rawwr(__DN(t) *_dev, e10k_anlpnp2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42d8, _regval);
}

// Register anlpnp2 is not writeable
static inline int e10k_anlpnp2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_anlpnp2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_anlpnp2_t _regval = mackerel_read_addr_32(_dev->base, 0x42d8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register anlpnp2 (Auto Negotiation Link Partner Next Page 2 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lpan_nph =\t%" PRIx16 "\t(LP AN Next Page Fields D[47:32]. [15:0] = Unformatted Code)\n", e10k_anlpnp2_lpan_nph_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    return(_r);
}

static inline uint16_t e10k_anlpnp2_lpan_nph_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint16_t e10k_anlpnp2_lpan_nph_rdf(__DN(t) *_dev)
{
    e10k_anlpnp2_t _regval = mackerel_read_addr_32(_dev->base, 0x42d8);
    return(e10k_anlpnp2_lpan_nph_extract(_regval));
}

/*
 * Register krpcsfc: KR PCS and FEC Control Register
 * Type: e10k.krpcsfc (Implicit type of KR PCS and FEC Control Register register)
 *   _anon0	(size 11, offset 0, init 0):	MBZ	_
 *   _anon11	(size 5, offset 11, init 0):	RSVD	_
 *   fec_enerr	(size 1, offset 16, init 0):	RW	FEC Enable Error Indication to KR-PCS
 *   _anon17	(size 1, offset 17, init 0):	RSVD	_
 *   fec_ncnt	(size 2, offset 18, init 0):	RW	Good Parity Block Count
 *   fec_mcnt	(size 2, offset 20, init 0):	RW	Bad Parity Block Count
 *   fec_lmode	(size 1, offset 22, init 0):	RW	Enables FEC Loose Mode
 *   fec_rxswp	(size 1, offset 23, init 0):	RW	FEC Rx Bit Order Swap
 *   fec_txswp	(size 1, offset 24, init 0):	RW	FEC Tx Bit Order Swap
 *   _anon25	(size 1, offset 25, init 0):	RSVD	_
 *   slipass	(size 1, offset 26, init 0):	RW	Loss of Sync (frame_align) Idle Pass-Through Select
 *   ssync	(size 1, offset 27, init 0):	RW	Rx Block Lock Override
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static inline e10k_krpcsfc_t e10k_krpcsfc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42e0));
}

static inline e10k_krpcsfc_t e10k_krpcsfc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_krpcsfc_t e10k_krpcsfc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42e0));
}

static inline void e10k_krpcsfc_rawwr(__DN(t) *_dev, e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_rawwr(__DN(t) *_dev, e10k_krpcsfc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
}

static inline void e10k_krpcsfc_wr(__DN(t) *_dev, e10k_krpcsfc_t _regval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_wr(__DN(t) *_dev, e10k_krpcsfc_t _regval)
{
    _regval = (_regval & 0xdfd0000);
    // No MB1 fields present
    _regval = (_regval | (0xf202f800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
}

static inline int e10k_krpcsfc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_krpcsfc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register krpcsfc (KR PCS and FEC Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    // _anon11 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_enerr =\t%" PRIx8 "\t(FEC Enable Error Indication to KR-PCS)\n", e10k_krpcsfc_fec_enerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_ncnt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fec_ncnt_prtval(_s + _r, _avail, e10k_krpcsfc_fec_ncnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Good Parity Block Count)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_mcnt =\t");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fec_mcnt_prtval(_s + _r, _avail, e10k_krpcsfc_fec_mcnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t(Bad Parity Block Count)\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_lmode =\t%" PRIx8 "\t(Enables FEC Loose Mode)\n", e10k_krpcsfc_fec_lmode_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_rxswp =\t%" PRIx8 "\t(FEC Rx Bit Order Swap)\n", e10k_krpcsfc_fec_rxswp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_txswp =\t%" PRIx8 "\t(FEC Tx Bit Order Swap)\n", e10k_krpcsfc_fec_txswp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon25 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " slipass =\t%" PRIx8 "\t(Loss of Sync (frame_align) Idle Pass-Through Select)\n", e10k_krpcsfc_slipass_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ssync =\t%" PRIx8 "\t(Rx Block Lock Override)\n", e10k_krpcsfc_ssync_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline uint8_t e10k_krpcsfc_fec_enerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_fec_enerr_rdf(__DN(t) *_dev)
{
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    return(e10k_krpcsfc_fec_enerr_extract(_regval));
}

static inline e10k_fec_ncnt_t e10k_krpcsfc_fec_ncnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fec_ncnt_t e10k_krpcsfc_fec_ncnt_rdf(__DN(t) *_dev)
{
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    return(e10k_krpcsfc_fec_ncnt_extract(_regval));
}

static inline e10k_fec_mcnt_t e10k_krpcsfc_fec_mcnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fec_mcnt_t e10k_krpcsfc_fec_mcnt_rdf(__DN(t) *_dev)
{
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    return(e10k_krpcsfc_fec_mcnt_extract(_regval));
}

static inline uint8_t e10k_krpcsfc_fec_lmode_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_fec_lmode_rdf(__DN(t) *_dev)
{
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    return(e10k_krpcsfc_fec_lmode_extract(_regval));
}

static inline uint8_t e10k_krpcsfc_fec_rxswp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_fec_rxswp_rdf(__DN(t) *_dev)
{
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    return(e10k_krpcsfc_fec_rxswp_extract(_regval));
}

static inline uint8_t e10k_krpcsfc_fec_txswp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_fec_txswp_rdf(__DN(t) *_dev)
{
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    return(e10k_krpcsfc_fec_txswp_extract(_regval));
}

static inline uint8_t e10k_krpcsfc_slipass_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_slipass_rdf(__DN(t) *_dev)
{
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    return(e10k_krpcsfc_slipass_extract(_regval));
}

static inline uint8_t e10k_krpcsfc_ssync_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcsfc_ssync_rdf(__DN(t) *_dev)
{
    e10k_krpcsfc_t _regval = mackerel_read_addr_32(_dev->base, 0x42e0);
    return(e10k_krpcsfc_ssync_extract(_regval));
}

static inline void e10k_krpcsfc_fec_enerr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_fec_enerr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_krpcsfc_t _regval = 0x10000 & (((e10k_krpcsfc_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffef800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffff800);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
    // No shadow register to write to
}

static inline void e10k_krpcsfc_fec_ncnt_wrf(__DN(t) *_dev, e10k_fec_ncnt_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_fec_ncnt_wrf(__DN(t) *_dev, e10k_fec_ncnt_t _fieldval)
{
    e10k_krpcsfc_t _regval = 0xc0000 & (((e10k_krpcsfc_t )(_fieldval)) << 18);
    _regval = (_regval | (0xfff3f800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffff800);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
    // No shadow register to write to
}

static inline void e10k_krpcsfc_fec_mcnt_wrf(__DN(t) *_dev, e10k_fec_mcnt_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_fec_mcnt_wrf(__DN(t) *_dev, e10k_fec_mcnt_t _fieldval)
{
    e10k_krpcsfc_t _regval = 0x300000 & (((e10k_krpcsfc_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffcff800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffff800);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
    // No shadow register to write to
}

static inline void e10k_krpcsfc_fec_lmode_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_fec_lmode_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_krpcsfc_t _regval = 0x400000 & (((e10k_krpcsfc_t )(_fieldval)) << 22);
    _regval = (_regval | (0xffbff800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffff800);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
    // No shadow register to write to
}

static inline void e10k_krpcsfc_fec_rxswp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_fec_rxswp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_krpcsfc_t _regval = 0x800000 & (((e10k_krpcsfc_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7ff800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffff800);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
    // No shadow register to write to
}

static inline void e10k_krpcsfc_fec_txswp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_fec_txswp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_krpcsfc_t _regval = 0x1000000 & (((e10k_krpcsfc_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfefff800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffff800);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
    // No shadow register to write to
}

static inline void e10k_krpcsfc_slipass_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_slipass_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_krpcsfc_t _regval = 0x4000000 & (((e10k_krpcsfc_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbfff800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffff800);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
    // No shadow register to write to
}

static inline void e10k_krpcsfc_ssync_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_krpcsfc_ssync_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_krpcsfc_t _regval = 0x8000000 & (((e10k_krpcsfc_t )(_fieldval)) << 27);
    _regval = (_regval | (0xf7fff800 & mackerel_read_addr_32(_dev->base, 0x42e0)));
    // No read of register shadow required
    _regval = (_regval & 0xfffff800);
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x42e0, _regval);
    // No shadow register to write to
}

/*
 * Register krpcss: KR PCS Status Register
 * Type: e10k.krpcss (Implicit type of KR PCS Status Register register)
 *   _anon0	(size 3, offset 0, init 0):	RSVD	_
 *   errcnt_blk	(size 8, offset 3, init 0):	RC	Rx Decoder Error Counter
 *   berbad_cnt	(size 6, offset 11, init 0):	RC	BER Bad Counter
 *   rxfifo_elh	(size 1, offset 17, init 0):	RC	Elastic Buffer Error
 *   rxlf_det	(size 1, offset 18, init 0):	RC	RX_LF Detect
 *   rxfrm_alerr	(size 1, offset 19, init 0):	RC	Frame Align Error
 *   blklck	(size 1, offset 20, init 0):	RO	Rx Block Lock Status bit
 *   hber_sts	(size 1, offset 21, init 0):	RC	Rx High Bit Error Rate Status bit
 *   rxfl_det2	(size 1, offset 22, init 0):	RC	RX_LF Detect
 *   lnk_sts	(size 1, offset 23, init 0):	RO	Rx Link Status
 *   rx_ufl	(size 1, offset 24, init 0):	RC	Rx Underflow Status
 *   rx_ofl	(size 1, offset 25, init 0):	RC	Rx Overflow Status
 *   rx_fifoerr	(size 1, offset 26, init 0):	RO	Rx Elastic Buffer Error
 *   rx_dataval	(size 1, offset 27, init 0):	RO	Data Valid Status
 *   tx_ufl	(size 1, offset 28, init 0):	RC	Tx Underflow Status
 *   tx_ofl	(size 1, offset 29, init 0):	RC	Tx Overflow Status
 *   tx_fifoerr	(size 1, offset 30, init 0):	RO	Unlatched FIFO Error Status
 *   tx_dataval	(size 1, offset 31, init 0):	RO	Data Valid Status
 */
static inline e10k_krpcss_t e10k_krpcss_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42e4));
}

static inline e10k_krpcss_t e10k_krpcss_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_krpcss_t e10k_krpcss_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42e4));
}

static inline void e10k_krpcss_rawwr(__DN(t) *_dev, e10k_krpcss_t _regval) __attribute__ ((always_inline));
static inline void e10k_krpcss_rawwr(__DN(t) *_dev, e10k_krpcss_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42e4, _regval);
}

// Register krpcss is not writeable
static inline int e10k_krpcss_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_krpcss_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register krpcss (KR PCS Status Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " errcnt_blk =\t%" PRIx8 "\t(Rx Decoder Error Counter)\n", e10k_krpcss_errcnt_blk_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " berbad_cnt =\t%" PRIx8 "\t(BER Bad Counter)\n", e10k_krpcss_berbad_cnt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfifo_elh =\t%" PRIx8 "\t(Elastic Buffer Error)\n", e10k_krpcss_rxfifo_elh_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxlf_det =\t%" PRIx8 "\t(RX_LF Detect)\n", e10k_krpcss_rxlf_det_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfrm_alerr =\t%" PRIx8 "\t(Frame Align Error)\n", e10k_krpcss_rxfrm_alerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " blklck =\t%" PRIx8 "\t(Rx Block Lock Status bit)\n", e10k_krpcss_blklck_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " hber_sts =\t%" PRIx8 "\t(Rx High Bit Error Rate Status bit)\n", e10k_krpcss_hber_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rxfl_det2 =\t%" PRIx8 "\t(RX_LF Detect)\n", e10k_krpcss_rxfl_det2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " lnk_sts =\t%" PRIx8 "\t(Rx Link Status)\n", e10k_krpcss_lnk_sts_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_ufl =\t%" PRIx8 "\t(Rx Underflow Status)\n", e10k_krpcss_rx_ufl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_ofl =\t%" PRIx8 "\t(Rx Overflow Status)\n", e10k_krpcss_rx_ofl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_fifoerr =\t%" PRIx8 "\t(Rx Elastic Buffer Error)\n", e10k_krpcss_rx_fifoerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rx_dataval =\t%" PRIx8 "\t(Data Valid Status)\n", e10k_krpcss_rx_dataval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_ufl =\t%" PRIx8 "\t(Tx Underflow Status)\n", e10k_krpcss_tx_ufl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_ofl =\t%" PRIx8 "\t(Tx Overflow Status)\n", e10k_krpcss_tx_ofl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_fifoerr =\t%" PRIx8 "\t(Unlatched FIFO Error Status)\n", e10k_krpcss_tx_fifoerr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " tx_dataval =\t%" PRIx8 "\t(Data Valid Status)\n", e10k_krpcss_tx_dataval_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint8_t e10k_krpcss_errcnt_blk_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_errcnt_blk_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_errcnt_blk_extract(_regval));
}

static inline uint8_t e10k_krpcss_berbad_cnt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_berbad_cnt_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_berbad_cnt_extract(_regval));
}

static inline uint8_t e10k_krpcss_rxfifo_elh_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rxfifo_elh_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_rxfifo_elh_extract(_regval));
}

static inline uint8_t e10k_krpcss_rxlf_det_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rxlf_det_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_rxlf_det_extract(_regval));
}

static inline uint8_t e10k_krpcss_rxfrm_alerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rxfrm_alerr_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_rxfrm_alerr_extract(_regval));
}

static inline uint8_t e10k_krpcss_blklck_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_blklck_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_blklck_extract(_regval));
}

static inline uint8_t e10k_krpcss_hber_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_hber_sts_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_hber_sts_extract(_regval));
}

static inline uint8_t e10k_krpcss_rxfl_det2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rxfl_det2_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_rxfl_det2_extract(_regval));
}

static inline uint8_t e10k_krpcss_lnk_sts_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_lnk_sts_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_lnk_sts_extract(_regval));
}

static inline uint8_t e10k_krpcss_rx_ufl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rx_ufl_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_rx_ufl_extract(_regval));
}

static inline uint8_t e10k_krpcss_rx_ofl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rx_ofl_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_rx_ofl_extract(_regval));
}

static inline uint8_t e10k_krpcss_rx_fifoerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rx_fifoerr_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_rx_fifoerr_extract(_regval));
}

static inline uint8_t e10k_krpcss_rx_dataval_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_rx_dataval_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_rx_dataval_extract(_regval));
}

static inline uint8_t e10k_krpcss_tx_ufl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_tx_ufl_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_tx_ufl_extract(_regval));
}

static inline uint8_t e10k_krpcss_tx_ofl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_tx_ofl_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_tx_ofl_extract(_regval));
}

static inline uint8_t e10k_krpcss_tx_fifoerr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_tx_fifoerr_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_tx_fifoerr_extract(_regval));
}

static inline uint8_t e10k_krpcss_tx_dataval_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_krpcss_tx_dataval_rdf(__DN(t) *_dev)
{
    e10k_krpcss_t _regval = mackerel_read_addr_32(_dev->base, 0x42e4);
    return(e10k_krpcss_tx_dataval_extract(_regval));
}

/*
 * Register fecs1: FEC Status 1 Register
 * Type: e10k.fecs1 (Implicit type of FEC Status 1 Register register)
 *   fec_cr	(size 32, offset 0, init 0):	RC	FEC Correctable Error Counter
 */
static inline e10k_fecs1_t e10k_fecs1_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fecs1_t e10k_fecs1_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42e8));
}

static inline e10k_fecs1_t e10k_fecs1_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fecs1_t e10k_fecs1_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42e8));
}

static inline void e10k_fecs1_rawwr(__DN(t) *_dev, e10k_fecs1_t _regval) __attribute__ ((always_inline));
static inline void e10k_fecs1_rawwr(__DN(t) *_dev, e10k_fecs1_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42e8, _regval);
}

// Register fecs1 is not writeable
static inline int e10k_fecs1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fecs1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fecs1_t _regval = mackerel_read_addr_32(_dev->base, 0x42e8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fecs1 (FEC Status 1 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_cr =\t%" PRIx32 "\t(FEC Correctable Error Counter)\n", e10k_fecs1_fec_cr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fecs1_fec_cr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fecs1_fec_cr_rdf(__DN(t) *_dev)
{
    e10k_fecs1_t _regval = mackerel_read_addr_32(_dev->base, 0x42e8);
    return(e10k_fecs1_fec_cr_extract(_regval));
}

/*
 * Register fecs2: FEC Status 2 Register
 * Type: e10k.fecs2 (Implicit type of FEC Status 2 Register register)
 *   fec_uncr	(size 32, offset 0, init 0):	RC	FEC Uncorrectable Error Counter
 */
static inline e10k_fecs2_t e10k_fecs2_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fecs2_t e10k_fecs2_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42ec));
}

static inline e10k_fecs2_t e10k_fecs2_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_fecs2_t e10k_fecs2_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x42ec));
}

static inline void e10k_fecs2_rawwr(__DN(t) *_dev, e10k_fecs2_t _regval) __attribute__ ((always_inline));
static inline void e10k_fecs2_rawwr(__DN(t) *_dev, e10k_fecs2_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x42ec, _regval);
}

// Register fecs2 is not writeable
static inline int e10k_fecs2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fecs2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_fecs2_t _regval = mackerel_read_addr_32(_dev->base, 0x42ec);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register fecs2 (FEC Status 2 Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fec_uncr =\t%" PRIx32 "\t(FEC Uncorrectable Error Counter)\n", e10k_fecs2_fec_uncr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline uint32_t e10k_fecs2_fec_uncr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_fecs2_fec_uncr_rdf(__DN(t) *_dev)
{
    e10k_fecs2_t _regval = mackerel_read_addr_32(_dev->base, 0x42ec);
    return(e10k_fecs2_fec_uncr_extract(_regval));
}

/*
 * Register corectl: Core Analog Configuration Register
 * Type: e10k.corectl (Implicit type of Core Analog Configuration Register register)
 *   data	(size 8, offset 0, init 0):	RW	Data to Core Analog Registers
 *   address	(size 8, offset 8, init 0):	RW	Address to Core Analog Registers
 *   latch_addr	(size 1, offset 16, init 0):	RW	Latch address
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
static inline e10k_corectl_t e10k_corectl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_corectl_t e10k_corectl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14f00));
}

static inline e10k_corectl_t e10k_corectl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_corectl_t e10k_corectl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14f00));
}

static inline void e10k_corectl_rawwr(__DN(t) *_dev, e10k_corectl_t _regval) __attribute__ ((always_inline));
static inline void e10k_corectl_rawwr(__DN(t) *_dev, e10k_corectl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14f00, _regval);
}

static inline void e10k_corectl_wr(__DN(t) *_dev, e10k_corectl_t _regval) __attribute__ ((always_inline));
static inline void e10k_corectl_wr(__DN(t) *_dev, e10k_corectl_t _regval)
{
    _regval = (_regval & 0x1ffff);
    // No MB1 fields present
    _regval = (_regval | (0xfffe0000 & mackerel_read_addr_32(_dev->base, 0x14f00)));
    mackerel_write_addr_32(_dev->base, 0x14f00, _regval);
}

static inline int e10k_corectl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_corectl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_corectl_t _regval = mackerel_read_addr_32(_dev->base, 0x14f00);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register corectl (Core Analog Configuration Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to Core Analog Registers)\n", e10k_corectl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to Core Analog Registers)\n", e10k_corectl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " latch_addr =\t%" PRIx8 "\t(Latch address)\n", e10k_corectl_latch_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    return(_r);
}

static inline uint8_t e10k_corectl_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_corectl_data_rdf(__DN(t) *_dev)
{
    e10k_corectl_t _regval = mackerel_read_addr_32(_dev->base, 0x14f00);
    return(e10k_corectl_data_extract(_regval));
}

static inline uint8_t e10k_corectl_address_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_corectl_address_rdf(__DN(t) *_dev)
{
    e10k_corectl_t _regval = mackerel_read_addr_32(_dev->base, 0x14f00);
    return(e10k_corectl_address_extract(_regval));
}

static inline uint8_t e10k_corectl_latch_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_corectl_latch_addr_rdf(__DN(t) *_dev)
{
    e10k_corectl_t _regval = mackerel_read_addr_32(_dev->base, 0x14f00);
    return(e10k_corectl_latch_addr_extract(_regval));
}

static inline void e10k_corectl_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_corectl_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_corectl_t _regval = 0xff & (((e10k_corectl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x14f00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14f00, _regval);
    // No shadow register to write to
}

static inline void e10k_corectl_address_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_corectl_address_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_corectl_t _regval = 0xff00 & (((e10k_corectl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x14f00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14f00, _regval);
    // No shadow register to write to
}

static inline void e10k_corectl_latch_addr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_corectl_latch_addr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_corectl_t _regval = 0x10000 & (((e10k_corectl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x14f00)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14f00, _regval);
    // No shadow register to write to
}

/*
 * Register smadarctl: Core Common Configuration Register
 * Type: e10k.smadarctl (Implicit type of Core Common Configuration Register register)
 *   data	(size 8, offset 0, init 0):	RW	Data to Core Analog Registers
 *   address	(size 8, offset 8, init 0):	RW	Address to Core Analog Registers
 *   latch_addr	(size 1, offset 16, init 0):	RW	Latch address
 *   _anon17	(size 15, offset 17, init 0):	RSVD	_
 */
static inline e10k_smadarctl_t e10k_smadarctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_smadarctl_t e10k_smadarctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14f10));
}

static inline e10k_smadarctl_t e10k_smadarctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_smadarctl_t e10k_smadarctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x14f10));
}

static inline void e10k_smadarctl_rawwr(__DN(t) *_dev, e10k_smadarctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_smadarctl_rawwr(__DN(t) *_dev, e10k_smadarctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x14f10, _regval);
}

static inline void e10k_smadarctl_wr(__DN(t) *_dev, e10k_smadarctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_smadarctl_wr(__DN(t) *_dev, e10k_smadarctl_t _regval)
{
    _regval = (_regval & 0x1ffff);
    // No MB1 fields present
    _regval = (_regval | (0xfffe0000 & mackerel_read_addr_32(_dev->base, 0x14f10)));
    mackerel_write_addr_32(_dev->base, 0x14f10, _regval);
}

static inline int e10k_smadarctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_smadarctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_smadarctl_t _regval = mackerel_read_addr_32(_dev->base, 0x14f10);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register smadarctl (Core Common Configuration Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " data =\t%" PRIx8 "\t(Data to Core Analog Registers)\n", e10k_smadarctl_data_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " address =\t%" PRIx8 "\t(Address to Core Analog Registers)\n", e10k_smadarctl_address_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " latch_addr =\t%" PRIx8 "\t(Latch address)\n", e10k_smadarctl_latch_addr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon17 is anonymous
    return(_r);
}

static inline uint8_t e10k_smadarctl_data_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_smadarctl_data_rdf(__DN(t) *_dev)
{
    e10k_smadarctl_t _regval = mackerel_read_addr_32(_dev->base, 0x14f10);
    return(e10k_smadarctl_data_extract(_regval));
}

static inline uint8_t e10k_smadarctl_address_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_smadarctl_address_rdf(__DN(t) *_dev)
{
    e10k_smadarctl_t _regval = mackerel_read_addr_32(_dev->base, 0x14f10);
    return(e10k_smadarctl_address_extract(_regval));
}

static inline uint8_t e10k_smadarctl_latch_addr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_smadarctl_latch_addr_rdf(__DN(t) *_dev)
{
    e10k_smadarctl_t _regval = mackerel_read_addr_32(_dev->base, 0x14f10);
    return(e10k_smadarctl_latch_addr_extract(_regval));
}

static inline void e10k_smadarctl_data_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_smadarctl_data_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_smadarctl_t _regval = 0xff & (((e10k_smadarctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x14f10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14f10, _regval);
    // No shadow register to write to
}

static inline void e10k_smadarctl_address_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_smadarctl_address_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_smadarctl_t _regval = 0xff00 & (((e10k_smadarctl_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x14f10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14f10, _regval);
    // No shadow register to write to
}

static inline void e10k_smadarctl_latch_addr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_smadarctl_latch_addr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_smadarctl_t _regval = 0x10000 & (((e10k_smadarctl_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x14f10)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x14f10, _regval);
    // No shadow register to write to
}

/*
 * Register mflcn: MAC Flow Control Register
 * Type: e10k.mflcn (Implicit type of MAC Flow Control Register register)
 *   pmcf	(size 1, offset 0, init 0):	RW	Pass MAC Control Frames
 *   dpf	(size 1, offset 1, init 0):	RW	Discard Pause Frame
 *   rpfce	(size 1, offset 2, init 0):	RW	Receive Priority Flow Control Enable
 *   rfce	(size 1, offset 3, init 0):	RW	Receive Flow Control Enable
 *   _anon4	(size 28, offset 4, init 0):	RSVD	_
 */
static inline e10k_mflcn_t e10k_mflcn_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mflcn_t e10k_mflcn_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4294));
}

static inline e10k_mflcn_t e10k_mflcn_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mflcn_t e10k_mflcn_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4294));
}

static inline void e10k_mflcn_rawwr(__DN(t) *_dev, e10k_mflcn_t _regval) __attribute__ ((always_inline));
static inline void e10k_mflcn_rawwr(__DN(t) *_dev, e10k_mflcn_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4294, _regval);
}

static inline void e10k_mflcn_wr(__DN(t) *_dev, e10k_mflcn_t _regval) __attribute__ ((always_inline));
static inline void e10k_mflcn_wr(__DN(t) *_dev, e10k_mflcn_t _regval)
{
    _regval = (_regval & 0xf);
    // No MB1 fields present
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x4294)));
    mackerel_write_addr_32(_dev->base, 0x4294, _regval);
}

static inline int e10k_mflcn_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mflcn_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mflcn_t _regval = mackerel_read_addr_32(_dev->base, 0x4294);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mflcn (MAC Flow Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pmcf =\t%" PRIx8 "\t(Pass MAC Control Frames)\n", e10k_mflcn_pmcf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dpf =\t%" PRIx8 "\t(Discard Pause Frame)\n", e10k_mflcn_dpf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rpfce =\t%" PRIx8 "\t(Receive Priority Flow Control Enable)\n", e10k_mflcn_rpfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rfce =\t%" PRIx8 "\t(Receive Flow Control Enable)\n", e10k_mflcn_rfce_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    return(_r);
}

static inline uint8_t e10k_mflcn_pmcf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mflcn_pmcf_rdf(__DN(t) *_dev)
{
    e10k_mflcn_t _regval = mackerel_read_addr_32(_dev->base, 0x4294);
    return(e10k_mflcn_pmcf_extract(_regval));
}

static inline uint8_t e10k_mflcn_dpf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mflcn_dpf_rdf(__DN(t) *_dev)
{
    e10k_mflcn_t _regval = mackerel_read_addr_32(_dev->base, 0x4294);
    return(e10k_mflcn_dpf_extract(_regval));
}

static inline uint8_t e10k_mflcn_rpfce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mflcn_rpfce_rdf(__DN(t) *_dev)
{
    e10k_mflcn_t _regval = mackerel_read_addr_32(_dev->base, 0x4294);
    return(e10k_mflcn_rpfce_extract(_regval));
}

static inline uint8_t e10k_mflcn_rfce_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mflcn_rfce_rdf(__DN(t) *_dev)
{
    e10k_mflcn_t _regval = mackerel_read_addr_32(_dev->base, 0x4294);
    return(e10k_mflcn_rfce_extract(_regval));
}

static inline void e10k_mflcn_pmcf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mflcn_pmcf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mflcn_t _regval = 0x1 & (((e10k_mflcn_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x4294)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4294, _regval);
    // No shadow register to write to
}

static inline void e10k_mflcn_dpf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mflcn_dpf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mflcn_t _regval = 0x2 & (((e10k_mflcn_t )(_fieldval)) << 1);
    _regval = (_regval | (0xfffffffd & mackerel_read_addr_32(_dev->base, 0x4294)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4294, _regval);
    // No shadow register to write to
}

static inline void e10k_mflcn_rpfce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mflcn_rpfce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mflcn_t _regval = 0x4 & (((e10k_mflcn_t )(_fieldval)) << 2);
    _regval = (_regval | (0xfffffffb & mackerel_read_addr_32(_dev->base, 0x4294)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4294, _regval);
    // No shadow register to write to
}

static inline void e10k_mflcn_rfce_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mflcn_rfce_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mflcn_t _regval = 0x8 & (((e10k_mflcn_t )(_fieldval)) << 3);
    _regval = (_regval | (0xfffffff7 & mackerel_read_addr_32(_dev->base, 0x4294)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4294, _regval);
    // No shadow register to write to
}

/*
 * Register sgmiic: SGMII Control Register
 * Type: e10k.sgmiic (Implicit type of SGMII Control Register register)
 *   srxrassmp	(size 4, offset 0, init 0):	RW	Shift Rx Rate-Adapt Single Data Sampling
 *   srxrarsmp	(size 4, offset 4, init 0):	RW	Shift Rx Rate-Adapt Replicated Data Sampling
 *   stxrasmp	(size 4, offset 8, init 0):	RW	Shift Tx Rate-Adapt Sampling
 *   ansflu100	(size 1, offset 12, init 0):	RW	AN SGMII Force Link Up 100 Mb/s
 *   ansbyp	(size 1, offset 13, init 0):	RW	AN SGMII Bypass
 *   anstrig	(size 1, offset 14, init 0):	RW	AN SGMII Trigger
 *   anslnktmr	(size 1, offset 15, init 0):	RW	AN SGMII Link-Timer
 *   _anon16	(size 1, offset 16, init 0):	RSVD	_
 *   anignrrxrf	(size 1, offset 17, init 0):	RW	Auto-Negotiation Ignore Received RF Field
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
static inline e10k_sgmiic_t e10k_sgmiic_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4314));
}

static inline e10k_sgmiic_t e10k_sgmiic_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_sgmiic_t e10k_sgmiic_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4314));
}

static inline void e10k_sgmiic_rawwr(__DN(t) *_dev, e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_rawwr(__DN(t) *_dev, e10k_sgmiic_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
}

static inline void e10k_sgmiic_wr(__DN(t) *_dev, e10k_sgmiic_t _regval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_wr(__DN(t) *_dev, e10k_sgmiic_t _regval)
{
    _regval = (_regval & 0x2ffff);
    // No MB1 fields present
    _regval = (_regval | (0xfffd0000 & mackerel_read_addr_32(_dev->base, 0x4314)));
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
}

static inline int e10k_sgmiic_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_sgmiic_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register sgmiic (SGMII Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srxrassmp =\t%" PRIx8 "\t(Shift Rx Rate-Adapt Single Data Sampling)\n", e10k_sgmiic_srxrassmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " srxrarsmp =\t%" PRIx8 "\t(Shift Rx Rate-Adapt Replicated Data Sampling)\n", e10k_sgmiic_srxrarsmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " stxrasmp =\t%" PRIx8 "\t(Shift Tx Rate-Adapt Sampling)\n", e10k_sgmiic_stxrasmp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ansflu100 =\t%" PRIx8 "\t(AN SGMII Force Link Up 100 Mb/s)\n", e10k_sgmiic_ansflu100_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ansbyp =\t%" PRIx8 "\t(AN SGMII Bypass)\n", e10k_sgmiic_ansbyp_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anstrig =\t%" PRIx8 "\t(AN SGMII Trigger)\n", e10k_sgmiic_anstrig_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anslnktmr =\t%" PRIx8 "\t(AN SGMII Link-Timer)\n", e10k_sgmiic_anslnktmr_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " anignrrxrf =\t%" PRIx8 "\t(Auto-Negotiation Ignore Received RF Field)\n", e10k_sgmiic_anignrrxrf_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline uint8_t e10k_sgmiic_srxrassmp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_srxrassmp_rdf(__DN(t) *_dev)
{
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    return(e10k_sgmiic_srxrassmp_extract(_regval));
}

static inline uint8_t e10k_sgmiic_srxrarsmp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_srxrarsmp_rdf(__DN(t) *_dev)
{
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    return(e10k_sgmiic_srxrarsmp_extract(_regval));
}

static inline uint8_t e10k_sgmiic_stxrasmp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_stxrasmp_rdf(__DN(t) *_dev)
{
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    return(e10k_sgmiic_stxrasmp_extract(_regval));
}

static inline uint8_t e10k_sgmiic_ansflu100_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_ansflu100_rdf(__DN(t) *_dev)
{
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    return(e10k_sgmiic_ansflu100_extract(_regval));
}

static inline uint8_t e10k_sgmiic_ansbyp_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_ansbyp_rdf(__DN(t) *_dev)
{
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    return(e10k_sgmiic_ansbyp_extract(_regval));
}

static inline uint8_t e10k_sgmiic_anstrig_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_anstrig_rdf(__DN(t) *_dev)
{
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    return(e10k_sgmiic_anstrig_extract(_regval));
}

static inline uint8_t e10k_sgmiic_anslnktmr_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_anslnktmr_rdf(__DN(t) *_dev)
{
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    return(e10k_sgmiic_anslnktmr_extract(_regval));
}

static inline uint8_t e10k_sgmiic_anignrrxrf_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_sgmiic_anignrrxrf_rdf(__DN(t) *_dev)
{
    e10k_sgmiic_t _regval = mackerel_read_addr_32(_dev->base, 0x4314);
    return(e10k_sgmiic_anignrrxrf_extract(_regval));
}

static inline void e10k_sgmiic_srxrassmp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_srxrassmp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_sgmiic_t _regval = 0xf & (((e10k_sgmiic_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x4314)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
    // No shadow register to write to
}

static inline void e10k_sgmiic_srxrarsmp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_srxrarsmp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_sgmiic_t _regval = 0xf0 & (((e10k_sgmiic_t )(_fieldval)) << 4);
    _regval = (_regval | (0xffffff0f & mackerel_read_addr_32(_dev->base, 0x4314)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
    // No shadow register to write to
}

static inline void e10k_sgmiic_stxrasmp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_stxrasmp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_sgmiic_t _regval = 0xf00 & (((e10k_sgmiic_t )(_fieldval)) << 8);
    _regval = (_regval | (0xfffff0ff & mackerel_read_addr_32(_dev->base, 0x4314)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
    // No shadow register to write to
}

static inline void e10k_sgmiic_ansflu100_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_ansflu100_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_sgmiic_t _regval = 0x1000 & (((e10k_sgmiic_t )(_fieldval)) << 12);
    _regval = (_regval | (0xffffefff & mackerel_read_addr_32(_dev->base, 0x4314)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
    // No shadow register to write to
}

static inline void e10k_sgmiic_ansbyp_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_ansbyp_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_sgmiic_t _regval = 0x2000 & (((e10k_sgmiic_t )(_fieldval)) << 13);
    _regval = (_regval | (0xffffdfff & mackerel_read_addr_32(_dev->base, 0x4314)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
    // No shadow register to write to
}

static inline void e10k_sgmiic_anstrig_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_anstrig_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_sgmiic_t _regval = 0x4000 & (((e10k_sgmiic_t )(_fieldval)) << 14);
    _regval = (_regval | (0xffffbfff & mackerel_read_addr_32(_dev->base, 0x4314)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
    // No shadow register to write to
}

static inline void e10k_sgmiic_anslnktmr_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_anslnktmr_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_sgmiic_t _regval = 0x8000 & (((e10k_sgmiic_t )(_fieldval)) << 15);
    _regval = (_regval | (0xffff7fff & mackerel_read_addr_32(_dev->base, 0x4314)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
    // No shadow register to write to
}

static inline void e10k_sgmiic_anignrrxrf_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_sgmiic_anignrrxrf_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_sgmiic_t _regval = 0x20000 & (((e10k_sgmiic_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x4314)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x4314, _regval);
    // No shadow register to write to
}

/*
 * Register crcerrs: CRC Error Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_crcerrs_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_crcerrs_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4000));
}

static inline uint32_t e10k_crcerrs_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_crcerrs_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4000));
}

static inline void e10k_crcerrs_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_crcerrs_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4000, _regval);
}

// Register crcerrs is not writeable
static inline int e10k_crcerrs_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_crcerrs_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4000);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register crcerrs (CRC Error Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register illerrc: Illegal Byte Error Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_illerrc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_illerrc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4004));
}

static inline uint32_t e10k_illerrc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_illerrc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4004));
}

static inline void e10k_illerrc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_illerrc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4004, _regval);
}

// Register illerrc is not writeable
static inline int e10k_illerrc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_illerrc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4004);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register illerrc (Illegal Byte Error Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register errbc: Error Byte Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_errbc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_errbc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4008));
}

static inline uint32_t e10k_errbc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_errbc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4008));
}

static inline void e10k_errbc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_errbc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4008, _regval);
}

// Register errbc is not writeable
static inline int e10k_errbc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_errbc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4008);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register errbc (Error Byte Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register array rxmpc: Rx Missed Packets Count
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_rxmpc_length = 8;
static inline uint32_t e10k_rxmpc_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rxmpc_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3fa0 + (_i * (32 / 8))));
}

static inline uint32_t e10k_rxmpc_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_rxmpc_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x3fa0 + (_i * (32 / 8))));
}

static inline void e10k_rxmpc_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxmpc_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x3fa0 + (_i * (32 / 8)), _regval);
}

// Register rxmpc is not writeable
static inline int e10k_rxmpc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_rxmpc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x3fa0 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "rxmpc", _i, "Rx Missed Packets Count");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_rxmpc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxmpc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_rxmpc_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register mlfc: MAC Local fault count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_mlfc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mlfc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4034));
}

static inline uint32_t e10k_mlfc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mlfc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4034));
}

static inline void e10k_mlfc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mlfc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4034, _regval);
}

// Register mlfc is not writeable
static inline int e10k_mlfc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mlfc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4034);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mlfc (MAC Local fault count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mrfc: MAC Remote fault count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_mrfc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mrfc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4038));
}

static inline uint32_t e10k_mrfc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mrfc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4038));
}

static inline void e10k_mrfc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mrfc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4038, _regval);
}

// Register mrfc is not writeable
static inline int e10k_mrfc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mrfc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4038);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mrfc (MAC Remote fault count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rlec: Receive Length Error Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_rlec_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rlec_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4040));
}

static inline uint32_t e10k_rlec_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rlec_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4040));
}

static inline void e10k_rlec_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rlec_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4040, _regval);
}

// Register rlec is not writeable
static inline int e10k_rlec_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rlec_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4040);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rlec (Receive Length Error Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register gprc: Good packets recieved count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_gprc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_gprc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4074));
}

static inline uint32_t e10k_gprc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_gprc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4074));
}

static inline void e10k_gprc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_gprc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4074, _regval);
}

// Register gprc is not writeable
static inline int e10k_gprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4074);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gprc (Good packets recieved count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rxnfgpc: Good Rx Non-Filtered Packet Counter
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_rxnfgpc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rxnfgpc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x41b0));
}

static inline uint32_t e10k_rxnfgpc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rxnfgpc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x41b0));
}

static inline void e10k_rxnfgpc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxnfgpc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x41b0, _regval);
}

// Register rxnfgpc is not writeable
static inline int e10k_rxnfgpc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxnfgpc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x41b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxnfgpc (Good Rx Non-Filtered Packet Counter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rxdgpc: DMA Good Rx Packet Counter
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_rxdgpc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rxdgpc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f50));
}

static inline uint32_t e10k_rxdgpc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rxdgpc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f50));
}

static inline void e10k_rxdgpc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rxdgpc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2f50, _regval);
}

// Register rxdgpc is not writeable
static inline int e10k_rxdgpc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rxdgpc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x2f50);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rxdgpc (DMA Good Rx Packet Counter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register gptc: Good packets trasmitted count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_gptc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_gptc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4080));
}

static inline uint32_t e10k_gptc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_gptc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4080));
}

static inline void e10k_gptc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_gptc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4080, _regval);
}

// Register gptc is not writeable
static inline int e10k_gptc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_gptc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4080);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register gptc (Good packets trasmitted count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register txdgpc: DMA Good Tx Packet Counter
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_txdgpc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_txdgpc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x87a0));
}

static inline uint32_t e10k_txdgpc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_txdgpc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x87a0));
}

static inline void e10k_txdgpc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_txdgpc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x87a0, _regval);
}

// Register txdgpc is not writeable
static inline int e10k_txdgpc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_txdgpc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x87a0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register txdgpc (DMA Good Tx Packet Counter): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register ruc: Receive Undersize Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_ruc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_ruc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a4));
}

static inline uint32_t e10k_ruc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_ruc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a4));
}

static inline void e10k_ruc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_ruc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40a4, _regval);
}

// Register ruc is not writeable
static inline int e10k_ruc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_ruc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40a4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register ruc (Receive Undersize Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rfc: Receive Fragment Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_rfc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rfc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a8));
}

static inline uint32_t e10k_rfc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rfc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40a8));
}

static inline void e10k_rfc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rfc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40a8, _regval);
}

// Register rfc is not writeable
static inline int e10k_rfc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rfc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40a8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rfc (Receive Fragment Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register roc: Receive Oversize Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_roc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_roc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40ac));
}

static inline uint32_t e10k_roc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_roc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40ac));
}

static inline void e10k_roc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_roc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40ac, _regval);
}

// Register roc is not writeable
static inline int e10k_roc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_roc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40ac);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register roc (Receive Oversize Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register rjc: Receive Jabber Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_rjc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rjc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b0));
}

static inline uint32_t e10k_rjc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_rjc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b0));
}

static inline void e10k_rjc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_rjc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40b0, _regval);
}

// Register rjc is not writeable
static inline int e10k_rjc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_rjc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register rjc (Receive Jabber Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mngprc: Management Packets Received Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_mngprc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mngprc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b4));
}

static inline uint32_t e10k_mngprc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mngprc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b4));
}

static inline void e10k_mngprc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mngprc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40b4, _regval);
}

// Register mngprc is not writeable
static inline int e10k_mngprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mngprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40b4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mngprc (Management Packets Received Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mngpdc: Management Packets Dropped Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_mngpdc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mngpdc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b8));
}

static inline uint32_t e10k_mngpdc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mngpdc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40b8));
}

static inline void e10k_mngpdc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mngpdc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40b8, _regval);
}

// Register mngpdc is not writeable
static inline int e10k_mngpdc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mngpdc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40b8);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mngpdc (Management Packets Dropped Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tpr: Total Packets Recieved
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_tpr_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_tpr_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d0));
}

static inline uint32_t e10k_tpr_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_tpr_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d0));
}

static inline void e10k_tpr_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tpr_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40d0, _regval);
}

// Register tpr is not writeable
static inline int e10k_tpr_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tpr_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40d0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tpr (Total Packets Recieved): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register tpt: Total Packets Transmitted
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_tpt_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_tpt_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d4));
}

static inline uint32_t e10k_tpt_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_tpt_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x40d4));
}

static inline void e10k_tpt_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_tpt_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x40d4, _regval);
}

// Register tpt is not writeable
static inline int e10k_tpt_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_tpt_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x40d4);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register tpt (Total Packets Transmitted): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register mspdc: MAC Short Packet Discard Count
 * Type: e10k.uint32 (primitive type)
 */
static inline uint32_t e10k_mspdc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mspdc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4010));
}

static inline uint32_t e10k_mspdc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint32_t e10k_mspdc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x4010));
}

static inline void e10k_mspdc_rawwr(__DN(t) *_dev, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mspdc_rawwr(__DN(t) *_dev, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x4010, _regval);
}

// Register mspdc is not writeable
static inline int e10k_mspdc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mspdc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x4010);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mspdc (MAC Short Packet Discard Count): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

/*
 * Register array qprc: Queue Packets Received Count
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_qprc_length = 16;
static inline uint32_t e10k_qprc_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_qprc_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1030 + (_i * 64)));
}

static inline uint32_t e10k_qprc_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_qprc_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1030 + (_i * 64)));
}

static inline void e10k_qprc_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_qprc_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1030 + (_i * 64), _regval);
}

// Register qprc is not writeable
static inline int e10k_qprc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_qprc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1030 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "qprc", _i, "Queue Packets Received Count");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_qprc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_qprc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 16; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_qprc_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array qprdc: Queue Packets Received Drop Count
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_qprdc_length = 16;
static inline uint32_t e10k_qprdc_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_qprdc_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1430 + (_i * 64)));
}

static inline uint32_t e10k_qprdc_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_qprdc_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x1430 + (_i * 64)));
}

static inline void e10k_qprdc_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_qprdc_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x1430 + (_i * 64), _regval);
}

// Register qprdc is not writeable
static inline int e10k_qprdc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_qprdc_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x1430 + (_i * 64));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "qprdc", _i, "Queue Packets Received Drop Count");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_qprdc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_qprdc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 16; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_qprdc_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array fhft_1: Flexible Host Filter Table Registers 0-3
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_fhft_1_length = 128;
static inline uint32_t e10k_fhft_1_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_fhft_1_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9000 + (_i * (32 / 8))));
}

static inline uint32_t e10k_fhft_1_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_fhft_1_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9000 + (_i * (32 / 8))));
}

static inline void e10k_fhft_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_fhft_1_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9000 + (_i * (32 / 8)), _regval);
}

static inline void e10k_fhft_1_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_fhft_1_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9000 + (_i * (32 / 8)), _regval);
}

static inline int e10k_fhft_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_fhft_1_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x9000 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fhft_1", _i, "Flexible Host Filter Table Registers 0-3");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_fhft_1_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fhft_1_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_fhft_1_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array fhft_2: Flexible Host Filter Table Registers 4-5
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_fhft_2_length = 64;
static inline uint32_t e10k_fhft_2_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_fhft_2_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9800 + (_i * (32 / 8))));
}

static inline uint32_t e10k_fhft_2_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_fhft_2_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x9800 + (_i * (32 / 8))));
}

static inline void e10k_fhft_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_fhft_2_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x9800 + (_i * (32 / 8)), _regval);
}

static inline void e10k_fhft_2_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_fhft_2_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x9800 + (_i * (32 / 8)), _regval);
}

static inline int e10k_fhft_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_fhft_2_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x9800 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "fhft_2", _i, "Flexible Host Filter Table Registers 4-5");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_fhft_2_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_fhft_2_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_fhft_2_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array mavtv: Management VLAN TAG Value
 * Type: e10k.mavtv (Implicit type of Management VLAN TAG Value register array)
 *   vid	(size 12, offset 0, init 0):	RW	VLAN ID that should be compared with incoming packet
 *   _anon12	(size 20, offset 12, init 0):	RSVD	_
 */
static const size_t e10k_mavtv_length = 8;
static inline e10k_mavtv_t e10k_mavtv_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_mavtv_t e10k_mavtv_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5010 + (_i * (32 / 8))));
}

static inline e10k_mavtv_t e10k_mavtv_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_mavtv_t e10k_mavtv_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5010 + (_i * (32 / 8))));
}

static inline void e10k_mavtv_rawwr(__DN(t) *_dev, int _i, e10k_mavtv_t _regval) __attribute__ ((always_inline));
static inline void e10k_mavtv_rawwr(__DN(t) *_dev, int _i, e10k_mavtv_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5010 + (_i * (32 / 8)), _regval);
}

static inline void e10k_mavtv_wr(__DN(t) *_dev, int _i, e10k_mavtv_t _regval) __attribute__ ((always_inline));
static inline void e10k_mavtv_wr(__DN(t) *_dev, int _i, e10k_mavtv_t _regval)
{
    _regval = (_regval & 0xfff);
    // No MB1 fields present
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x5010 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x5010 + (_i * (32 / 8)), _regval);
}

static inline int e10k_mavtv_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_mavtv_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mavtv_t _regval = mackerel_read_addr_32(_dev->base, 0x5010 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mavtv", _i, "Management VLAN TAG Value");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vid =\t%" PRIx16 "\t(VLAN ID that should be compared with incoming packet)\n", e10k_mavtv_vid_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    return(_r);
}

static inline int e10k_mavtv_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mavtv_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_mavtv_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_mavtv_vid_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_mavtv_vid_rdf(__DN(t) *_dev, int _i)
{
    e10k_mavtv_t _regval = mackerel_read_addr_32(_dev->base, 0x5010 + (_i * (32 / 8)));
    return(e10k_mavtv_vid_extract(_regval));
}

static inline void e10k_mavtv_vid_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mavtv_vid_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_mavtv_t _regval = 0xfff & (((e10k_mavtv_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0x5010 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5010 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array mfutp: Management Flex UDP/TP Ports
 * Type: e10k.mfutp (Implicit type of Management Flex UDP/TP Ports register array)
 *   mfutp_1	(size 16, offset 0, init 0):	RW	VLAN ID that should be compared with incoming packet
 *   mfutp_2	(size 16, offset 16, init 0):	RW	VLAN ID that should be compared with incoming packet
 */
static const size_t e10k_mfutp_length = 8;
static inline e10k_mfutp_t e10k_mfutp_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_mfutp_t e10k_mfutp_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5030 + (_i * (32 / 8))));
}

static inline e10k_mfutp_t e10k_mfutp_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_mfutp_t e10k_mfutp_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5030 + (_i * (32 / 8))));
}

static inline void e10k_mfutp_rawwr(__DN(t) *_dev, int _i, e10k_mfutp_t _regval) __attribute__ ((always_inline));
static inline void e10k_mfutp_rawwr(__DN(t) *_dev, int _i, e10k_mfutp_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)), _regval);
}

static inline void e10k_mfutp_wr(__DN(t) *_dev, int _i, e10k_mfutp_t _regval) __attribute__ ((always_inline));
static inline void e10k_mfutp_wr(__DN(t) *_dev, int _i, e10k_mfutp_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)), _regval);
}

static inline int e10k_mfutp_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_mfutp_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mfutp_t _regval = mackerel_read_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mfutp", _i, "Management Flex UDP/TP Ports");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mfutp_1 =\t%" PRIx16 "\t(VLAN ID that should be compared with incoming packet)\n", e10k_mfutp_mfutp_1_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mfutp_2 =\t%" PRIx16 "\t(VLAN ID that should be compared with incoming packet)\n", e10k_mfutp_mfutp_2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_mfutp_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mfutp_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_mfutp_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_mfutp_mfutp_1_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_mfutp_mfutp_1_rdf(__DN(t) *_dev, int _i)
{
    e10k_mfutp_t _regval = mackerel_read_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)));
    return(e10k_mfutp_mfutp_1_extract(_regval));
}

static inline uint16_t e10k_mfutp_mfutp_2_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_mfutp_mfutp_2_rdf(__DN(t) *_dev, int _i)
{
    e10k_mfutp_t _regval = mackerel_read_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)));
    return(e10k_mfutp_mfutp_2_extract(_regval));
}

static inline void e10k_mfutp_mfutp_1_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mfutp_mfutp_1_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_mfutp_t _regval = 0xffff & (((e10k_mfutp_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_mfutp_mfutp_2_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mfutp_mfutp_2_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_mfutp_t _regval = 0xffff0000 & (((e10k_mfutp_t )(_fieldval)) << 16);
    _regval = (_regval | (0xffff & mackerel_read_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5030 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array metf: Management Ethernet Type Filter
 * Type: e10k.metf (Implicit type of Management Ethernet Type Filter register array)
 *   etype	(size 16, offset 0, init 0):	RW	EtherType value to be compared with incoming packet
 *   _anon16	(size 14, offset 16, init 0):	RSVD	_
 *   polarity	(size 1, offset 30, init 0):	RW	Negative filter
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static const size_t e10k_metf_length = 4;
static inline e10k_metf_t e10k_metf_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_metf_t e10k_metf_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5190 + (_i * (32 / 8))));
}

static inline e10k_metf_t e10k_metf_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_metf_t e10k_metf_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5190 + (_i * (32 / 8))));
}

static inline void e10k_metf_rawwr(__DN(t) *_dev, int _i, e10k_metf_t _regval) __attribute__ ((always_inline));
static inline void e10k_metf_rawwr(__DN(t) *_dev, int _i, e10k_metf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)), _regval);
}

static inline void e10k_metf_wr(__DN(t) *_dev, int _i, e10k_metf_t _regval) __attribute__ ((always_inline));
static inline void e10k_metf_wr(__DN(t) *_dev, int _i, e10k_metf_t _regval)
{
    _regval = (_regval & 0x4000ffff);
    // No MB1 fields present
    _regval = (_regval | (0xbfff0000 & mackerel_read_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)), _regval);
}

static inline int e10k_metf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_metf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_metf_t _regval = mackerel_read_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "metf", _i, "Management Ethernet Type Filter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " etype =\t%" PRIx16 "\t(EtherType value to be compared with incoming packet)\n", e10k_metf_etype_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon16 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " polarity =\t%" PRIx8 "\t(Negative filter)\n", e10k_metf_polarity_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline int e10k_metf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_metf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 4; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_metf_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_metf_etype_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_metf_etype_rdf(__DN(t) *_dev, int _i)
{
    e10k_metf_t _regval = mackerel_read_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)));
    return(e10k_metf_etype_extract(_regval));
}

static inline uint8_t e10k_metf_polarity_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_metf_polarity_rdf(__DN(t) *_dev, int _i)
{
    e10k_metf_t _regval = mackerel_read_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)));
    return(e10k_metf_polarity_extract(_regval));
}

static inline void e10k_metf_etype_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_metf_etype_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_metf_t _regval = 0xffff & (((e10k_metf_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffff0000 & mackerel_read_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_metf_polarity_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_metf_polarity_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_metf_t _regval = 0x40000000 & (((e10k_metf_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5190 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register manc: Management Control Register
 * Type: e10k.manc (Implicit type of Management Control Register register)
 *   _anon0	(size 17, offset 0, init 0):	RSVD	_
 *   rcv_tco_en	(size 1, offset 17, init 0):	RW	Receive TCO Packets Enabled
 *   _anon18	(size 1, offset 18, init 0):	RSVD	_
 *   rcv_all	(size 1, offset 19, init 0):	RW	Receive All Enable
 *   mcst_pl2	(size 1, offset 20, init 0):	RW	Receive All Multicast
 *   en_m2h	(size 1, offset 21, init 0):	RW	Enable manageability packets to host memory
 *   bp_vlan	(size 1, offset 22, init 0):	RW	VLAN filtering is bypassed for MNG packets
 *   en_xsum_flt	(size 1, offset 23, init 0):	RW	When set, this bit enables Xsum filtering to manageability
 *   en_ipv4_flt	(size 1, offset 24, init 0):	RW	Enable IPv4 address Filters
 *   fixed_net_t	(size 1, offset 25, init 0):	RW	Fixed next type
 *   net_type	(size 1, offset 26, init 0):	RW	Pass only VLAN tagged packets
 *   _anon27	(size 5, offset 27, init 0):	RSVD	_
 */
static inline e10k_manc_t e10k_manc_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5820));
}

static inline e10k_manc_t e10k_manc_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_manc_t e10k_manc_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5820));
}

static inline void e10k_manc_rawwr(__DN(t) *_dev, e10k_manc_t _regval) __attribute__ ((always_inline));
static inline void e10k_manc_rawwr(__DN(t) *_dev, e10k_manc_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
}

static inline void e10k_manc_wr(__DN(t) *_dev, e10k_manc_t _regval) __attribute__ ((always_inline));
static inline void e10k_manc_wr(__DN(t) *_dev, e10k_manc_t _regval)
{
    _regval = (_regval & 0x7fa0000);
    // No MB1 fields present
    _regval = (_regval | (0xf805ffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
}

static inline int e10k_manc_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_manc_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register manc (Management Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon0 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcv_tco_en =\t%" PRIx8 "\t(Receive TCO Packets Enabled)\n", e10k_manc_rcv_tco_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rcv_all =\t%" PRIx8 "\t(Receive All Enable)\n", e10k_manc_rcv_all_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mcst_pl2 =\t%" PRIx8 "\t(Receive All Multicast)\n", e10k_manc_mcst_pl2_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_m2h =\t%" PRIx8 "\t(Enable manageability packets to host memory)\n", e10k_manc_en_m2h_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bp_vlan =\t%" PRIx8 "\t(VLAN filtering is bypassed for MNG packets)\n", e10k_manc_bp_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_xsum_flt =\t%" PRIx8 "\t(When set, this bit enables Xsum filtering to manageability)\n", e10k_manc_en_xsum_flt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " en_ipv4_flt =\t%" PRIx8 "\t(Enable IPv4 address Filters)\n", e10k_manc_en_ipv4_flt_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " fixed_net_t =\t%" PRIx8 "\t(Fixed next type)\n", e10k_manc_fixed_net_t_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " net_type =\t%" PRIx8 "\t(Pass only VLAN tagged packets)\n", e10k_manc_net_type_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon27 is anonymous
    return(_r);
}

static inline uint8_t e10k_manc_rcv_tco_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_rcv_tco_en_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_rcv_tco_en_extract(_regval));
}

static inline uint8_t e10k_manc_rcv_all_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_rcv_all_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_rcv_all_extract(_regval));
}

static inline uint8_t e10k_manc_mcst_pl2_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_mcst_pl2_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_mcst_pl2_extract(_regval));
}

static inline uint8_t e10k_manc_en_m2h_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_en_m2h_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_en_m2h_extract(_regval));
}

static inline uint8_t e10k_manc_bp_vlan_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_bp_vlan_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_bp_vlan_extract(_regval));
}

static inline uint8_t e10k_manc_en_xsum_flt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_en_xsum_flt_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_en_xsum_flt_extract(_regval));
}

static inline uint8_t e10k_manc_en_ipv4_flt_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_en_ipv4_flt_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_en_ipv4_flt_extract(_regval));
}

static inline uint8_t e10k_manc_fixed_net_t_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_fixed_net_t_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_fixed_net_t_extract(_regval));
}

static inline uint8_t e10k_manc_net_type_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc_net_type_rdf(__DN(t) *_dev)
{
    e10k_manc_t _regval = mackerel_read_addr_32(_dev->base, 0x5820);
    return(e10k_manc_net_type_extract(_regval));
}

static inline void e10k_manc_rcv_tco_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_rcv_tco_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x20000 & (((e10k_manc_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e10k_manc_rcv_all_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_rcv_all_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x80000 & (((e10k_manc_t )(_fieldval)) << 19);
    _regval = (_regval | (0xfff7ffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e10k_manc_mcst_pl2_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_mcst_pl2_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x100000 & (((e10k_manc_t )(_fieldval)) << 20);
    _regval = (_regval | (0xffefffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e10k_manc_en_m2h_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_en_m2h_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x200000 & (((e10k_manc_t )(_fieldval)) << 21);
    _regval = (_regval | (0xffdfffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e10k_manc_bp_vlan_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_bp_vlan_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x400000 & (((e10k_manc_t )(_fieldval)) << 22);
    _regval = (_regval | (0xffbfffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e10k_manc_en_xsum_flt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_en_xsum_flt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x800000 & (((e10k_manc_t )(_fieldval)) << 23);
    _regval = (_regval | (0xff7fffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e10k_manc_en_ipv4_flt_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_en_ipv4_flt_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x1000000 & (((e10k_manc_t )(_fieldval)) << 24);
    _regval = (_regval | (0xfeffffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e10k_manc_fixed_net_t_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_fixed_net_t_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x2000000 & (((e10k_manc_t )(_fieldval)) << 25);
    _regval = (_regval | (0xfdffffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

static inline void e10k_manc_net_type_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc_net_type_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc_t _regval = 0x4000000 & (((e10k_manc_t )(_fieldval)) << 26);
    _regval = (_regval | (0xfbffffff & mackerel_read_addr_32(_dev->base, 0x5820)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5820, _regval);
    // No shadow register to write to
}

/*
 * Register mfval: Manageability Filters Valid
 * Type: e10k.mfval (Implicit type of Manageability Filters Valid register)
 *   mac	(size 4, offset 0, init 0):	RW	Indicates if the MAC unicast filters contain valid MAC addresses
 *   _anon4	(size 4, offset 4, init 0):	RSVD	_
 *   vlan	(size 8, offset 8, init 0):	RW	VLAN filter registers contain valid VLAN tags
 *   ipv4	(size 4, offset 16, init 0):	RW	IPv4 address filters contain valid addresses
 *   _anon20	(size 4, offset 20, init 0):	RSVD	_
 *   ipv6	(size 4, offset 24, init 0):	RW	IPv6 address filters contain valid addresses
 *   _anon28	(size 4, offset 28, init 0):	RSVD	_
 */
static inline e10k_mfval_t e10k_mfval_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mfval_t e10k_mfval_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5824));
}

static inline e10k_mfval_t e10k_mfval_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_mfval_t e10k_mfval_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5824));
}

static inline void e10k_mfval_rawwr(__DN(t) *_dev, e10k_mfval_t _regval) __attribute__ ((always_inline));
static inline void e10k_mfval_rawwr(__DN(t) *_dev, e10k_mfval_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5824, _regval);
}

static inline void e10k_mfval_wr(__DN(t) *_dev, e10k_mfval_t _regval) __attribute__ ((always_inline));
static inline void e10k_mfval_wr(__DN(t) *_dev, e10k_mfval_t _regval)
{
    _regval = (_regval & 0xf0fff0f);
    // No MB1 fields present
    _regval = (_regval | (0xf0f000f0 & mackerel_read_addr_32(_dev->base, 0x5824)));
    mackerel_write_addr_32(_dev->base, 0x5824, _regval);
}

static inline int e10k_mfval_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mfval_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_mfval_t _regval = mackerel_read_addr_32(_dev->base, 0x5824);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register mfval (Manageability Filters Valid): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " mac =\t%" PRIx8 "\t(Indicates if the MAC unicast filters contain valid MAC addresses)\n", e10k_mfval_mac_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon4 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan =\t%" PRIx8 "\t(VLAN filter registers contain valid VLAN tags)\n", e10k_mfval_vlan_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv4 =\t%" PRIx8 "\t(IPv4 address filters contain valid addresses)\n", e10k_mfval_ipv4_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon20 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " ipv6 =\t%" PRIx8 "\t(IPv6 address filters contain valid addresses)\n", e10k_mfval_ipv6_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon28 is anonymous
    return(_r);
}

static inline uint8_t e10k_mfval_mac_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mfval_mac_rdf(__DN(t) *_dev)
{
    e10k_mfval_t _regval = mackerel_read_addr_32(_dev->base, 0x5824);
    return(e10k_mfval_mac_extract(_regval));
}

static inline uint8_t e10k_mfval_vlan_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mfval_vlan_rdf(__DN(t) *_dev)
{
    e10k_mfval_t _regval = mackerel_read_addr_32(_dev->base, 0x5824);
    return(e10k_mfval_vlan_extract(_regval));
}

static inline uint8_t e10k_mfval_ipv4_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mfval_ipv4_rdf(__DN(t) *_dev)
{
    e10k_mfval_t _regval = mackerel_read_addr_32(_dev->base, 0x5824);
    return(e10k_mfval_ipv4_extract(_regval));
}

static inline uint8_t e10k_mfval_ipv6_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_mfval_ipv6_rdf(__DN(t) *_dev)
{
    e10k_mfval_t _regval = mackerel_read_addr_32(_dev->base, 0x5824);
    return(e10k_mfval_ipv6_extract(_regval));
}

static inline void e10k_mfval_mac_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mfval_mac_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mfval_t _regval = 0xf & (((e10k_mfval_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffff0 & mackerel_read_addr_32(_dev->base, 0x5824)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5824, _regval);
    // No shadow register to write to
}

static inline void e10k_mfval_vlan_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mfval_vlan_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mfval_t _regval = 0xff00 & (((e10k_mfval_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff00ff & mackerel_read_addr_32(_dev->base, 0x5824)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5824, _regval);
    // No shadow register to write to
}

static inline void e10k_mfval_ipv4_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mfval_ipv4_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mfval_t _regval = 0xf0000 & (((e10k_mfval_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfff0ffff & mackerel_read_addr_32(_dev->base, 0x5824)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5824, _regval);
    // No shadow register to write to
}

static inline void e10k_mfval_ipv6_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_mfval_ipv6_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_mfval_t _regval = 0xf000000 & (((e10k_mfval_t )(_fieldval)) << 24);
    _regval = (_regval | (0xf0ffffff & mackerel_read_addr_32(_dev->base, 0x5824)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5824, _regval);
    // No shadow register to write to
}

/*
 * Register manc2h: Management Control To Host Register
 * Type: e10k.manc2h (Implicit type of Management Control To Host Register register)
 *   host_en	(size 8, offset 0, init 0):	RW	Host Enable
 *   _anon8	(size 24, offset 8, init 0):	RSVD	_
 */
static inline e10k_manc2h_t e10k_manc2h_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_manc2h_t e10k_manc2h_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5860));
}

static inline e10k_manc2h_t e10k_manc2h_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_manc2h_t e10k_manc2h_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x5860));
}

static inline void e10k_manc2h_rawwr(__DN(t) *_dev, e10k_manc2h_t _regval) __attribute__ ((always_inline));
static inline void e10k_manc2h_rawwr(__DN(t) *_dev, e10k_manc2h_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5860, _regval);
}

static inline void e10k_manc2h_wr(__DN(t) *_dev, e10k_manc2h_t _regval) __attribute__ ((always_inline));
static inline void e10k_manc2h_wr(__DN(t) *_dev, e10k_manc2h_t _regval)
{
    _regval = (_regval & 0xff);
    // No MB1 fields present
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x5860)));
    mackerel_write_addr_32(_dev->base, 0x5860, _regval);
}

static inline int e10k_manc2h_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_manc2h_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_manc2h_t _regval = mackerel_read_addr_32(_dev->base, 0x5860);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register manc2h (Management Control To Host Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " host_en =\t%" PRIx8 "\t(Host Enable)\n", e10k_manc2h_host_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon8 is anonymous
    return(_r);
}

static inline uint8_t e10k_manc2h_host_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_manc2h_host_en_rdf(__DN(t) *_dev)
{
    e10k_manc2h_t _regval = mackerel_read_addr_32(_dev->base, 0x5860);
    return(e10k_manc2h_host_en_extract(_regval));
}

static inline void e10k_manc2h_host_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_manc2h_host_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_manc2h_t _regval = 0xff & (((e10k_manc2h_t )(_fieldval)) << 0);
    _regval = (_regval | (0xffffff00 & mackerel_read_addr_32(_dev->base, 0x5860)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x5860, _regval);
    // No shadow register to write to
}

/*
 * Register array mdef: Manageability Decision Filters
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_mdef_length = 8;
static inline uint32_t e10k_mdef_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_mdef_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5890 + (_i * (32 / 8))));
}

static inline uint32_t e10k_mdef_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_mdef_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5890 + (_i * (32 / 8))));
}

static inline void e10k_mdef_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mdef_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5890 + (_i * (32 / 8)), _regval);
}

static inline void e10k_mdef_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mdef_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5890 + (_i * (32 / 8)), _regval);
}

static inline int e10k_mdef_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_mdef_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5890 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mdef", _i, "Manageability Decision Filters");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_mdef_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mdef_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_mdef_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register array mdef_ext: Manageability Decision Filters
 * Type: e10k.uint32 (primitive type)
 */
static const size_t e10k_mdef_ext_length = 8;
static inline uint32_t e10k_mdef_ext_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_mdef_ext_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5160 + (_i * (32 / 8))));
}

static inline uint32_t e10k_mdef_ext_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_mdef_ext_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0x5160 + (_i * (32 / 8))));
}

static inline void e10k_mdef_ext_rawwr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mdef_ext_rawwr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x5160 + (_i * (32 / 8)), _regval);
}

static inline void e10k_mdef_ext_wr(__DN(t) *_dev, int _i, uint32_t _regval) __attribute__ ((always_inline));
static inline void e10k_mdef_ext_wr(__DN(t) *_dev, int _i, uint32_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0x5160 + (_i * (32 / 8)), _regval);
}

static inline int e10k_mdef_ext_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_mdef_ext_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    uint32_t _regval = mackerel_read_addr_32(_dev->base, 0x5160 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "mdef_ext", _i, "Manageability Decision Filters");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\t%" PRIx32 "\n", _regval);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_mdef_ext_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_mdef_ext_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 8; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_mdef_ext_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

/*
 * Register pfvtctl: VT Control Register
 * Type: e10k.pfvtctl (Implicit type of VT Control Register register)
 *   vt_en	(size 1, offset 0, init 0):	RW	Virtualization Enabled Mode
 *   _anon1	(size 6, offset 1, init 0):	RSVD	_
 *   def_pl	(size 6, offset 7, init 0):	RW	Default pool
 *   _anon13	(size 16, offset 13, init 0):	RSVD	_
 *   dis_def_pl	(size 1, offset 29, init 0):	RW	Disable default pool
 *   rpl_en	(size 1, offset 30, init 0):	RW	Replication enable
 *   _anon31	(size 1, offset 31, init 0):	RSVD	_
 */
static inline e10k_pfvtctl_t e10k_pfvtctl_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pfvtctl_t e10k_pfvtctl_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x51b0));
}

static inline e10k_pfvtctl_t e10k_pfvtctl_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pfvtctl_t e10k_pfvtctl_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x51b0));
}

static inline void e10k_pfvtctl_rawwr(__DN(t) *_dev, e10k_pfvtctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfvtctl_rawwr(__DN(t) *_dev, e10k_pfvtctl_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x51b0, _regval);
}

static inline void e10k_pfvtctl_wr(__DN(t) *_dev, e10k_pfvtctl_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfvtctl_wr(__DN(t) *_dev, e10k_pfvtctl_t _regval)
{
    _regval = (_regval & 0x60001f81);
    // No MB1 fields present
    _regval = (_regval | (0x9fffe07e & mackerel_read_addr_32(_dev->base, 0x51b0)));
    mackerel_write_addr_32(_dev->base, 0x51b0, _regval);
}

static inline int e10k_pfvtctl_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pfvtctl_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pfvtctl_t _regval = mackerel_read_addr_32(_dev->base, 0x51b0);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pfvtctl (VT Control Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vt_en =\t%" PRIx8 "\t(Virtualization Enabled Mode)\n", e10k_pfvtctl_vt_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " def_pl =\t%" PRIx8 "\t(Default pool)\n", e10k_pfvtctl_def_pl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon13 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " dis_def_pl =\t%" PRIx8 "\t(Disable default pool)\n", e10k_pfvtctl_dis_def_pl_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " rpl_en =\t%" PRIx8 "\t(Replication enable)\n", e10k_pfvtctl_rpl_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon31 is anonymous
    return(_r);
}

static inline uint8_t e10k_pfvtctl_vt_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvtctl_vt_en_rdf(__DN(t) *_dev)
{
    e10k_pfvtctl_t _regval = mackerel_read_addr_32(_dev->base, 0x51b0);
    return(e10k_pfvtctl_vt_en_extract(_regval));
}

static inline uint8_t e10k_pfvtctl_def_pl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvtctl_def_pl_rdf(__DN(t) *_dev)
{
    e10k_pfvtctl_t _regval = mackerel_read_addr_32(_dev->base, 0x51b0);
    return(e10k_pfvtctl_def_pl_extract(_regval));
}

static inline uint8_t e10k_pfvtctl_dis_def_pl_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvtctl_dis_def_pl_rdf(__DN(t) *_dev)
{
    e10k_pfvtctl_t _regval = mackerel_read_addr_32(_dev->base, 0x51b0);
    return(e10k_pfvtctl_dis_def_pl_extract(_regval));
}

static inline uint8_t e10k_pfvtctl_rpl_en_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvtctl_rpl_en_rdf(__DN(t) *_dev)
{
    e10k_pfvtctl_t _regval = mackerel_read_addr_32(_dev->base, 0x51b0);
    return(e10k_pfvtctl_rpl_en_extract(_regval));
}

static inline void e10k_pfvtctl_vt_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfvtctl_vt_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pfvtctl_t _regval = 0x1 & (((e10k_pfvtctl_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x51b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x51b0, _regval);
    // No shadow register to write to
}

static inline void e10k_pfvtctl_def_pl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfvtctl_def_pl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pfvtctl_t _regval = 0x1f80 & (((e10k_pfvtctl_t )(_fieldval)) << 7);
    _regval = (_regval | (0xffffe07f & mackerel_read_addr_32(_dev->base, 0x51b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x51b0, _regval);
    // No shadow register to write to
}

static inline void e10k_pfvtctl_dis_def_pl_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfvtctl_dis_def_pl_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pfvtctl_t _regval = 0x20000000 & (((e10k_pfvtctl_t )(_fieldval)) << 29);
    _regval = (_regval | (0xdfffffff & mackerel_read_addr_32(_dev->base, 0x51b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x51b0, _regval);
    // No shadow register to write to
}

static inline void e10k_pfvtctl_rpl_en_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfvtctl_rpl_en_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pfvtctl_t _regval = 0x40000000 & (((e10k_pfvtctl_t )(_fieldval)) << 30);
    _regval = (_regval | (0xbfffffff & mackerel_read_addr_32(_dev->base, 0x51b0)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x51b0, _regval);
    // No shadow register to write to
}

/*
 * Register pfqde: PF PF Queue Drop Enable Register
 * Type: e10k.pfqde (Implicit type of PF PF Queue Drop Enable Register register)
 *   qde	(size 1, offset 0, init 0):	RW	Enable drop of packets from Rx Queue queue_idx
 *   _anon1	(size 7, offset 1, init 0):	RSVD	_
 *   queue_idx	(size 7, offset 8, init 0):	RW	Queue index referenced
 *   _anon15	(size 1, offset 15, init 0):	RSVD	_
 *   we	(size 1, offset 16, init 0):	RW	Write Enable
 *   re	(size 1, offset 17, init 0):	RW	Read Enable
 *   _anon18	(size 14, offset 18, init 0):	RSVD	_
 */
static inline e10k_pfqde_t e10k_pfqde_rawrd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pfqde_t e10k_pfqde_rawrd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f04));
}

static inline e10k_pfqde_t e10k_pfqde_rd(__DN(t) *_dev) __attribute__ ((always_inline));
static inline e10k_pfqde_t e10k_pfqde_rd(__DN(t) *_dev)
{
    return(mackerel_read_addr_32(_dev->base, 0x2f04));
}

static inline void e10k_pfqde_rawwr(__DN(t) *_dev, e10k_pfqde_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfqde_rawwr(__DN(t) *_dev, e10k_pfqde_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0x2f04, _regval);
}

static inline void e10k_pfqde_wr(__DN(t) *_dev, e10k_pfqde_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfqde_wr(__DN(t) *_dev, e10k_pfqde_t _regval)
{
    _regval = (_regval & 0x37f01);
    // No MB1 fields present
    _regval = (_regval | (0xfffc80fe & mackerel_read_addr_32(_dev->base, 0x2f04)));
    mackerel_write_addr_32(_dev->base, 0x2f04, _regval);
}

static inline int e10k_pfqde_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pfqde_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pfqde_t _regval = mackerel_read_addr_32(_dev->base, 0x2f04);
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register pfqde (PF PF Queue Drop Enable Register): ");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " qde =\t%" PRIx8 "\t(Enable drop of packets from Rx Queue queue_idx)\n", e10k_pfqde_qde_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon1 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " queue_idx =\t%" PRIx8 "\t(Queue index referenced)\n", e10k_pfqde_queue_idx_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon15 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " we =\t%" PRIx8 "\t(Write Enable)\n", e10k_pfqde_we_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " re =\t%" PRIx8 "\t(Read Enable)\n", e10k_pfqde_re_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon18 is anonymous
    return(_r);
}

static inline uint8_t e10k_pfqde_qde_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pfqde_qde_rdf(__DN(t) *_dev)
{
    e10k_pfqde_t _regval = mackerel_read_addr_32(_dev->base, 0x2f04);
    return(e10k_pfqde_qde_extract(_regval));
}

static inline uint8_t e10k_pfqde_queue_idx_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pfqde_queue_idx_rdf(__DN(t) *_dev)
{
    e10k_pfqde_t _regval = mackerel_read_addr_32(_dev->base, 0x2f04);
    return(e10k_pfqde_queue_idx_extract(_regval));
}

static inline uint8_t e10k_pfqde_we_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pfqde_we_rdf(__DN(t) *_dev)
{
    e10k_pfqde_t _regval = mackerel_read_addr_32(_dev->base, 0x2f04);
    return(e10k_pfqde_we_extract(_regval));
}

static inline uint8_t e10k_pfqde_re_rdf(__DN(t) *_dev) __attribute__ ((always_inline));
static inline uint8_t e10k_pfqde_re_rdf(__DN(t) *_dev)
{
    e10k_pfqde_t _regval = mackerel_read_addr_32(_dev->base, 0x2f04);
    return(e10k_pfqde_re_extract(_regval));
}

static inline void e10k_pfqde_qde_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfqde_qde_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pfqde_t _regval = 0x1 & (((e10k_pfqde_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffffffe & mackerel_read_addr_32(_dev->base, 0x2f04)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2f04, _regval);
    // No shadow register to write to
}

static inline void e10k_pfqde_queue_idx_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfqde_queue_idx_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pfqde_t _regval = 0x7f00 & (((e10k_pfqde_t )(_fieldval)) << 8);
    _regval = (_regval | (0xffff80ff & mackerel_read_addr_32(_dev->base, 0x2f04)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2f04, _regval);
    // No shadow register to write to
}

static inline void e10k_pfqde_we_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfqde_we_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pfqde_t _regval = 0x10000 & (((e10k_pfqde_t )(_fieldval)) << 16);
    _regval = (_regval | (0xfffeffff & mackerel_read_addr_32(_dev->base, 0x2f04)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2f04, _regval);
    // No shadow register to write to
}

static inline void e10k_pfqde_re_wrf(__DN(t) *_dev, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfqde_re_wrf(__DN(t) *_dev, uint8_t _fieldval)
{
    e10k_pfqde_t _regval = 0x20000 & (((e10k_pfqde_t )(_fieldval)) << 17);
    _regval = (_regval | (0xfffdffff & mackerel_read_addr_32(_dev->base, 0x2f04)));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0x2f04, _regval);
    // No shadow register to write to
}

/*
 * Register array pfvlvf: PF VM VLAN Pool Filter
 * Type: e10k.pfvlvf (Implicit type of PF VM VLAN Pool Filter register array)
 *   vlan_id	(size 12, offset 0, init 0):	RW	VLAN tag for pool VLAN filter n
 *   _anon12	(size 19, offset 12, init 0):	RSVD	_
 *   vi_en	(size 1, offset 31, init 0):	RW	VLAN Id Enable
 */
static const size_t e10k_pfvlvf_length = 64;
static inline e10k_pfvlvf_t e10k_pfvlvf_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_pfvlvf_t e10k_pfvlvf_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xf100 + (_i * (32 / 8))));
}

static inline e10k_pfvlvf_t e10k_pfvlvf_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_pfvlvf_t e10k_pfvlvf_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xf100 + (_i * (32 / 8))));
}

static inline void e10k_pfvlvf_rawwr(__DN(t) *_dev, int _i, e10k_pfvlvf_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfvlvf_rawwr(__DN(t) *_dev, int _i, e10k_pfvlvf_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)), _regval);
}

static inline void e10k_pfvlvf_wr(__DN(t) *_dev, int _i, e10k_pfvlvf_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfvlvf_wr(__DN(t) *_dev, int _i, e10k_pfvlvf_t _regval)
{
    _regval = (_regval & 0x80000fff);
    // No MB1 fields present
    _regval = (_regval | (0x7ffff000 & mackerel_read_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)))));
    mackerel_write_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)), _regval);
}

static inline int e10k_pfvlvf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_pfvlvf_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pfvlvf_t _regval = mackerel_read_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "pfvlvf", _i, "PF VM VLAN Pool Filter");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vlan_id =\t%" PRIx16 "\t(VLAN tag for pool VLAN filter n)\n", e10k_pfvlvf_vlan_id_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    // _anon12 is anonymous
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " vi_en =\t%" PRIx8 "\t(VLAN Id Enable)\n", e10k_pfvlvf_vi_en_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_pfvlvf_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pfvlvf_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 64; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_pfvlvf_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint16_t e10k_pfvlvf_vlan_id_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint16_t e10k_pfvlvf_vlan_id_rdf(__DN(t) *_dev, int _i)
{
    e10k_pfvlvf_t _regval = mackerel_read_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)));
    return(e10k_pfvlvf_vlan_id_extract(_regval));
}

static inline uint8_t e10k_pfvlvf_vi_en_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint8_t e10k_pfvlvf_vi_en_rdf(__DN(t) *_dev, int _i)
{
    e10k_pfvlvf_t _regval = mackerel_read_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)));
    return(e10k_pfvlvf_vi_en_extract(_regval));
}

static inline void e10k_pfvlvf_vlan_id_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfvlvf_vlan_id_wrf(__DN(t) *_dev, int _i, uint16_t _fieldval)
{
    e10k_pfvlvf_t _regval = 0xfff & (((e10k_pfvlvf_t )(_fieldval)) << 0);
    _regval = (_regval | (0xfffff000 & mackerel_read_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline void e10k_pfvlvf_vi_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfvlvf_vi_en_wrf(__DN(t) *_dev, int _i, uint8_t _fieldval)
{
    e10k_pfvlvf_t _regval = 0x80000000 & (((e10k_pfvlvf_t )(_fieldval)) << 31);
    _regval = (_regval | (0x7fffffff & mackerel_read_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)))));
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf100 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array pfvlvfb: PF VM VLAN Pool Filter Bitmap
 * Type: e10k.pfvlvfb (Implicit type of PF VM VLAN Pool Filter Bitmap register array)
 *   pool_ena	(size 32, offset 0, init 0):	RW	Pool Enable Bit Array
 */
static const size_t e10k_pfvlvfb_length = 128;
static inline e10k_pfvlvfb_t e10k_pfvlvfb_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_pfvlvfb_t e10k_pfvlvfb_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xf200 + (_i * (32 / 8))));
}

static inline e10k_pfvlvfb_t e10k_pfvlvfb_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_pfvlvfb_t e10k_pfvlvfb_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xf200 + (_i * (32 / 8))));
}

static inline void e10k_pfvlvfb_rawwr(__DN(t) *_dev, int _i, e10k_pfvlvfb_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfvlvfb_rawwr(__DN(t) *_dev, int _i, e10k_pfvlvfb_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf200 + (_i * (32 / 8)), _regval);
}

static inline void e10k_pfvlvfb_wr(__DN(t) *_dev, int _i, e10k_pfvlvfb_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfvlvfb_wr(__DN(t) *_dev, int _i, e10k_pfvlvfb_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xf200 + (_i * (32 / 8)), _regval);
}

static inline int e10k_pfvlvfb_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_pfvlvfb_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pfvlvfb_t _regval = mackerel_read_addr_32(_dev->base, 0xf200 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "pfvlvfb", _i, "PF VM VLAN Pool Filter Bitmap");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " pool_ena =\t%" PRIx32 "\t(Pool Enable Bit Array)\n", e10k_pfvlvfb_pool_ena_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_pfvlvfb_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pfvlvfb_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_pfvlvfb_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_pfvlvfb_pool_ena_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_pfvlvfb_pool_ena_rdf(__DN(t) *_dev, int _i)
{
    e10k_pfvlvfb_t _regval = mackerel_read_addr_32(_dev->base, 0xf200 + (_i * (32 / 8)));
    return(e10k_pfvlvfb_pool_ena_extract(_regval));
}

static inline void e10k_pfvlvfb_pool_ena_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfvlvfb_pool_ena_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_pfvlvfb_t _regval = 0xffffffff & (((e10k_pfvlvfb_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf200 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

/*
 * Register array pfuta: PF Unicast Table Array
 * Type: e10k.pfuta (Implicit type of PF Unicast Table Array register array)
 *   bitvec	(size 32, offset 0, init 0):	RW	Bit Vector
 */
static const size_t e10k_pfuta_length = 128;
static inline e10k_pfuta_t e10k_pfuta_rawrd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_pfuta_t e10k_pfuta_rawrd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xf400 + (_i * (32 / 8))));
}

static inline e10k_pfuta_t e10k_pfuta_rd(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline e10k_pfuta_t e10k_pfuta_rd(__DN(t) *_dev, int _i)
{
    return(mackerel_read_addr_32(_dev->base, 0xf400 + (_i * (32 / 8))));
}

static inline void e10k_pfuta_rawwr(__DN(t) *_dev, int _i, e10k_pfuta_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfuta_rawwr(__DN(t) *_dev, int _i, e10k_pfuta_t _regval)
{
    mackerel_write_addr_32(_dev->base, 0xf400 + (_i * (32 / 8)), _regval);
}

static inline void e10k_pfuta_wr(__DN(t) *_dev, int _i, e10k_pfuta_t _regval) __attribute__ ((always_inline));
static inline void e10k_pfuta_wr(__DN(t) *_dev, int _i, e10k_pfuta_t _regval)
{
    // No MB0 or RSVD fields present
    // No MB1 fields present
    // No pre-read of register required
    mackerel_write_addr_32(_dev->base, 0xf400 + (_i * (32 / 8)), _regval);
}

static inline int e10k_pfuta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline int e10k_pfuta_pri(char *_s, size_t _size, __DN(t) *_dev, int _i)
{
    int _r = 0;
    int _avail;
    int _rc;
    e10k_pfuta_t _regval = mackerel_read_addr_32(_dev->base, 0xf400 + (_i * (32 / 8)));
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Register %s[%d] (%s): ", "pfuta", _i, "PF Unicast Table Array");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, " bitvec =\t%" PRIx32 "\t(Bit Vector)\n", e10k_pfuta_bitvec_extract(_regval));
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

static inline int e10k_pfuta_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pfuta_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    int _i;
    for( _i = 0; _i < 128; _i++) {
        _avail = ((_r > _size) ? 0 : (_size - _r));
        _rc = e10k_pfuta_pri(_s + _r, _avail, _dev, _i);
        if ((_rc > 0) && (_rc < _avail)) {
            _r = (_r + _rc);
        }
    }
    return(_r);
}

static inline uint32_t e10k_pfuta_bitvec_rdf(__DN(t) *_dev, int _i) __attribute__ ((always_inline));
static inline uint32_t e10k_pfuta_bitvec_rdf(__DN(t) *_dev, int _i)
{
    e10k_pfuta_t _regval = mackerel_read_addr_32(_dev->base, 0xf400 + (_i * (32 / 8)));
    return(e10k_pfuta_bitvec_extract(_regval));
}

static inline void e10k_pfuta_bitvec_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval) __attribute__ ((always_inline));
static inline void e10k_pfuta_bitvec_wrf(__DN(t) *_dev, int _i, uint32_t _fieldval)
{
    e10k_pfuta_t _regval = 0xffffffff & (((e10k_pfuta_t )(_fieldval)) << 0);
    // No pre-read of register required
    // No read of register shadow required
    // No MB0 fields present
    // No MB1 fields present
    mackerel_write_addr_32(_dev->base, 0xf400 + (_i * (32 / 8)), _regval);
    // No shadow register to write to
}

static inline int e10k_pr(char *_s, size_t _size, __DN(t) *_dev) __attribute__ ((always_inline));
static inline int e10k_pr(char *_s, size_t _size, __DN(t) *_dev)
{
    int _r = 0;
    int _avail;
    int _rc;
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "Dump of device e10k (Intel 82599 10 GbE Controller):\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_status_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ctrl_ext_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_esdp_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_i2cctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ledctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_exvet_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eec_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eerd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fla_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eemngctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eemngdata_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_flmngctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_flmngdata_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_flop_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_grc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pfctop_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fcttv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fcrtl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fcrth_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fcrtv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tfcs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fccfg_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gcr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gscl_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gscl_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gscl5_8_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gscn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_factps_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pciephyadr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pciephydat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_swsm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fwsm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_swfw_sync_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gcr_ext_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mrevid_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_picause_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_piena_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eicr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eics_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eims_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eimc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eiac_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eiam_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eicsn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eimsn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eimcn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eiamn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eitrsel_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eitr_l_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_eitr_h_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_l34timir_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_llithresh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_imirvp_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ivar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ivar_misc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gpie_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pbacl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vlnctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mcstctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_psrtype_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxcsum_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rfctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ral_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mpsar_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_vfta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mrqc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rqtc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rssrk_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_reta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_saqf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_daqf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_sdpqf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ftqf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_synqf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_etqf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_etqs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxfeccerr0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdbal_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdbal_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdbah_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdbah_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdlen_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdlen_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdh_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdh_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdt_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdt_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxdctl_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxdctl_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_srrctl_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_srrctl_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rdrxctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxpbsize_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxmemwrap_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rscdbu_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rscctl_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rscctl_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dtxmxszrq_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dmatxctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dtxtcpflgl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dtxtcpflgh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tdbal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tdbah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tdlen_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tdh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tdt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_txdctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tdwbal_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tdwbah_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_txpbsize_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mngtxmap_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mtqc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_txpbthresh_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rtrpcs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rttdcs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rttpcs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rtrup2tc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rttup2tc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rtrpt4c_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rttdt2c_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rttpt2c_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rttdqsel_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rttdt1c_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rttbcnrc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dca_rxctrl_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dca_rxctrl_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dca_txctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dca_id_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_dca_ctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_secrxctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_secrxstat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tcptimer_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirctrl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirhkey_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirskey_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirdip4m_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirsip4m_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirtcpm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirudpm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirip6m_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirm_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirfree_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirlen_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirustat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirfstat_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirmatch_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirmiss_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirsipv6_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdiripsa_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdiripda_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirport_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirvlan_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdirhash_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fdircmd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcs1gcfig_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcs1glctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcs1glsta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcs1gana_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcs1ganlp_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcs1gannp_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcs1ganlpnp_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_hlreg0_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_hlreg1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pap_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_msca_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_msrwd_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_maxfrs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcss1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pcss2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_xpcss_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_serdesc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_macs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_autoc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_links_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_links2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_autoc2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_anlp1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_anlp2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mmngc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_anlpnp1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_anlpnp2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_krpcsfc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_krpcss_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fecs1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fecs2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_corectl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_smadarctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mflcn_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_sgmiic_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_crcerrs_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_illerrc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_errbc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxmpc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mlfc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mrfc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rlec_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxnfgpc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rxdgpc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_gptc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_txdgpc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_ruc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rfc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_roc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_rjc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mngprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mngpdc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tpr_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_tpt_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mspdc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_qprc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_qprdc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fhft_1_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_fhft_2_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mavtv_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mfutp_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_metf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_manc_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mfval_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_manc2h_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mdef_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_mdef_ext_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pfvtctl_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pfqde_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pfvlvf_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pfvlvfb_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = e10k_pfuta_pr(_s + _r, _avail, _dev);
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "End of dump of device e10k\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    _avail = ((_r > _size) ? 0 : (_size - _r));
    _rc = snprintf(_s + _r, _avail, "-------------------------\n");
    if ((_rc > 0) && (_rc < _avail)) {
        _r = (_r + _rc);
    }
    return(_r);
}

#undef __DN
#endif // __e10k_DEV_H
