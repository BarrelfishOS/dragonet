## -*- mode: python; coding: utf-8 -*-

include('memcached_definitions.inc')
include('useful_funs.inc')
AGGREGATOR='summary'
#AGGREGATOR='timeseries'
DESCRIPTION='Memcached Transactions'
DEFAULTS={'PLOT': 'lbest'}
TESTNAME='UDP_RR'
#ITERATIONS=3

RESULT_LOCATION_BASE = '%s_%s' % (RESULT_LOCATION_BASE2, TESTNAME.strip().replace(' ', ''))
# NOTE: The RESULT_LOCATION_BASE  should have absolute path
# NOTE: This location will be created if not present


def getInterruptLines(minfo):
    netdev = minfo["EGRESS_INFO"]["iface"]
    if netdev == None or netdev == 'lo' or netdev == "" :
        return ""
    if not 'INTERRUPTS' in  minfo["EGRESS_INFO"].keys():
        return ""
    ints = minfo["EGRESS_INFO"]['INTERRUPTS']
    if ints == None or ints == 'lo' or ints == "" :
        return ""
    return "-I %s" % (ints)

def dstatCmd(mname, outBase=RESULT_LOCATION_BASE, outfname='dstat_out.dstat',
            outjson='dstat_out.json',
            netdev='lo', cpus='3,5',
            runtime=TOTAL_LENGTH,
            interrupts=""
            ):

    if outfname == None or outfname == "" or outfname == False :
        outfname = '/dev/null'
    else :
        outfilename = ('%s_%s/%s' % (RESULT_LOCATION_BASE, mname, outfname))



    outjsonname = ('%s_%s/%s' % (RESULT_LOCATION_BASE, mname, outjson))
    cmd = '../dstat/dstat --nocolor -J %s -ciny -C%s -N %s %s 1 %d > %s ; cat %s' % (
                   outjsonname, cpus, netdev, interrupts, runtime, outfilename, outjsonname)
    return cmd



TOOLS_LOCATION1 = '${HOME}/dragonet/benchmarking/netperf-wrapper/'
TOOLS_LOCATION2 = '${HOME}/git/dragonet/benchmarking/netperf-wrapper/'

def toCoreList(clist):
    ret = ""
    for c in clist:
        if ret == "" :
            ret = "%d" % (c)
        else :
            ret = "%s,%d" % (ret, c)
    return ret

def toCoreListDstat(clist):
    ret = "%d-%d" % (min(clist), max(clist))
    return ret

def debug_server_core():
    ans = map((lambda x: x % int(SERVERS_CORECOUNT[SERVERS[0]])), range(2, (2+SERVER_CORES)))
    print "server cores = %s " %(ans)
    return ans

server_core = debug_server_core()

server_names=SERVERS
client_names=CLIENTS
server_if = SERVERS_IF
client_if = CLIENTS_IF
echo_server_name = ECHO_SERVER
echo_server_cmds = SRV_CMDS[echo_server_name]
psize = PKT_SIZE
brustsize = BRUST_SIZE

def chunks(l, n):
    """ Yield successive n-sized chunks from l.  """
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

# generates cores to use list while avoiding assigning same core to two
# instances on same machine.
# Essentially it allows having same client multiple times in list of clients
def gen_core_list(mlist):
    cores_to_use = []
    for i in range(0,len(mlist)):
        m = mlist[i]
        existing_duplicates = [x for x in mlist[0:i] if x == m]
        init_core = 2 + (len(existing_duplicates) * CLIENT_CORES)
        # rouning the core id's with number of cores available
        core_use_order = map(
                                (lambda x: x % int(CLIENTS_CORECOUNT[m])),
                                range(init_core, (init_core + CLIENT_CORES))
                            )
        cores_to_use.append(core_use_order)
    print "Cores used by clients: %s" % (cores_to_use)
    return cores_to_use

client_core_list = gen_core_list(client_names)
expected_tps = "%dk" % (BRUST_SIZE)
#client_window_size = "%dk" % (BRUST_SIZE)
client_window_size = "1k"
per_thread_concurrency = 128

per_thread_concurrency_SP = 1
client_window_size_SP = client_window_size
expected_tps_SP = expected_tps

server_onload = SERVER_ONLOAD_CMDLINE

if [echo_server_name] == "netserver" :
    NO_NETPERF = ""
    print "Starting netserver on server machine"
else :
    print "Assuming no netserver, pointing to default echo port 7"
    NO_NETPERF = "-N"

custom_header = "pkt=%d, brust=%d, srv=%s, onload=%s" % (psize,
            brustsize,
            echo_server_name,
            server_onload,
            )

def create_special_client(id):
    client_core_list_SP = client_core_list[id][0:1]
    # FIXME: make sure that id is smaller than client_names
    cl = ('clieSP%d' % (id),
         {
          'deployment_host': client_names[id],
          'result_location': '%s_clieSP%d' % (RESULT_LOCATION_BASE, id),
          'tools_location': TOOLS_LOCATION1,
          'is_server': False,
          'TOOLS': o([
            ( 'memaslSP%d' % (id),
            {
                'command': 'taskset -c %s %s -T%d -w %s --tps=%s -c %d -s %s:%s' % (
                    toCoreList(client_core_list_SP), MEMASLAP_CMD,
                    len(client_core_list_SP),
                    client_window_size_SP,
                    #client_request_size, -X
                    expected_tps_SP,
                    len(client_core_list_SP) * per_thread_concurrency_SP,
                    TARGET,
                    echo_server_cmds['client_extra_opts']),
                'runner': 'memaslap_sumary',
                'units': 'Gbits/s',
                'wait_for': True,
                'init_cmd': ["sleep 1"],
                'out_cmd': [],
                'kill_cmd': ["sudo killall memaslap || true"],
            }),

            ('dstat',
            {
                'command': dstatCmd (mname = 'clieSP%d' % (id),
                    cpus=toCoreList(client_core_list_SP), netdev=client_if[client_names[id]]),
                'runner': 'dstat_json',
                'wait_for': True,
                'init_cmd': [],
                'out_cmd': [],
                'kill_cmd': [],
            }),
            ]),
          })
    return cl


def create_client(id):
    # FIXME: make sure that id is smaller than client_names
    cl = ('client%d' % (id),
         {
          'deployment_host': client_names[id],
          'result_location': '%s_client%d' % (RESULT_LOCATION_BASE, id),
          'tools_location': TOOLS_LOCATION1,
          'is_server': False,
          'TOOLS': o([
            ( 'memaslap%d' % (id),
            {
                'command': 'taskset -c %s %s -T%d -w %s --tps=%s -c %d -s %s:%s' % (
                    toCoreList(client_core_list[id]), MEMASLAP_CMD,
                    len(client_core_list[id]),
                    client_window_size,
                    #client_request_size, -X
                    expected_tps,
                    len(client_core_list[id]) * per_thread_concurrency,
                    TARGET,
                    echo_server_cmds['client_extra_opts']),
                'runner': 'memaslap_sumary',
                'units': 'Gbits/s',
                'wait_for': True,
                'init_cmd': ["sleep 1"],
                'out_cmd': [],
                'kill_cmd': ["sudo killall memaslap || true"],
            }),

            ('dstat',
            {
                'command': dstatCmd (mname = 'client%d' % (id),
                    cpus=toCoreList(client_core_list[id]), netdev=client_if[client_names[id]]),
                'runner': 'dstat_json',
                'wait_for': True,
                'init_cmd': [],
                'out_cmd': [],
                'kill_cmd': [],
            }),
            ]),
          })
    return cl

def create_client_list(client_names, startid=SPECIAL_CLIENTS_COUNT):
    clist = []
    if startid >= len(client_names):
        return clist
    for i in range(startid, len(client_names)):
       clist.append(create_client(i))
    return clist

def create_special_client_list(client_names, spcount=SPECIAL_CLIENTS_COUNT):
    clist = []
    if spcount > len(client_names):
        spcount = len(client_names)
    for i in range(0, spcount):
       clist.append(create_special_client(i))
    return clist

def create_special_client_attr(id, mname, attr, label, func):
    if label == None or label == "" :
        label = attr
    label = ("SP_%s_%d_%s" % (label, id, mname))
    return result_attr_wrapper(attr, c="memaslSP%d" % (id), l=label, func=func)


def create_special_client_attr_list(client_names,  attr, label=None,
                    func=None, spcount=SPECIAL_CLIENTS_COUNT):
    clist = []
    if spcount > len(client_names):
        spcount = len(client_names)
    for i in range(0, spcount):
       clist.append(create_special_client_attr(i, client_names[i], attr, label, func))
    return clist


def create_client_attr(id, mname, attr, label, func):
    if label == None or label == "" :
        label = attr
    label = ("%s_%d_%s" % (label, id, mname))
    return result_attr_wrapper(attr, c="memaslap%d" % (id), l=label, func=func)


def create_client_attr_list(client_names,  attr, label=None, func=None, startid=SPECIAL_CLIENTS_COUNT):
    clist = []
    if startid >= len(client_names):
        return clist
    for i in range(startid, len(client_names)):
       clist.append(create_client_attr(i, client_names[i], attr, label, func))
    return clist


DATA_SETS = o(
        [('server-1',
         {
          'deployment_host': server_names[0],
          'result_location': '%s_server1' % (RESULT_LOCATION_BASE),
          'tools_location': TOOLS_LOCATION1,
          'is_server': True,
          'TOOLS': o([
            ( 'memcached',
            {
                'command': 'sudo taskset -c %s %s %s -t %d -l %s' % (
                    toCoreList(server_core), server_onload,
                    echo_server_cmds['exec_cmd'],
                    len(server_core),
                    TARGET),
                'runner': 'process',
                'units': 'Gbits/s',
                'wait_for': False,
                'init_cmd': echo_server_cmds['init_cmd'],
                'kill_cmd': echo_server_cmds['kill_cmd'],
                'out_cmd': echo_server_cmds['out_cmd'],
            }),

            ('dstat',
            {
                'command': dstatCmd (mname = 'server1',
                    cpus=toCoreList(server_core), netdev=server_if[server_names[0]],
                    interrupts=getInterruptLines(MINFO_SERVER[server_names[0]])),
                'runner': 'dstat_json',
                'wait_for': True,
                'init_cmd': [],
                'out_cmd': [],
                'kill_cmd': [],
            }),
            ])}
        )]
        + create_special_client_list(client_names)
        + create_client_list(client_names)
        )


def valid_tps(vals) :
    if vals == None or vals == []:
        return 0
    if min(vals) == 0 :
        return 0
    else:
        return sum(vals)

ATTRIBUTES = o([
    ( 'attrs',
        { 'attrlist' : [
                    meta_attr_wrapper('ECHO_SERVER', l="Server"),
                    meta_attr_wrapper('USE_TCP'),
                    meta_attr_wrapper('SERVER_ONLOAD_CMDLINE', l="Onload"),
                    meta_attr_wrapper('CLIENTS', agg=(lambda x: len(x) - SPECIAL_CLIENTS_COUNT)),
                    result_attr_wrapper('threads count', c="memaslap%d"% (SPECIAL_CLIENTS_COUNT)),
                    result_attr_wrapper('concurrency', c="memaslap%d" % (SPECIAL_CLIENTS_COUNT)),
                    result_attr_wrapper('windows size', c="memaslap%d" % (SPECIAL_CLIENTS_COUNT), func=get_result_str),
                    result_attr_wrapper('RESULT', c="memaslap", l="Valid TPS", agg=valid_tps),
                    result_attr_wrapper('get_misses', c="memaslap", l="total get_misses"),
                    result_attr_wrapper('Get_Avg', c="memaslap", l="get_avg", agg=myavg),
                    ]
                    + create_special_client_attr_list(client_names, attr= 'cmd_get')
                    + create_special_client_attr_list(client_names, attr= 'Get_Min')
                    + create_special_client_attr_list(client_names, attr= 'Get_Avg')
                    + create_special_client_attr_list(client_names, attr= 'Get_Max')
                    + create_special_client_attr_list(client_names, attr= 'RESULT')

                    + create_client_attr_list(client_names, attr= 'cmd_get')
                    + create_client_attr_list(client_names, attr= 'Get_Min')
                    + create_client_attr_list(client_names, attr= 'Get_Avg')
                    + create_client_attr_list(client_names, attr= 'Get_Max')
                    + create_client_attr_list(client_names, attr= 'RESULT')
                    + create_client_attr_list(client_names, attr= 'Net_rate', func=get_result_str)
                    + [
                    {
                    'data': get_cpu2,
                    'args' : {'takeAvg': True, 'mname':'server-1',
                        'coreidlist' : server_core},
                    'label': 'Server CPU'
                    },
#                    {
#                    'data': get_cpu2,
#                    'args' : {'takeAvg': True, 'mname':'client0',
#                        'coreidlist' : client_core_list[0] },
#                    'label': 'Client0 CPU'
#                    },
#                   {
#                    'data': get_interrupts,
#                    'args' : {
#                            'mname': 'server-1',
#                            'takeAvg': True},
#                    'label': 'NIC Interrupts'
#                   },

                    meta_attr_wrapper('TARGET'),
                    meta_attr_wrapper('TITLE'),
                ]
        }
    )
])


PLOTS = o([
    ])

#########################################################




