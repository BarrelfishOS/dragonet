HARDWARE FILTERS
================
All those filters can only be used on the recieve side.

Etherype Filter
---------------
Count: 8
Assign queue id based on ethertype in ethernet frame
Could be used to sort out ARP or ATA over Ethernet packets


Flow Director Filter
-------------------
Count: 8K-32K Signature XOR 2K-8K Perfect Match
Assign queue id based on (tcp, udp, sctp) ports and IPv4/v6 addresses, vlan
tag and flexible 2-byte tuple in first 64 bytes of pkt.
The flow director filter has two modes, they both use a hash table based on
bucket hashing. Perfect match hashing compares the filters in the bucket
directly to the incoming packets, while signature hashing uses two hashes, one
to find the bucket, and another one to find the matching filter (therefore
collisions are possible).
Flow director filters are probably the way to go for the common filters for
TCP/UDP connections.
Notes: Flow director filter allow only for masking some fields (bitwise)
globally, i.e. one setting for all filters. The offset for the flexible
2-byte tuple too can only be specified globally. Signature and perfect match
filters cannot be used simultaneously.

5-Tuple L4/L3 Filter
--------------------
Count: 128
Allows matches on source and destination ip/port as well as L4 protocol (tcp,
udp, sctp). All those fields can be masked individually.
Could be used to resolve conflicts in flowdirector signature filters, or for
filters that require individual masks (e.g for pure IP packets, or also server
ports) Also every filter is assigned one of 7 priorities, that decide which
filter applies if there are multiple matches.
Notes: Only Matches based on IPv4 addresses



INTERFACE RX
============
Suppose that a method exists to create/initialize a recieve queue that
returns some kind of handle or reference. For this queue multiple filters can be
registered that control which packets are recieved by it.

Limitations by Hardware
-----------------------
From an architectural point of view it would be nice if the card would not have
to know about the used protocols in the filters, but since the card does only
support very specific filters this cannot be avoided. Also features like IP
options make it hard to provide protocol independant filters since the offset of
the payload can vary.

Another point worth mentioning is the order in which the filters are applied.
Since the order of the filters is more or less fixed in the specification
(except for the priorities to order the 5-tuple filters) and could be described
as bottom up (first L2 then 5-tuple (could be used for L3 among others) and then
flow director (which we probably want to use for L4)). So this is probably the
way to specify it for the interface, since emulating another order for some
filters quickly cascades and leads to all filters needing to be emulated in
some configuration.

Since the only way to use bitwise masking of matching fields is globally over
all flow director filters, and since this feature is probably not needed very
often, I suggest to ommit it, or emulate it in software.
This also applies to filtering IP packets using another protocol than
tcp/udp(/sctp), which probably could be implemented using the flex 2-byte
tuple field in the flow director filters, but since masking is configured
globally this would either not be of much use, or severely limit the
possibilites for the other filters.

IPv6 is another source of problems, since the 5-tuple filters don't allow
filtering based on IPv6 addresses. The flow director filters allows it, but
as it does not provide all the features of the 5-tuple filters here some
functionality will probably be need to be implemented in software.


Interface definition
--------------------
Overview of functions to create filters (some quite similar to the current
implementation):
  * rx_filter_etype(q_h queue, uint16_t ethertype)
  * rx_filter_ipv4(q_h queue, ipv4_address_t src, ipv4_address_t dst,
                   ipv4_protocol_t proto);
  * rx_filter_ipv4_tcp(q_h queue, ipv4_address_t saddr, tcp_port_t sport,
                       ipv4_address_t daddr, tcp_port_t dport);
  * rx_filter_ipv4_udp(q_h queue, ipv4_address_t saddr, udp_port_t sport,
                       ipv4_address_t daddr, udp_port_t dport);

Allowing for wildcard values for the ipv4_, tcp_ and udp_ types.


INTERFACE TX
============
For security reasons it would be nice to have filtering on the outgoing queues
as well to make sure an application only sends packets it is allowed to. But
since this is not supported directly by the hardware there is a tradeoff
between security and performance. Either we check the outgoing packets in
software, or we skip the checks and allow the application to send it's
potentially not allowed packets directly.




